<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Survivors</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/emoji-toolkit@7.0.0/lib/js/joypixels.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.production.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #0d1117; /* --bg-medium */
            color: #c9d1d9; /* --text-color */
            overflow: hidden;
        }
        .font-press-start {
            font-family: 'Press Start 2P', cursive;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0d1117; /* --bg-medium */
        }
        ::-webkit-scrollbar-thumb {
            background: #30363d; /* --border-color */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #2f81f7; /* --player-color */
        }
        
        /* Custom scrollbar for the skin list */
        #skin-list-container::-webkit-scrollbar-thumb {
             background: #ffc107; /* --text-yellow */
        }

        .health-bar-fill.low { background-color: #f85149 !important; } /* --enemy-color */

        /* General focus outline for accessibility */
        *:focus-visible {
            outline: 3px solid #2f81f7; /* --player-color */
            outline-offset: 2px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-fadeIn { animation: fadeIn 0.5s ease-out forwards; }
        
        @keyframes toastInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes toastOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        .toast-in { animation: toastInRight 0.5s ease-out forwards; }
        .toast-out { animation: toastOutRight 0.5s ease-in forwards; }

        /* For Tailwind accent color compatibility if needed */
        .accent-player-color {
            accent-color: var(--player-color, #2f81f7);
        }

        /* --- TALENT TREE & MAIN MENU NEW STYLES --- */
        @keyframes hexgrid-scroll {
            0% { background-position: 0 0; }
            100% { background-position: -104px 60px; }
        }
        .hub-background {
            background-color: #010409;
            background-image:
                radial-gradient(ellipse at center, rgba(13, 17, 23, 0.5) 0%, rgba(1, 4, 9, 1) 80%),
                linear-gradient(rgba(13, 17, 23, 0.95) 0%, rgba(13, 17, 23, 0.95) 100%),
                linear-gradient(60deg, #0d1117 1px, transparent 1px, transparent 26px, #0d1117 26px, #0d1117 27px, transparent 27px),
                linear-gradient(120deg, #0d1117 1px, transparent 1px, transparent 26px, #0d1117 26px, #0d1117 27px, transparent 27px),
                linear-gradient(#0d1117 1px, transparent 1px, transparent 26px, #0d1117 26px, #0d1117 27px, transparent 27px);
            background-size: 100% 100%, 100% 100%, 52px 30px, 52px 30px, 52px 30px;
            animation: hexgrid-scroll 5s linear infinite;
        }
        .hexagon-clip {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        .talent-node-shadow-defense { box-shadow: 0 0 15px 3px rgba(59, 130, 246, 0.5); }
        .talent-node-shadow-offense { box-shadow: 0 0 15px 3px rgba(239, 68, 68, 0.5); }
        .talent-node-shadow-utility { box-shadow: 0 0 15px 3px rgba(251, 191, 36, 0.5); }
        .talent-node-shadow-ultimate { box-shadow: 0 0 20px 5px rgba(168, 85, 247, 0.6); }
        .talent-node-shadow-maxed { box-shadow: 0 0 20px 5px rgba(250, 204, 21, 0.7); }
        .talent-node-shadow-corrupted { box-shadow: 0 0 20px 5px rgba(217, 70, 239, 0.6); }

        @keyframes line-flow {
            to { stroke-dashoffset: -100; }
        }
        .line-flow-anim {
            stroke-dasharray: 20 10;
            animation: line-flow 3s linear infinite;
        }
        /* Markdown styles for Patch Notes */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            font-family: 'Press Start 2P', cursive;
            border-bottom: 2px solid #30363d;
            padding-bottom: 0.3em;
            margin-bottom: 1rem;
        }
        .markdown-content h1 { font-size: 1.8rem; color: #38bdf8; }
        .markdown-content h2 { font-size: 1.4rem; color: #67e8f9; }
        .markdown-content h3 { font-size: 1.1rem; color: #a5f3fc; }
        .markdown-content ul { list-style-type: '» '; padding-left: 1.5rem; }
        .markdown-content li { margin-bottom: 0.5rem; }
        .markdown-content strong { color: #facc15; }
        .markdown-content code { background-color: #161b22; padding: 0.2em 0.4em; border-radius: 6px; font-family: 'VT323', monospace; }
    
        .joypixels {
            display: inline-block;  /* Permite que a imagem se comporte como texto */
            height: 1.2em;          /* Define a altura relativa ao tamanho da fonte do texto ao redor */
            width: 1.2em;           /* Define a largura para manter a proporção */
            vertical-align: middle; /* Alinha a imagem verticalmente com o meio do texto */
            margin: 0 0.1em;        /* Adiciona um pequeno espaçamento horizontal */
        }

        /* Opcional: Para os botões do seletor, podemos aumentar um pouco */
        .emoji-picker-button .joypixels {
            height: 1.5em;
            width: 1.5em;
        }

/* --- LEVEL UP SCREEN NEW STYLES (V4 - Frosted Glass Overlay) --- */
.levelup-container {
    position: absolute;
    inset: 0;
    z-index: 20;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    
    /* A MÁGICA ACONTECE AQUI */
    background-color: rgba(1, 4, 9, 0.65); /* Cor escura semi-transparente */
    backdrop-filter: blur(8px) brightness(65%); /* Desfoca e escurece o que está atrás */
    -webkit-backdrop-filter: blur(8px) brightness(65%); /* Suporte para Safari */

    overflow: hidden;
}

/* O resto dos estilos permanece o mesmo, mas são incluídos aqui para garantir */
@keyframes title-fade-in { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
@keyframes core-fade-in { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
@keyframes card-slide-in-left { from { opacity: 0; transform: translateX(-50px); } to { opacity: 1; transform: translateX(0); } }
@keyframes card-slide-in-right { from { opacity: 0; transform: translateX(50px); } to { opacity: 1; transform: translateX(0); } }

.central-conduit { perspective: 1000px; }
.central-conduit-core { width: 140px; height: 140px; position: relative; transform-style: preserve-3d; animation: core-fade-in 0.5s ease-out; }
.conduit-ring { position: absolute; inset: 0; border-radius: 50%; border: 4px solid; animation: spin 12s linear infinite; }
@keyframes spin { from { transform: rotateY(0deg) rotateX(70deg); } to { transform: rotateY(360deg) rotateX(70deg); } }

.upgrade-card-module {
    width: 350px; 
    height: 190px;
    background: linear-gradient(145deg, rgba(22, 27, 34, 0.85), rgba(13, 17, 23, 0.85)); /* Fundo do card um pouco translúcido */
    backdrop-filter: blur(4px); /* Desfoque sutil no próprio card */
    border: 2px solid rgba(48, 54, 61, 0.8);
    border-radius: 0.5rem;
    padding: 1rem 1.25rem;
    position: relative;
    display: flex;
    flex-direction: column;
    transition: all 0.2s ease-in-out;
    cursor: pointer;
    opacity: 0;
    animation-fill-mode: forwards;
}
.upgrade-card-module.from-left { animation-name: card-slide-in-left; }
.upgrade-card-module.from-right { animation-name: card-slide-in-right; }
.upgrade-card-module:hover { border-color: #38bdf8; box-shadow: 0 0 25px rgba(56, 189, 248, 0.4); }
.upgrade-card-module:hover.from-left { transform: translateX(10px); }
.upgrade-card-module:hover.from-right { transform: translateX(-10px); }

.card-connector { position: absolute; top: 50%; transform: translateY(-50%); width: 24px; height: 48px; background-color: #4b5563; border: 2px solid #30363d; }
.card-connector.left { right: -26px; border-radius: 0 8px 8px 0; }
.card-connector.right { left: -26px; border-radius: 8px 0 0 8px; }

.connection-line { stroke-width: 3px; stroke: #2563eb; fill: none; transition: all 0.2s ease-in-out; stroke-dasharray: 4 8; }
.connection-line.active { stroke: #38bdf8; stroke-width: 4px; stroke-dasharray: 30 10; animation: line-flow 1s linear infinite; }

    
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-markdown": "https://esm.sh/react-markdown@8.0.7",
    "remark-gfm": "https://esm.sh/remark-gfm@3.0.1"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="flex flex-col items-center justify-center h-screen m-0 bg-[#0d1117]">
    <div id="root" class="w-full h-full flex flex-col items-center justify-center"></div>
    <script>

    </script>
    <script type="module">
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import ReactMarkdown from 'react-markdown';
        import remarkGfm from 'remark-gfm';
        import { produce } from "https://esm.sh/immer@9.0.12";

        // --- INICIALIZAÇÃO CORRETA DO SUPABASE ---
        const SUPABASE_URL = 'https://ffmxdkgijolpxnslursz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZmbXhka2dpam9scHhuc2x1cnN6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIxOTY0NzIsImV4cCI6MjA2Nzc3MjQ3Mn0.3oczYmSYUABV9veK2LjE9JqGvixupD0FOv2MWMLOuMg';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        if (supabase) {
            console.log("Supabase client initialized.");
        } else {
            console.error("Failed to initialize Supabase client.");
        }

        // --- START OF CUSTOM HOOK: useImmerState ---
        const { useState: useImmerInitialState, useCallback: useImmerCallback } = React;

        const useImmerState = (initialState) => {
            // Usamos o useState normal por baixo dos panos
            const [state, setState] = useImmerInitialState(initialState);
            
            // Criamos uma nova função `setImmerState` que aceita uma "receita" do immer
            const setImmerState = useImmerCallback((updater) => {
                // A mágica acontece aqui: `produce` é chamado dentro do setState
                setState(prevState => produce(prevState, updater));
            }, []);

            // Retornamos o estado e nossa nova função de atualização
            return [state, setImmerState];
        };
        // --- END OF CUSTOM HOOK: useImmerState ---


        // --- START OF SoundManager.ts ---
        const SoundManager = (() => {
            let audioCtx;
            const sounds = {};
            let globalVolume = 0.5; // Default volume
            let isMuted = false;    // Default mute state
            const SOUND_SETTINGS_KEY = 'os_survivors_sound_settings';

            const loadSettings = () => {
                try {
                    const storedSettings = localStorage.getItem(SOUND_SETTINGS_KEY);
                    if (storedSettings) {
                        const parsed = JSON.parse(storedSettings);
                        globalVolume = typeof parsed.volume === 'number' ? Math.max(0, Math.min(1, parsed.volume)) : 0.5;
                        isMuted = typeof parsed.muted === 'boolean' ? parsed.muted : false;
                    }
                } catch (e) {
                    console.error("Error loading sound settings:", e);
                    globalVolume = 0.5;
                    isMuted = false;
                }
            };

            const saveSettings = () => {
                try {
                    localStorage.setItem(SOUND_SETTINGS_KEY, JSON.stringify({ volume: globalVolume, muted: isMuted }));
                } catch (e) {
                    console.error("Error saving sound settings:", e);
                }
            };
            
            const init = () => {
                if (!audioCtx && typeof AudioContext !== 'undefined') {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                loadSettings(); 
            };


            const playTone = (frequency, duration, type = 'sine', individualVolume = 0.3, pan = 0, decay = 0.1) => {
                if (isMuted) return; 
                if (!audioCtx) init();
                if (!audioCtx) return;
                if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.warn("AudioContext resume failed:", e));

                const effectiveVolume = individualVolume * globalVolume; 

                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                
                gainNode.gain.setValueAtTime(effectiveVolume, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration + decay);


                if (panner) {
                    panner.pan.setValueAtTime(pan, audioCtx.currentTime);
                    oscillator.connect(panner);
                    panner.connect(gainNode);
                } else {
                    oscillator.connect(gainNode);
                }
                gainNode.connect(audioCtx.destination);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + duration + decay + 0.05); 
            };

            const playNoise = (duration, individualVolume = 0.2, pan = 0, attack = 0.01, decay = 0.1) => {
                if (isMuted) return; 
                if (!audioCtx) init();
                if (!audioCtx) return;
                 if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.warn("AudioContext resume failed:", e));

                const effectiveVolume = individualVolume * globalVolume; 

                const bufferSize = audioCtx.sampleRate * (duration + attack + decay); 
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; 
                }

                const noiseNode = audioCtx.createBufferSource();
                noiseNode.buffer = buffer;
                const gainNode = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

                gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(effectiveVolume, audioCtx.currentTime + attack);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + attack + duration + decay);


                if (panner) {
                    panner.pan.setValueAtTime(pan, audioCtx.currentTime);
                    noiseNode.connect(panner);
                    panner.connect(gainNode);
                } else {
                    noiseNode.connect(gainNode);
                }
                
                gainNode.connect(audioCtx.destination);
                noiseNode.start(audioCtx.currentTime);
                noiseNode.stop(audioCtx.currentTime + attack + duration + decay + 0.05);
            };
            
            sounds.shoot = () => playTone(330, 0.05, 'square', 0.08, -0.2, 0.05); 
            sounds.enemyHit = () => playTone(180, 0.04, 'sawtooth', 0.1, 0.2, 0.04);
            sounds.enemyDie = () => playNoise(0.15, 0.15, Math.random()*0.4 - 0.2, 0.01, 0.1);
            sounds.pickupXP = () => playTone(900, 0.03, 'sine', 0.06, 0, 0.03);
            sounds.pickupHealth = () => playTone(600, 0.15, 'triangle', 0.2, 0, 0.1);
            sounds.levelUp = () => { playTone(523, 0.08, 'sine', 0.25, -0.1, 0.1); setTimeout(() => playTone(659, 0.08, 'sine', 0.25, 0, 0.1), 80); setTimeout(() => playTone(783, 0.12, 'sine', 0.25, 0.1, 0.15), 160); };
            sounds.gameOver = () => { playNoise(0.4, 0.3, 0, 0.05, 0.3); setTimeout(() => playTone(100, 0.6, 'sawtooth', 0.25, 0, 0.5), 80); };
            sounds.playerHit = () => playTone(150, 0.1, 'square', 0.25, 0, 0.1);
            sounds.acidVirusShot = () => playTone(220, 0.08, 'sawtooth', 0.09, 0, 0.1);
            sounds.acidVirusImpact = () => playNoise(0.1, 0.12, 0, 0.01, 0.09); 
            sounds.acidSporeLaunch = () => playTone(600, 0.05, 'sine', 0.1, 0, 0.05); 
            sounds.bossWarning = () => { playTone(130.81, 0.4, 'sawtooth', 0.4); setTimeout(() => playNoise(0.25, 0.25, 0, 0.05, 0.2), 150); };
            sounds.uiClick = () => playTone(700, 0.05, 'triangle', 0.1, 0, 0.05);
            sounds.upgradeSelect = () => playTone(650, 0.08, 'sine', 0.15, 0, 0.08);
            sounds.kernelUnlock = () => { playTone(440, 0.1, 'sine', 0.2); setTimeout(() => playTone(880, 0.15, 'sine', 0.2), 100); };
            sounds.permanentUpgrade = () => playTone(550, 0.12, 'square', 0.18, 0, 0.1);
            sounds.freezeSound = () => playTone(1200, 0.1, 'sine', 0.15, 0, 0.15); 
            sounds.chainLightningSound = () => playTone(800, 0.03, 'sawtooth', 0.12, Math.random()*0.6-0.3, 0.03); 
            sounds.minionSpawn = () => playNoise(0.1, 0.1, Math.random() * 0.5 - 0.25, 0.02, 0.08);
            sounds.minionConvert = () => playTone(880, 0.1, 'triangle', 0.15, 0, 0.1);
            sounds.minionModeSwitch = () => playTone(300, 0.08, 'square', 0.1, 0, 0.08);
            sounds.corruptedZoneAppear = () => playTone(80, 0.3, 'sawtooth', 0.2, 0, 0.2);
            sounds.kernelPanicCharge = () => playTone(70, 1.5, 'sine', 0.4, 0, 0.1);
            sounds.kernelPanicExecute = () => { playNoise(0.6, 0.5, 0, 0.01, 0.4); playTone(50, 0.5, 'square', 0.35, 0, 0.3); };
            sounds.dataStreamFire = () => playTone(450, 0.02, 'triangle', 0.06, Math.random()*0.2-0.1, 0.02);
            sounds.bossPhaseChange = () => { playNoise(0.3, 0.3, 0, 0.02, 0.2); playTone(200, 0.2, 'sawtooth', 0.25, 0, 0.1);};
            sounds.teleportCharge = () => playTone(400, 0.4, 'sine', 0.15, 0, 0.05);
            sounds.teleportExecute = () => playTone(1000, 0.1, 'triangle', 0.2, 0, 0.1);
            sounds.shieldActivate = () => playNoise(0.1, 0.1, 0, 0.01, 0.08);
            sounds.shieldBreak = () => playNoise(0.2, 0.2, 0, 0.05, 0.15);
            sounds.zombieRevive = () => playTone(90, 0.5, 'sawtooth', 0.2, 0, 0.3);
            sounds.laserCharge = () => playTone(200, 1.0, 'sine', 0.3, 0, 0.1);
            sounds.laserFire = () => playNoise(1.5, 0.4, 0, 0.1, 0.5);
            sounds.playerDash = () => playTone(800, 0.08, 'sawtooth', 0.15, 0, 0.1);
            sounds.pickupBuff = () => playTone(1000, 0.1, 'triangle', 0.2, 0, 0.1);
            sounds.cleanseComplete = () => playTone(783, 0.15, 'sine', 0.25, 0, 0.15);
            sounds.enterDebuffZone = () => playTone(120, 0.2, 'square', 0.1, 0, 0.15);
            sounds.defragSwing = () => playNoise(0.08, 0.12, 0, 0.01, 0.07);
            sounds.dataLeechConnect = () => playTone(250, 0.1, 'triangle', 0.1, 0, 0.1);
            sounds.achievementUnlock = () => { playTone(659, 0.08, 'sine', 0.3, -0.2, 0.1); setTimeout(() => playTone(880, 0.15, 'triangle', 0.3, 0.2, 0.15), 100); };
            sounds.eventStart = () => playTone(200, 0.3, 'sawtooth', 0.3, 0, 0.2);
            sounds.eventSuccess = () => { playTone(783, 0.1, 'sine', 0.3); setTimeout(() => playTone(1046, 0.15, 'sine', 0.3), 120); };


            const resumeAudio = () => {
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(e => console.warn("AudioContext resume failed on user interaction:", e));
                }
            };
            
            const interactionEvents = ['click', 'keydown', 'touchstart'];
            const addResumeListeners = () => {
                interactionEvents.forEach(event => {
                    document.addEventListener(event, resumeAudio, { once: true });
                });
            };
            
            addResumeListeners();


            return {
                init, 
                play: (soundName) => {
                    if (isMuted) return;
                    if (!audioCtx) init(); 
                    if (!audioCtx) return; 
                    
                    if (audioCtx.state === 'suspended') {
                         audioCtx.resume().then(() => {
                            if (sounds[soundName]) {
                                sounds[soundName]();
                            } else {
                                console.warn(`Sound ${soundName} not found.`);
                            }
                         }).catch(e => console.warn("AudioContext resume failed in play:", e));
                         return; 
                    }


                    if (sounds[soundName]) {
                        sounds[soundName]();
                    } else {
                        console.warn(`Sound ${soundName} not found.`);
                    }
                },
                getVolume: () => globalVolume,
                setVolume: (level) => {
                    globalVolume = Math.max(0, Math.min(1, parseFloat(level)));
                    saveSettings();
                },
                isMuted: () => isMuted,
                setMuted: (mute) => {
                    isMuted = !!mute;
                    saveSettings();
                }
            };
        })();
        // --- END OF SoundManager.ts ---

        // --- START OF types.ts (converted to JS objects/comments) ---
        const GameScreenState = {
            // Screens with no main layout
            INTRO: 0,
            
            // Screens for the game UI
            PLAYING: 1,
            LEVEL_UP: 2,
            GAME_OVER: 3,
            PAUSED: 4,
            BOSS_WARNING: 5,
            BOSS_FIGHT: 6,
            STAGE_CLEAR: 7, 
            STAGE_2_CLEAR: 18,
            STAGE_3_CLEAR: 19,      // --- ALTERADO --- (era ARBITER_DEFEATED)
            NEXUS_DEFEATED: 26,     // --- NOVO ---
            INFINITE_MODE: 20,
            
            // Screens for the new Main Hub Layout
            PROFILE: 27,
            TALENT_TREE: 8,
            RANKING: 10,
            CLASS_SELECTION: 12, 
            ACHIEVEMENTS: 13,
            GLOBAL_STATS: 14,
            DECOMPILER: 15,
            SKIN_SELECTION: 16,
            EVOLUTION_GUIDE: 17,
            ARSENAL: 21,
            MODE_SELECTION: 22,
            PATCH_NOTES: 23,
            SETTINGS: 24,
            CODEX: 25,
            NEXUS_DEFEATED: 26,
            MODIFIER_SELECTION: 33,
            CRISOL_HUB: 28,           // Tela de seleção de câmaras
            CRISOL_CHAMBER: 29,       // Jogando uma câmara finita
            CRISOL_INFINITE: 30,      // Jogando o modo infinito
            CRISOL_RESULT: 31,        // Tela de resultado (vitória/derrota)
            CRISOL_PAUSED: 32,
        };

        const EnemyType = {
            // Fase 1
            DEFAULT: 'default',
            MEMORY_LEAK: 'memory_leak',
            SPYWARE: 'spyware',
            TROJAN_HORSE: 'trojan_horse',
            MALWARE_FRAGMENT: 'malware_fragment',
            ROOTKIT: 'rootkit',
            DDOS_BOT: 'ddos_bot',
            GLITCH_MINION: 'glitch_minion',
            // Fase 2
            PROCESSO_CORROMPIDO: 'processo_corrompido',
            PONTEIRO_NULO: 'ponteiro_nulo',
            SEGMENTO_FALHA: 'segmento_falha',
            PROCESSO_ZUMBI: 'processo_zumbi',
            // Fase 3
            NANITE: 'nanite',
            HEATSINK: 'heatsink',
            IO_CONTROLLER: 'io_controller',
            VOLATILE_PROCESS: 'volatile_process',
            // --- FASE 4 (NOVO) ---
            RECURSIVE_PROCESS: 'recursive_process',
            CHILD_PROCESS: 'child_process',
            ROGUE_FIREWALL: 'rogue_firewall',
            LATENCY_SPIKE: 'latency_spike',
            PROTOCOL_ANOMALY: 'protocol_anomaly',
        };

        const StatusEffectType = {
            SLOW: 'SLOW',
            FREEZE: 'FREEZE',
            VULNERABILITY: 'VULNERABILITY',
            FEAR: 'FEAR',
        };
        
        const TemporaryBuffType = {
            MOVE_SPEED: 'MOVE_SPEED',
            ATTACK_SPEED: 'ATTACK_SPEED',
            DAMAGE_AMP: 'DAMAGE_AMP',
            REGEN: 'REGEN',
            DAMAGE_REDUCTION: 'DAMAGE_REDUCTION',
        };

        const InteractableType = {
            DATA_CACHE: 'DATA_CACHE',
            CORRUPTED_LIBRARY: 'CORRUPTED_LIBRARY',
        };
        
        const BossAttackType = {
            DATA_SMASHER: 'DATA_SMASHER',
            CORRUPTION_WAVE: 'CORRUPTION_WAVE',
            HOSTILE_TAKEOVER: 'HOSTILE_TAKEOVER',
            LOGIC_BOMB: 'LOGIC_BOMB',
            FINAL_JUDGEMENT: 'FINAL_JUDGEMENT'
        };

        // --- END OF types.ts ---

        // --- START OF constants.ts ---
        const CANVAS_WIDTH = 1920;
        const CANVAS_HEIGHT = 1440; 
        const RANKING_KEY = 'os_survivors_ranking_local'; 
        const GLOBAL_STATS_KEY = 'os_survivors_global_stats';
        const DECOMPILER_STATS_KEY = 'os_survivors_decompiler_stats';
        const WEAPON_MASTERY_KEY = 'os_survivors_weapon_mastery_stats';
        const NIGHTMARE_UNLOCKED_KEY = 'os_survivors_nightmare_unlocked';
        const CORRUPTED_KERNELS_KEY = 'os_survivors_corrupted_kernels';
        const MAX_RANKING_ENTRIES = 10;

        // --- START OF SUPABASE INTEGRATION ---

const fetchOnlineRankings = async () => {
    if (!supabase) {
        console.error("Supabase client não está inicializado.");
        return [];
    }
    try {
        // Seleciona todas as colunas da tabela 'rankings'
        // Ordena por 'score' em ordem decrescente
        // Limita o resultado a 10 entradas
        const { data, error } = await supabase
            .from('rankings')
            .select('*')
            .order('score', { ascending: false })
            .limit(10);

        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error("Erro ao buscar ranking do Supabase:", error);
        return [];
    }
};

// Adicione esta constante no topo do seu arquivo, junto com as outras
const BEST_ONLINE_SCORE_KEY = 'os_survivors_best_online_score';

// Substitua a função inteira por esta
const submitScoreToOnlineRanking = async (name, score, time, classId, userId) => {
    if (!supabase || !userId) {
        console.error("Supabase client ou User ID não estão disponíveis. Pontuação não será salva.");
        return;
    }

    try {
        // <<< 1. LÓGICA LOCAL DE VERIFICAÇÃO >>>
        // Pega a melhor pontuação online que já enviamos deste navegador.
        const storedBestScore = parseInt(localStorage.getItem(BEST_ONLINE_SCORE_KEY), 10) || 0;

        // Se a pontuação atual não for maior, não fazemos nada.
        if (score <= storedBestScore) {
            console.log(`Pontuação local (${score}) não é maior que o recorde online salvo (${storedBestScore}). Não será enviada.`);
            return; // PARA A EXECUÇÃO AQUI
        }

        // <<< 2. CHAMADA SIMPLIFICADA PARA O SUPABASE >>>
        // Usamos um 'upsert' que vai INSERIR se o user_id for novo, ou ATUALIZAR se já existir.
        // Como a gente já filtrou a pontuação no passo 1, só atualizaremos com pontuações maiores.
        const { error } = await supabase
            .from('rankings')
            .upsert({
                user_id: String(userId), // A coluna de conflito, deve ser ÚNICA na sua tabela
                name: name.trim() === '' ? 'Anônimo' : name.trim(),
                score: Number(score),
                "time": Number(time), // Nome da coluna entre aspas porque 'time' é palavra reservada em SQL
                class_id: String(classId),
                date: new Date().toLocaleDateString() // Adiciona a data atual
            }, {
                onConflict: 'user_id' // Informa ao Supabase qual coluna usar para detectar conflitos
            });

        if (error) {
            // Se ainda der erro, será mais fácil de depurar.
            console.error("Erro ao fazer upsert da pontuação no Supabase:", error);
            // Possível causa do erro: a coluna 'user_id' não está definida como UNIQUE ou PRIMARY KEY na sua tabela do Supabase.
            throw error;
        }

        // <<< 3. ATUALIZAÇÃO DO RECORDE LOCAL >>>
        // Se o envio foi bem-sucedido, atualizamos o recorde local.
        localStorage.setItem(BEST_ONLINE_SCORE_KEY, score.toString());
        console.log(`Novo recorde online (${score}) salvo localmente e enviado com sucesso!`);

    } catch (error) {
        // O console.error já está dentro da função original.
        // Apenas para garantir que a mensagem de erro seja clara.
        console.error("Falha na função submitScoreToOnlineRanking:", error);
    }
};

const fetchPatchNotesJSON = async () => {
    if (!supabase) {
        console.error("Supabase client não está inicializado.");
        return [];
    }
    try {
        // Seleciona as colunas da tabela 'patch_notes'
        // CORREÇÃO: Ordena pela coluna 'date', que existe na sua tabela.
        const { data, error } = await supabase
            .from('patch_notes')
            .select('title, date, notes')
            .order('date', { ascending: false });

        if (error) throw error;
        
        // O Supabase já retorna os dados prontos, não precisa de JSON.parse
        return data || [];
    } catch (error) {
        console.error("Erro ao buscar patch notes do Supabase:", error);
        throw error;
    }
};

// --- END OF SUPABASE INTEGRATION ---

        const DECOMPILER_TIERS = {
            TIER_1: 600,
            TIER_2: 1200,
            TIER_3: 2400,
            TIER_4: 4800,
        };
        
        const WEAPON_MASTERY_CONFIG = [
            {
                weaponId: 'antivirus',
                name: 'Antivírus',
                icon: '🎯',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+5% de Dano para o Antivírus', bonus: { type: 'damage_multiplier', value: 0.05 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+10% Velocidade de Projétil', bonus: { type: 'projectile_speed', value: 0.10 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Primeiro tiro em um novo alvo sempre é Crítico.', bonus: { type: 'first_shot_crit', value: true } },
                ]
            },
            {
                weaponId: 'firewall',
                name: 'Firewall',
                icon: '🛡️',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+8% de Dano de contato dos orbes', bonus: { type: 'damage_multiplier', value: 0.08 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+15% Raio Orbital', bonus: { type: 'radius_multiplier', value: 0.15 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Orbes de Firewall podem bloquear projéteis inimigos.', bonus: { type: 'projectile_block', value: true } },
                ]
            },
            {
                weaponId: 'acid_virus',
                name: 'Vírus Ácido',
                icon: '🦠',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+10% Dano da Poça de Ácido', bonus: { type: 'dot_damage_multiplier', value: 0.10 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+15% Duração da Poça de Ácido', bonus: { type: 'duration_multiplier', value: 0.15 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Poças de Ácido reduzem a armadura dos inimigos em 10%', bonus: { type: 'armor_shred', value: 0.10 } },
                ]
            },
            {
                weaponId: 'defrag',
                name: 'Desfragmentador',
                icon: '⚔️',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+5% Dano para o Desfragmentador', bonus: { type: 'damage_multiplier', value: 0.05 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '-10% Recarga do Desfragmentador', bonus: { type: 'cooldown_multiplier', value: -0.10 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Atingir 3 ou mais inimigos com um único golpe concede um bônus de velocidade temporário.', bonus: { type: 'speed_on_cleave', value: true } },
                ]
            },
            {
                weaponId: 'data_leech',
                name: 'Data Leech',
                icon: '🔗',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+8% Dano do Data Leech', bonus: { type: 'damage_multiplier', value: 0.08 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+15% Alcance do Raio', bonus: { type: 'range_multiplier', value: 0.15 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'O bônus de dano por ficar parado é acumulado 50% mais rápido.', bonus: { type: 'still_bonus_speed', value: 1.5 } },
                ]
            }
        ];

        // --- START OF game/profileContent.ts ---
        const PROFILE_AVATARS = [
          { id: 'avatar_default', name: 'Processo Padrão', unlockCondition: { type: 'default' }, description: 'Disponível por padrão.' },
          { id: 'avatar_trojan', name: 'Fragmento de Trojan', unlockCondition: { type: 'stat_tracker', stat: 'totalEnemyKills', subType: 'trojan_horse', value: 25 }, description: 'Derrote 25 Trojans.' },
          { id: 'avatar_guardian', name: 'Olhar do Guardião', unlockCondition: { type: 'achievement', id: 'defeat_boss_1' }, description: 'Derrote o Guardião do Núcleo.' },
          { id: 'avatar_nightmare', name: 'Ícone do Pesadelo', unlockCondition: { type: 'achievement', id: 'nightmare_win' }, description: 'Vença o jogo no Modo Pesadelo.' }
        ];

        const PROFILE_TITLES = [
          { id: 'title_survivor', name: 'Sobrevivente', unlockCondition: { type: 'default' }, description: 'Disponível por padrão.' },
          { id: 'title_bug_squasher', name: 'Exterminador de Bugs', unlockCondition: { type: 'stat_tracker', stat: 'totalKills', value: 10000 }, description: 'Derrote 10.000 inimigos.' },
          { id: 'title_legend', name: 'Lenda do Sistema', unlockCondition: { type: 'achievement', id: 'survive_20_min' }, description: 'Sobreviva por 20 minutos.' },
          { id: 'title_architect', name: 'Arquiteto', unlockCondition: { type: 'achievement', id: 'unlock_all_classes' }, description: 'Desbloqueie todas as classes.' }
        ];

        const PROFILE_BANNERS = [
          { id: 'banner_grid', name: 'Grid Padrão', unlockCondition: { type: 'default' }, description: 'Disponível por padrão.' },
          { id: 'banner_circuit', name: 'Placa de Circuito', unlockCondition: { type: 'achievement', id: 'evolve_3_weapons_session' }, description: 'Evolua 3 armas em uma partida.' },
          { id: 'banner_corruption', name: 'Corrupção Vermelha', unlockCondition: { type: 'achievement', id: 'defeat_boss_3' }, description: 'Derrote o Árbitro do Sistema.' }
        ];
        // --- END OF game/profileContent.ts ---


        const GAME_COLORS = {
            BACKGROUND_DARK: '#010409',
            BACKGROUND_MEDIUM: '#0d1117',
            BACKGROUND_STAGE_2: '#0A192F', 
            GRID_STAGE_2: 'rgba(45, 212, 191, 0.1)', 
            BACKGROUND_STAGE_3: '#081426',
            BACKGROUND_STAGE_4_ABYSS: '#04010a', // --- ALTERADO ---
            CIRCUIT_STAGE_4: 'rgba(80, 80, 150, 0.1)', // --- NOVO ---
            DATA_FLOW_CYAN: 'rgba(0, 255, 255, 0.7)', // --- NOVO ---
            DATA_FLOW_MAGENTA: 'rgba(255, 0, 255, 0.7)', // --- NOVO ---
            GRID_STAGE_4: 'rgba(0, 255, 255, 0.1)', // --- NOVO ---
            UNSTABLE_SECTOR_WARNING: 'rgba(255, 100, 0, 0.4)',
            UNSTABLE_SECTOR_DANGER: 'rgba(255, 0, 0, 0.7)',
            BORDER: '#30363d',
            TEXT: '#c9d1d9',
            PLAYER: '#2f81f7',
            ENEMY_DEFAULT: '#f85149',
            ENEMY_MEMORY_LEAK: '#ff9f43',
            ENEMY_SPYWARE: '#8e44ad',
            ENEMY_TROJAN: '#34495e',
            ENEMY_ROOTKIT: '#b71c1c',
            ENEMY_DDOS_BOT: '#00e5ff',
            ENEMY_GLITCH_MINION: 'rgba(220, 20, 60, 0.8)',
            MEMORY_LEAK_TRAIL: 'rgba(255, 159, 67, 0.4)',
            ENEMY_PROCESSO_CORROMPIDO: '#67e8f9',
            ENEMY_PONTEIRO_NULO: '#f472b6',
            ENEMY_SEGMENTO_FALHA: '#fbbf24',
            ENEMY_PROCESSO_ZUMBI: '#a3e635',
            ENEMY_NANITE: '#E5E7EB',
            ENEMY_HEATSINK: '#F97316',
            ENEMY_IO_CONTROLLER: '#A78BFA',
            ENEMY_VOLATILE_PROCESS: '#FACC15',
            // --- FASE 4 CORES (NOVO) ---
            ENEMY_RECURSIVE_PROCESS: '#fb923c',
            ENEMY_CHILD_PROCESS: '#fdba74',
            ENEMY_ROGUE_FIREWALL: '#eab308',
            ENEMY_LATENCY_SPIKE: '#60a5fa',
            ENEMY_PROTOCOL_ANOMALY: '#f472b6',
            SHIELD_EFFECT: 'rgba(191, 219, 254, 0.6)',
            TELEPORT_CHARGE_EFFECT: 'rgba(244, 114, 182, 0.4)',
            PROJECTILE: '#3fb950',
            PROJECTILE_SYSTEM_PURGE: '#76ff03',
            PROJECTILE_HUNTER_SWARM: '#fbc02d',
            PROJECTILE_SHARD: '#82eefd',
            PROJECTILE_CHAIN_LIGHTNING: '#FFFF00', 
            PROJECTILE_DATA_STREAM: '#FF6347', 
            PROJECTILE_ACID_VIRUS: '#a3e635', 
            PROJECTILE_ACID_SPORE: '#c084fc', 
            ACID_PUDDLE: 'rgba(100, 140, 80, 0.25)',
            FIREWALL_ORB: '#a371f7',
            FIREWALL_AEGIS_ORB: '#da70d6',
            FIREWALL_AEGIS_PULSE: 'rgba(218, 112, 214, 0.4)',
            XP_ORB: '#76ff03',
            HEALTH_PICKUP: '#FF6B81', 
            KNOWLEDGE_ORB: '#ffd700',
            DATA_VAULT: '#161b22',
            DATA_VAULT_CIRCUIT: '#ffd700',
            PARTICLE_EXPLOSION: '#ffeb3b',
            CRITICAL_HIT_TEXT: '#ffc107',
            UI_PANEL_BG: 'rgba(13, 17, 23, 0.9)',
            UI_PANEL_BG_SOLID: '#0a0d12',
            PROGRESS_BAR_BG: '#30363d',
            HEALTH_BAR_LOW: '#f85149',
            UPGRADE_CARD_BG: '#0d1117',
            UPGRADE_CARD_HOVER_BORDER: '#2f81f7',
            UPGRADE_CARD_EVOLUTION_BORDER: '#ffd700',
            TEXT_GREEN: '#28a745',
            TEXT_YELLOW: '#ffc107',
            TEXT_RED: '#dc3545',
            TEXT_XP: '#76ff03',
            TEXT_SYSTEM_CORE: '#FFD700',
            TEXT_CORRUPTED_CORE: '#d946ef',
            PLAYER_OVERDRIVE_GLOW: 'rgba(255, 255, 0, 0.7)',
            BOSS_CORE: '#6a0dad',
            BOSS_SHIELD_NODE: '#00BFFF',
            BOSS_PROJECTILE_PHASE1: '#9370DB',
            BOSS_PROJECTILE_PHASE2: '#FF4500',
            BOSS_PULSE_ATTACK: 'rgba(200, 0, 200, 0.3)', 
            BOSS_2_CORE: '#facc15',
            BOSS_2_SUB_ROUTINE: '#ec4899',
            BOSS_2_LASER: 'rgba(250, 80, 80, 0.8)',
            BOSS_2_DATA_WALL: 'rgba(100, 30, 200, 0.6)',
            BOSS_2_ENERGY_WAVE: 'rgba(250, 204, 21, 0.3)',
            BOSS_3_CORE: '#B91C1C',
            BOSS_3_RAM_SOCKET_CORRUPTED: 'rgba(220, 38, 38, 0.8)',
            BOSS_3_RAM_SOCKET_CLEANSE: 'rgba(34, 197, 94, 0.6)',
            BOSS_3_BUS_WARNING: 'rgba(250, 204, 21, 0.5)',
            BOSS_3_BUS_FIRE: 'rgba(239, 68, 68, 0.8)',
            BOSS_3_AURA: 'rgba(147, 51, 234, 0.15)',
            BOSS_3_STATIC_ZONE: 'rgba(107, 33, 168, 0.25)',
            BOSS_3_LOGIC_BOMB: '#fbbf24',
            BOSS_4_CORE: '#ec4899', // --- NOVO ---
            BOSS_4_SUB_ROUTER: '#fde047', // --- NOVO ---
            BOSS_4_DOS_WAVE: 'rgba(236, 72, 153, 0.3)', // --- NOVO ---
            BOSS_4_PORT_SCAN: 'rgba(250, 80, 80, 0.9)', // --- NOVO ---
            CORRUPTED_ZONE: 'rgba(139, 0, 0, 0.5)', 
            KERNEL_PANIC_PULSE_WARNING: 'rgba(255, 0, 0, 0.3)', 
            ENEMY_DOT_EFFECT: 'rgba(124, 252, 0, 0.6)',
            EVASION_PARTICLE: 'rgba(200, 200, 255, 0.8)',
            STATUS_SLOW_TINT: 'rgba(100, 149, 237, 0.3)', 
            STATUS_FREEZE_TINT: 'rgba(173, 216, 230, 0.6)', 
            STATUS_VULNERABILITY_AURA: 'rgba(148, 0, 211, 0.4)', 
            STATUS_FEAR_AURA: 'rgba(255, 127, 80, 0.4)', 
            DATA_CACHE: '#2f81f7',
            CORRUPTED_LIBRARY: 'rgba(220, 20, 60, 0.6)',
            DASH_COOLDOWN_FILL: '#f3f4f6',
            DASH_COOLDOWN_BG: '#4b5563',
            EFFECT_DEFRAG: 'rgba(200, 220, 255, 0.8)',
            EFFECT_DATA_LEECH: '#be29ec',
            ALLIED_MINION: '#00e5ff',
            ACHIEVEMENT_UNLOCKED_BG: '#1a2a44',
            ACHIEVEMENT_LOCKED_BG: '#161b22',
            ACHIEVEMENT_DIFFICULTY_EASY: '#1f7133',
            ACHIEVEMENT_DIFFICULTY_MEDIUM: '#866c1d',
            ACHIEVEMENT_DIFFICULTY_HARD: '#b32c2c',
            ACHIEVEMENT_DIFFICULTY_EPIC: '#6e40c9',
        };

        const STATUS_EFFECT_PARAMS = {
            [StatusEffectType.SLOW]: { baseDuration: 3000, baseMagnitude: 0.6 }, 
            [StatusEffectType.FREEZE]: { baseDuration: 1500 },
            [StatusEffectType.VULNERABILITY]: { baseDuration: 5000, baseMagnitude: 1.2 }, 
            [StatusEffectType.FEAR]: { baseDuration: 2500 },
            CHAIN_LIGHTNING: { baseMaxChains: 2, baseRange: 150, baseDamageMultiplier: 0.70 }
        };

        const DASH_STATS = {
            COOLDOWN: 4000,
            DURATION: 150,
            SPEED_MULTIPLIER: 4.5,
        };

        const INTERACTABLE_STATS = {
            SPAWN_INTERVAL_MIN: 15000,
            SPAWN_INTERVAL_MAX: 25000,
            [InteractableType.DATA_CACHE]: {
                SIZE: 24,
                DURATION: 15000, 
                BUFFS: [
                    { type: TemporaryBuffType.MOVE_SPEED, magnitude: 1.3, duration: 10000, icon: '🏃' },
                    { type: TemporaryBuffType.ATTACK_SPEED, magnitude: 0.75, duration: 10000, icon: '⚡' },
                    { type: TemporaryBuffType.DAMAGE_AMP, magnitude: 1.25, duration: 8000, icon: '💥' },
                    { type: TemporaryBuffType.REGEN, magnitude: 2, duration: 12000, icon: '💉' }
                ]
            },
            [InteractableType.CORRUPTED_LIBRARY]: {
                RADIUS: 100,
                DURATION: 30000,
                CLEANSE_TIME: 3000,
                DECAY_RATE: 0.5,
                DEBUFF_MAGNITUDE: 1.2,
                REWARD_XP_COUNT: 5,
                REWARD_XP_VALUE: 100,
            }
        };

        const PLAYER_INITIAL_STATS = {
            size: 40,
            baseSpeed: 240,
            baseMaxHealth: 100,
            baseXpMagnetRadius: 50,
            baseExpModifier: 1,
            baseCooldownModifier: 1,
            globalDamageFactor: 1,
            baseRegenAmount: 0,
            baseDamageReduction: 0,
            baseCritChance: 0.0, 
            baseCritDamage: 1.5,
            lastRegenTime: 0,
            overdriveActive: false,
            overdriveEndTime: 0,
            overdriveCooldownUntil: 0,
            overdriveDamageBonus: 0,
            lastMoveDirection: { x: 0, y: -1 },
            statusEffectDuration: 1.0, 
            regenAmount: 0, 
        };

        // --- START OF game/classes.ts ---
        const CLASS_DEFINITIONS = [
            {
                id: "class_executor",
                name: "Executor",
                description: "Uma classe de combate versátil e equilibrada, perfeita para novos jogadores e veteranos que preferem um estilo de jogo adaptável.",
                iconColor: "#2f81f7",
                statModifiers: {},
                startingWeaponId: "antivirus",
                uniquePassive: {
                    id: "passive_executor_first_strike",
                    name: "Primeiro Contato",
                    description: "O primeiro ataque contra um inimigo com vida cheia causa +25% de dano.",
                },
                unlockCost: 0,
            },
            {
                id: "class_sentinel",
                name: "Sentinela",
                description: "Uma fortaleza ambulante. Focado em máxima sobrevivência, controle de área e resistência a dano, ideal para jogadores que gostam de jogar na defensiva.",
                iconColor: "#f85149",
                statModifiers: {
                    baseMaxHealth: 25,
                    baseSpeed: -(PLAYER_INITIAL_STATS.baseSpeed * 0.10),
                },
                startingWeaponId: "firewall",
                uniquePassive: {
                    id: "passive_sentinel_retaliation",
                    name: "Protocolo de Retaliação",
                    description: "Ao receber dano, ganha um bônus de 15% de Redução de Dano por 3 segundos. Não pode ser reativado enquanto estiver ativo.",
                },
                unlockCost: 3,
            },
            {
                id: "class_assassin",
                name: "Assassino",
                description: "Ágil e mortal. Especializa-se em movimentos rápidos e na eliminação sequencial de inimigos, criando um fluxo de combate de alto risco e alta recompensa.",
                iconColor: "#76ff03",
                 statModifiers: {
                    baseSpeed: PLAYER_INITIAL_STATS.baseSpeed * 0.15,
                    baseMaxHealth: -15,
                },
                startingWeaponId: "defrag",
                uniquePassive: {
                    id: "passive_assassin_execution_flow",
                    name: "Fluxo da Execução",
                    description: "Ao derrotar um inimigo, você ganha +20% de velocidade de movimento e +15% de velocidade de ataque por 2 segundos. O efeito reinicia a cada abate.",
                },
                unlockCost: 3,
            },
            {
                id: "class_corruptor",
                name: "Corruptor",
                description: "Um especialista em decompor ameaças para extrair o máximo de dados (experiência) de seus restos, acelerando sua própria evolução.",
                iconColor: "#a3e635",
                 statModifiers: {
                    baseExpModifier: 0.15,
                },
                startingWeaponId: "acid_virus",
                uniquePassive: {
                    id: "passive_corruptor_data_extraction",
                    name: "Extração de Dados",
                    description: "Inimigos que são derrotados enquanto estão dentro de uma Poça de Ácido concedem 10% a mais de Experiência.",
                },
                unlockCost: 5,
            },
            {
                id: "class_reaper",
                name: "Ceifador",
                description: "Um combatente de médio alcance que se sustenta na ofensiva, drenando a energia vital dos processos inimigos para se manter na luta.",
                iconColor: "#be29ec",
                statModifiers: {
                    baseXpMagnetRadius: PLAYER_INITIAL_STATS.baseXpMagnetRadius * 0.75,
                },
                startingWeaponId: "data_leech",
                uniquePassive: {
                    id: "passive_reaper_process_siphon",
                    name: "Sifão de Processos",
                    description: "Inimigos derrotados pelo Data Leech (ou enquanto afetados por ele) têm 15% de chance de dropar um orbe de vida fragmentado que cura 5 HP.",
                },
                unlockCost: 5,
            },
            {
                id: "class_technomancer",
                name: "Tecnomante",
                description: "Um mestre de comando que lidera um enxame de processos convertidos, mantendo sua agilidade para reposicionamento tático.",
                iconColor: "#00e5ff",
                statModifiers: {
                    baseMaxHealth: 10,
                },
                startingWeaponId: "antivirus",
                uniquePassive: {
                    id: "passive_technomancer_swarm", 
                    name: "Enxame de Processos",
                    description: "Converte inimigos em minions de assalto (30% de chance, máx 4). Mantém a habilidade de Dash padrão.",
                },
                unlockCost: 5,
            }
        ];
        // --- END OF game/classes.ts ---
        
        // --- START OF game/skins.ts ---
        
        let skinStateCache = {}; 
        
        function drawGlitchwareFragments(ctx, x, y, size, now) { const fragmentCount = 5; for (let i = 0; i < fragmentCount; i++) { const angle = (now / 600) + (i * (Math.PI * 2 / fragmentCount)); const orbitRadius = size / 1.8 + Math.sin(now / 300 + i * 5) * (size * 0.1); const fragX = x + Math.cos(angle) * orbitRadius + (Math.random() - 0.5) * 3; const fragY = y + Math.sin(angle) * orbitRadius + (Math.random() - 0.5) * 3; const fragSize = size / 4; if (i % 2 === 0) { ctx.fillRect(fragX - fragSize / 2, fragY - fragSize / 2, fragSize, fragSize); } else { ctx.beginPath(); ctx.moveTo(fragX, fragY - fragSize / 2); ctx.lineTo(fragX - fragSize / 2, fragY + fragSize / 2); ctx.lineTo(fragX + fragSize / 2, fragY + fragSize / 2); ctx.closePath(); ctx.fill(); } } }
        function drawHexagon(ctx, x, y, radius) { ctx.beginPath(); for (let i = 0; i < 6; i++) { ctx.lineTo(x + radius * Math.cos((Math.PI / 3) * i), y + radius * Math.sin((Math.PI / 3) * i)); } ctx.closePath(); }
        function drawGear(ctx, x, y, radius, teeth) { const s = radius * 0.2; ctx.beginPath(); for (let i = 0; i < teeth; i++) { const a = (Math.PI * 2 / teeth) * i; const a1 = a - (Math.PI / teeth) * 0.4; const a2 = a + (Math.PI / teeth) * 0.4; ctx.arc(x, y, radius - s, a1, a2, false); ctx.arc(x, y, radius, a2, a1, true); } ctx.closePath(); }
        function drawHextechCircuits(ctx, x, y, radius) { ctx.beginPath(); for (let i = 0; i < 6; i++) { const a = (Math.PI / 3) * i; ctx.moveTo(x + radius * 0.5 * Math.cos(a), y + radius * 0.5 * Math.sin(a)); ctx.lineTo(x + radius * Math.cos(a), y + radius * Math.sin(a)); const n = (Math.PI / 3) * (i + 2); ctx.lineTo(x + radius * Math.cos(n), y + radius * Math.sin(n)); } }

                        const SKIN_DEFINITIONS = [
            {
                id: 'skin_default',
                name: 'Padrão',
                rarity: 'Comum',
                unlockCondition: { type: 'default' },
                unlockHint: 'Disponível por padrão.',
                draw: (ctx, player, options) => { 
                    ctx.save(); 
                    ctx.fillStyle = player.color || '#2f81f7'; 
                    ctx.shadowColor = player.color || '#2f81f7'; 
                    ctx.shadowBlur = 15; 
                    ctx.beginPath(); 
                    ctx.arc(player.position.x, player.position.y, player.size / 2, 0, Math.PI * 2); 
                    ctx.fill(); 
                    ctx.restore(); 
                }
            },
            {
                id: 'skin_symbiotic_cell',
                name: 'Célula Simbiótica',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 2 },
                unlockHint: 'Custo: 2 Núcleos de Sistema.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y);
                    const pulse = Math.sin(time / 500) * 5; const outerRadius = size / 2 - 5 + pulse;
                    ctx.globalAlpha = 0.5;
                    const membraneGrad = ctx.createRadialGradient(0, 0, outerRadius * 0.7, 0, 0, outerRadius);
                    membraneGrad.addColorStop(0, 'rgba(74, 222, 128, 0.1)');
                    membraneGrad.addColorStop(1, 'rgba(16, 185, 129, 0.8)');
                    ctx.fillStyle = membraneGrad; ctx.beginPath(); ctx.arc(0, 0, outerRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                    const corePulse = Math.sin(time / 480) * 3; const coreRadius = size / 5 + corePulse;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGrad.addColorStop(0, '#A7F3D0'); coreGrad.addColorStop(1, '#10B981');
                    ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2); ctx.fill();
                    const particleCount = 10;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (time / 1000) + (i * (Math.PI * 2 / particleCount));
                        const dist = (size / 4) * (Math.sin(time / 700 + i) * 0.5 + 0.5);
                        const px = Math.cos(angle) * dist; const py = Math.sin(angle) * dist;
                        ctx.fillStyle = 'rgba(209, 250, 229, 0.8)'; ctx.fillRect(px - 1, py - 1, 2, 2);
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_energy_core',
                name: 'Núcleo de Energia',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 2 },
                unlockHint: 'Custo: 2 Núcleos de Sistema.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y);
                    const coreRadius = size / 4 + Math.sin(time / 400) * 3;
                    const auraGrad = ctx.createRadialGradient(0, 0, coreRadius, 0, 0, coreRadius * 2);
                    auraGrad.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
                    auraGrad.addColorStop(1, 'rgba(59, 130, 246, 0)');
                    ctx.fillStyle = auraGrad; ctx.beginPath(); ctx.arc(0, 0, coreRadius * 2, 0, Math.PI * 2); ctx.fill();
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGrad.addColorStop(0, '#FFFFFF');
                    coreGrad.addColorStop(0.8, '#93C5FD');
                    coreGrad.addColorStop(1, '#3B82F6');
                    ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                    ctx.shadowColor = '#60A5FA'; ctx.shadowBlur = 15; ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.restore();
                }
            },
            {
                id: 'skin_logic_gate',
                name: 'Porta Lógica',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 3 },
                unlockHint: 'Custo: 3 Núcleos de Sistema.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.translate(x, y); ctx.strokeStyle = '#999'; ctx.lineWidth = 4; ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.arc(0, 0, size / 3, -Math.PI / 2, Math.PI / 2);
                    ctx.lineTo(-size / 3, size / 3); ctx.lineTo(-size / 3, -size / 3); ctx.closePath(); ctx.fill(); ctx.stroke();
                    const input1 = Math.floor(now / 1000) % 2; const input2 = Math.floor(now / 700) % 2; const output = input1 && input2;
                    ctx.fillStyle = input1 ? 'lime' : 'red'; ctx.beginPath(); ctx.arc(-size / 3, -size / 6, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = input2 ? 'lime' : 'red'; ctx.beginPath(); ctx.arc(-size / 3, size / 6, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = output ? 'lime' : 'red'; ctx.beginPath(); ctx.arc(size / 2.5, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                }
            },
            {
                id: 'skin_bsod',
                name: 'Tela Azul (BSOD)',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 2 },
                unlockHint: 'Custo: 2 Núcleos de Sistema.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.fillStyle = '#0000AA'; ctx.fillRect(x - size / 2, y - size / 2, size, size);
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 2;
                    for (let i = 0; i < size; i += 4) { if (Math.random() > 0.9) { ctx.beginPath(); ctx.moveTo(x - size / 2, y - size / 2 + i); ctx.lineTo(x + size / 2, y - size / 2 + i); ctx.stroke(); }}
                    ctx.fillStyle = 'white'; ctx.font = `bold ${size * 0.15}px "Courier New", monospace`; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                    if (Math.floor(now / 500) % 2) { ctx.fillText("KERNEL_PANIC", x - size * 0.45, y); } else { ctx.fillText("0xDEADBEEF", x - size * 0.45, y); }
                    ctx.restore();
                }
            },
            // --- RARA ---
            {
                id: 'skin_qr_code',
                name: 'Código de Acesso (QR)',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'score', value: 10000 },
                unlockHint: 'Acumule 10.000 pontos em uma única partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    if (!skinStateCache.qrcode || Math.floor(now / 200) !== skinStateCache.qrcode.lastUpdate) {
                        skinStateCache.qrcode = { grid: [], lastUpdate: Math.floor(now / 200) };
                        for (let i = 0; i < 10; i++) { skinStateCache.qrcode.grid[i] = []; for (let j = 0; j < 10; j++) { skinStateCache.qrcode.grid[i][j] = Math.random() > 0.5; }}
                    }
                    ctx.translate(x, y); const pSize = size / 10;
                    for (let i = 0; i < 10; i++) { for (let j = 0; j < 10; j++) { ctx.fillStyle = skinStateCache.qrcode.grid[i][j] ? 'black' : 'white'; ctx.fillRect(-size / 2 + i * pSize, -size / 2 + j * pSize, pSize, pSize); }}
                    ctx.restore();
                }
            },
            {
                id: 'skin_quantum_cpu',
                name: 'CPU Quântica',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'level', value: 25 },
                unlockHint: 'Alcance o Nível 25 em uma única partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.translate(x, y); ctx.rotate(now / 5000); ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-size / 2, -size / 2, size, size);
                    const grad = ctx.createLinearGradient(-size / 2, -size / 2, size / 2, size / 2);
                    grad.addColorStop(0, '#333'); grad.addColorStop(0.5, '#555'); grad.addColorStop(1, '#333');
                    ctx.fillStyle = grad; ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
                    ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2; ctx.shadowColor = '#00ffcc'; ctx.shadowBlur = 15;
                    const pulse = Math.sin(now / 200) * 5;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath(); const angle = i * Math.PI / 2; ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * (size / 2 + pulse), Math.sin(angle) * (size / 2 + pulse)); ctx.stroke();
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_graphic_equalizer',
                name: 'Equalizador Gráfico',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'evolvedWeaponsIncludes', value: 'evolution_firewall_aegis_shield' },
                unlockHint: 'Evolua o Firewall para "Aegis Shield" em uma partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; const bars = 8; const barWidth = size / bars;
                    ctx.save(); ctx.translate(x - size/2, y - size/2);
                    for(let i=0; i<bars; i++) {
                        const height = (Math.sin(i * 0.8 + time/200) + 1)/2 * size; const hue = 120 - (height/size) * 120;
                        ctx.fillStyle = `hsl(${hue}, 100%, 15%)`; ctx.fillRect(i*barWidth, 0, barWidth-2, size);
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.fillRect(i*barWidth, size, barWidth-2, -height);
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_singularity_core',
                name: 'Núcleo Singular',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'timeSurvived', value: 900 },
                unlockHint: 'Sobreviva por 15 minutos em uma única partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y);
                    ctx.globalCompositeOperation = 'lighter';
                    const drawWave = (radius, color, speed, frequency, amplitude) => {
                        ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.6; ctx.rotate(time * speed); ctx.beginPath();
                        for (let i = 0; i <= 360; i++) { const angle = i * Math.PI / 180; const r = radius + Math.sin(angle * frequency + time * 0.001) * amplitude; const px = Math.cos(angle) * r; const py = Math.sin(angle) * r; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); }
                        ctx.closePath(); ctx.stroke(); ctx.restore();
                    };
                    drawWave(size * 0.30, '#0ea5e9', 0.0001, 5, size * 0.05); drawWave(size * 0.35, '#06b6d4', -0.00015, 7, size * 0.04); drawWave(size * 0.40, '#22d3ee', 0.00008, 6, size * 0.06);
                    ctx.globalCompositeOperation = 'source-over';
                    const coreRadius = size * 0.2; ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(207, 250, 254, 0.8)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }
            },
            {
                id: 'skin_origami',
                name: 'Origami',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'damageTakenInFirst5Minutes', value: 0 },
                unlockHint: 'Complete os primeiros 5 minutos sem sofrer dano.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const n = options.time; const x = player.position.x; const y = player.position.y; const s = player.size;
                    ctx.lineJoin = 'round'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 1.5;
                    const p = 0.5 + Math.sin(n / 1000) * 0.5; const pts = [{ x: 0, y: -s / 2 }, { x: s / 2, y: 0 }, { x: 0, y: s / 2 }, { x: -s / 2, y: 0 }];
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath(); const p1 = pts[i]; const p2 = pts[(i + 1) % 4];
                        const mX = (p1.x + p2.x) * 0.5 * p; const mY = (p1.y + p2.y) * 0.5 * p;
                        ctx.moveTo(x, y); ctx.lineTo(x + p1.x, y + p1.y); ctx.lineTo(x + mX, y + mY); ctx.lineTo(x + p2.x, y + p2.y); ctx.closePath();
                        const l = 0.7 + Math.sin(i * Math.PI / 2 + n / 500) * 0.2;
                        ctx.fillStyle = `rgba(240, 240, 255, ${l})`; ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; ctx.shadowBlur = 10;
                        ctx.fill(); ctx.shadowColor = 'transparent'; ctx.stroke();
                    }
                    ctx.restore();
                }
            },
            // --- ÉPICA ---
            {
                id: 'skin_unstable_blackhole',
                name: 'Buraco Negro Instável',
                rarity: 'Épica',
                unlockCondition: { type: 'session_stat', stat: 'level', value: 40 },
                unlockHint: 'Alcance o Nível 40 em uma única partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; ctx.save(); ctx.translate(x, y);
                    const coreRadius = size * 0.2;
                    for (let i = 0; i < 5; i++) {
                        ctx.strokeStyle = `rgba(139, 92, 246, ${Math.random() * 0.3})`; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath(); const startAngle = Math.random() * Math.PI * 2; const endAngle = startAngle + Math.PI * Math.random() * 0.5; const r = coreRadius + Math.random() * 15 + 10;
                        ctx.arc(0, 0, r, startAngle, endAngle); ctx.stroke();
                    }
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.save(); ctx.rotate(time / 8000);
                    const grad = ctx.createConicGradient(0, 0, 0);
                    grad.addColorStop(0, '#f97316'); grad.addColorStop(0.25, '#ec4899'); grad.addColorStop(0.5, '#8b5cf6'); grad.addColorStop(0.75, '#facc15'); grad.addColorStop(1, '#f97316');
                    ctx.strokeStyle = grad; ctx.lineWidth = size * 0.15 + Math.sin(time / 400) * 8; ctx.globalAlpha = 0.8 + Math.sin(time/500) * 0.2; ctx.beginPath(); ctx.arc(0, 0, size * 0.4, 0, 2 * Math.PI); ctx.stroke(); ctx.restore();
                    if (Math.random() > 0.985) {
                        ctx.save(); const angle = Math.random() * Math.PI * 2; ctx.rotate(angle); const plasmaGrad = ctx.createLinearGradient(0, -coreRadius, 0, -size);
                        plasmaGrad.addColorStop(0, 'rgba(236, 72, 153, 0.8)'); plasmaGrad.addColorStop(1, 'rgba(236, 72, 153, 0)');
                        ctx.fillStyle = plasmaGrad; ctx.beginPath(); ctx.moveTo(0, -coreRadius); ctx.lineTo(-10, -size/2); ctx.lineTo(10, -size/2); ctx.closePath(); ctx.fill(); ctx.restore();
                    }
                    if (!player.particles) { player.particles = Array(100).fill({}).map(() => ({ angle: Math.random() * Math.PI * 2, radius: size/2 * (Math.random() * 0.6 + 0.4), speed: Math.random() * 2 + 1, size: Math.random() * 2 + 1, color: `hsl(${Math.random()*60 + 240}, 100%, 70%)` })); }
                    ctx.globalCompositeOperation = 'lighter';
                    player.particles.forEach(p => {
                        p.radius -= p.speed * 0.05; const px = Math.cos(p.angle) * p.radius; const py = Math.sin(p.angle) * p.radius; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(px, py, p.size, 0, 2 * Math.PI); ctx.fill(); p.angle += p.speed * 0.01;
                        if (p.radius < coreRadius) { p.radius = size/2 * (Math.random() * 0.2 + 0.9); p.angle = Math.random() * Math.PI * 2; }
                    });
                    ctx.restore();
                }
            },
            {
                id: 'skin_temporal_gear',
                name: 'Engrenagem Temporal',
                rarity: 'Épica',
                unlockCondition: { type: 'global_stat', stat: 'totalKills', value: 25000 },
                unlockHint: 'Derrote 25.000 inimigos no total.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; ctx.save(); ctx.translate(x, y);
                    ctx.fillStyle = '#1E293B'; ctx.beginPath(); ctx.arc(0, 0, size/2, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FBBF24'; ctx.lineWidth = 3; ctx.stroke();
                    const numerals = ['XII', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI'];
                    ctx.font = `${size * 0.08}px 'Press Start 2P'`; ctx.fillStyle = '#FBBF24'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    for(let i = 0; i < 12; i++){ const angle = i * Math.PI / 6; ctx.save(); ctx.rotate(angle); ctx.translate(0, -size * 0.4); ctx.rotate(-angle); ctx.fillText(numerals[i], 0, 0); ctx.restore(); }
                    const drawGear = (radius, teeth, speed, color1, color2) => {
                        const step = Math.PI * 2 / teeth; ctx.save(); ctx.rotate(time * speed);
                        ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 8; ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4;
                        const grad = ctx.createRadialGradient(0, 0, radius*0.5, 0, 0, radius);
                        grad.addColorStop(0, color1); grad.addColorStop(1, color2);
                        ctx.fillStyle = grad; ctx.beginPath();
                        for(let i=0; i<teeth * 2; i++) { const angle = i * step/2; const r = radius * (i % 2 === 0 ? 1 : 0.8); ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r); }
                        ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, radius * 0.2, 0, Math.PI * 2);
                        const holeGrad = ctx.createRadialGradient(0, 0, radius*0.1, 0, 0, radius*0.2);
                        holeGrad.addColorStop(0,'#111'); holeGrad.addColorStop(1,'#444');
                        ctx.fillStyle = holeGrad; ctx.fill(); ctx.restore();
                    };
                    drawGear(size * 0.35, 12, 0.0003, '#D1D5DB', '#6B7280'); drawGear(size * 0.2, 8, -0.0009, '#FCA5A5', '#991B1B');
                    const drawHand = (angle, length, width, color) => { ctx.save(); ctx.rotate(angle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -length); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke(); ctx.restore(); }
                    drawHand( (time / 1000) * Math.PI / 30, size * 0.4, 2, '#FBBF24'); drawHand( (time / 60000) * Math.PI / 30, size * 0.3, 4, '#FBBF24');
                    if(Math.random() > 0.9) { ctx.fillStyle = '#FDE047'; ctx.fillRect(Math.random()*size - size/2, Math.random()*size - size/2, 2, 2); }
                    ctx.restore();
                }
            },
            {
                id: 'skin_pym_particle',
                name: 'Partícula Pym',
                rarity: 'Épica',
                unlockCondition: { type: 'session_stat', stat: 'killsWhileBuffed', value: 500 },
                unlockHint: 'Derrote 500 inimigos sob o efeito de um "Data Cache".',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const n = options.time; const x = player.position.x; const y = player.position.y;
                    const cD = 2000; const c = (n % cD) / cD;
                    const eC = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                    const e = eC(c); const mS = player.size * 0.8; const M_S = player.size * 1.2; const cS = mS + (M_S - mS) * e;
                    const r = [{ color: 'rgba(255, 0, 0, 0.7)', offset: 0.0, width: 0.1 }, { color: 'rgba(192, 192, 192, 0.8)', offset: 0.2, width: 0.2 }, { color: 'rgba(20, 20, 20, 1)', offset: 0.5, width: 0.3 }, { color: 'rgba(255, 0, 0, 0.9)', offset: 0.9, width: 0.1 }];
                    r.forEach(ring => {
                        const radius = cS / 2 * (1 - ring.offset); const lW = cS / 2 * ring.width;
                        ctx.beginPath(); ctx.strokeStyle = ring.color; ctx.lineWidth = lW;
                        ctx.shadowColor = ring.color === 'rgba(20, 20, 20, 1)' ? 'transparent' : ring.color; ctx.shadowBlur = 15;
                        ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.stroke();
                    });
                    ctx.shadowColor = 'transparent'; const pC = 20;
                    for (let i = 0; i < pC; i++) {
                        const pL = (n / 10 + i * 50) % 100 / 100; const a = (n / 1500) + (i * (Math.PI * 2 / pC));
                        const oR = cS * (0.5 + e * 0.3); const px = x + Math.cos(a) * oR; const py = y + Math.sin(a) * oR;
                        ctx.beginPath(); ctx.fillStyle = e < 0.5 ? 'rgba(0, 191, 255, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                        ctx.globalAlpha = 1 - pL; ctx.arc(px, py, (1 - pL) * 3, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_stark_protocol',
                name: 'Reator Arc',
                rarity: 'Épica',
                unlockCondition: { type: 'session_stat', stat: 'dataCachesCollected', value: 15 },
                unlockHint: 'Colete 15 "Data Caches" em uma única partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const { x, y } = player.position; const radius = player.size / 2; const time = options.time;
                    const redGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    redGrad.addColorStop(0, '#E00000'); redGrad.addColorStop(0.7, '#A00000'); redGrad.addColorStop(1, '#600000');
                    ctx.fillStyle = redGrad; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 30; ctx.shadowOffsetY = 15;
                    ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                    const innerGlowGrad = ctx.createRadialGradient(x, y, radius * 0.7, x, y, radius);
                    innerGlowGrad.addColorStop(0, 'rgba(255, 255, 255, 0)'); innerGlowGrad.addColorStop(1, 'rgba(255, 255, 255, 0.4)');
                    ctx.fillStyle = innerGlowGrad; ctx.fill(); ctx.strokeStyle = '#400000'; ctx.lineWidth = 6; ctx.stroke();
                    const shapeWidth = player.size * 0.65; const shapeHeight = player.size * 0.65;
                    ctx.beginPath(); ctx.moveTo(x - shapeWidth * 0.3, y - shapeHeight * 0.5);
                    ctx.lineTo(x + shapeWidth * 0.3, y - shapeHeight * 0.5); ctx.lineTo(x + shapeWidth * 0.5, y - shapeHeight * 0.2);
                    ctx.lineTo(x + shapeWidth * 0.5, y + shapeHeight * 0.2); ctx.lineTo(x + shapeWidth * 0.3, y + shapeHeight * 0.5);
                    ctx.lineTo(x - shapeWidth * 0.3, y + shapeHeight * 0.5); ctx.lineTo(x - shapeWidth * 0.5, y + shapeHeight * 0.2);
                    ctx.lineTo(x - shapeWidth * 0.5, y - shapeHeight * 0.2); ctx.closePath();
                    const goldGrad = ctx.createLinearGradient(x - shapeWidth / 2, y - shapeHeight / 2, x + shapeWidth / 2, y + shapeHeight / 2);
                    goldGrad.addColorStop(0, '#FFD700'); goldGrad.addColorStop(0.4, '#DAA520'); goldGrad.addColorStop(0.8, '#B8860B'); goldGrad.addColorStop(1, '#A0522D');
                    ctx.fillStyle = goldGrad; ctx.fill(); ctx.strokeStyle = '#CC9900'; ctx.lineWidth = 2; ctx.stroke();
                    const centerCircleRadius = player.size * 0.45 / 2;
                    const glowProgress = (Math.sin(time / 900) + 1) / 2;
                    const glowBlur1 = 30 + (glowProgress * 10); const glowBlur2 = 60 + (glowProgress * 20);
                    ctx.globalAlpha = 0.8; ctx.fillStyle = 'rgba(173, 216, 230, 0.8)'; ctx.filter = `blur(${glowBlur2}px)`;
                    ctx.beginPath(); ctx.arc(x, y, centerCircleRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.globalAlpha = 1.0; ctx.filter = `blur(${glowBlur1}px)`;
                    ctx.beginPath(); ctx.arc(x, y, centerCircleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.filter = 'none';
                    const blueGrad = ctx.createRadialGradient(x, y, 0, x, y, centerCircleRadius);
                    blueGrad.addColorStop(0, '#ADD8E6'); blueGrad.addColorStop(0.3, '#87CEEB'); blueGrad.addColorStop(0.7, '#4682B4'); blueGrad.addColorStop(1, '#2F4F4F');
                    ctx.fillStyle = blueGrad; ctx.beginPath(); ctx.arc(x, y, centerCircleRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.strokeStyle = 'rgba(173, 216, 230, 0.5)'; ctx.lineWidth = 2; ctx.stroke();
                    const innerBlueRadius = centerCircleRadius * 0.6; ctx.fillStyle = '#00BFFF';
                    ctx.beginPath(); ctx.arc(x, y, innerBlueRadius, 0, 2 * Math.PI); ctx.fill();
                    const whiteCoreRadius = innerBlueRadius * 0.58;
                    const whiteGrad = ctx.createRadialGradient(x, y, 0, x, y, whiteCoreRadius);
                    whiteGrad.addColorStop(0, '#FFFFFF'); whiteGrad.addColorStop(0.6, '#E0E0E0'); whiteGrad.addColorStop(1, '#C0C0C0');
                    ctx.fillStyle = whiteGrad; ctx.beginPath(); ctx.arc(x, y, whiteCoreRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.restore();
                }
            },
            {
                id: 'skin_liberty_sentinel',
                name: 'Sentinela da Liberdade',
                rarity: 'Épica',
                unlockCondition: { type: 'global_stat', stat: 'allBossesDefeated', value: ['guardian', 'sincronizador', 'arbiter', 'hivemind_nexus'] }, // --- ALTERADO ---
                unlockHint: 'Derrote todos os chefes do jogo (Guardião, Sincronizador, Árbitro e Nexus).', // --- ALTERADO ---
                draw: (ctx, player, options) => {
                    ctx.save(); const { x, y } = player.position; const radius = player.size / 2;
                    ctx.shadowColor = '#B91C1C'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 2;
                    ctx.fillStyle = '#B91C1C'; ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.fill();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                    ctx.fillStyle = '#E5E7EB'; ctx.beginPath(); ctx.arc(x, y, radius * 0.8, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#B91C1C'; ctx.beginPath(); ctx.arc(x, y, radius * 0.6, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#2563EB'; ctx.beginPath(); ctx.arc(x, y, radius * 0.4, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#E5E7EB'; ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                        const outerX = x + radius * 0.35 * Math.cos(angle); const outerY = y + radius * 0.35 * Math.sin(angle);
                        ctx.lineTo(outerX, outerY);
                        const innerAngle = angle + Math.PI / 5;
                        const innerX = x + radius * 0.15 * Math.cos(innerAngle); const innerY = y + radius * 0.15 * Math.sin(innerAngle);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath(); ctx.fill(); ctx.restore();
                }
            },
            {
                id: 'skin_gpu',
                name: 'Shader Unit (GPU)',
                rarity: 'Épica',
                unlockCondition: { type: 'session_stat', stat: 'reachedInfiniteMode', value: true },
                unlockHint: 'Chegue ao Modo Infinito.',
                 draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.translate(x, y);
                    const grad = ctx.createLinearGradient(-size / 2, -size / 2, size / 2, size / 2);
                    const hue = (now / 20) % 360;
                    grad.addColorStop(0, `hsl(${hue}, 100%, 50%)`); grad.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 100%, 50%)`); grad.addColorStop(1, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
                    ctx.fillStyle = grad; ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.shadowColor = 'white'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.moveTo(0, -size / 2); ctx.lineTo(size / 2, size / 2); ctx.lineTo(-size / 2, size / 2); ctx.closePath();
                    ctx.fill(); ctx.stroke(); ctx.restore();
                }
            },
            // --- LENDÁRIA ---
            {
                id: 'skin_dragon_ball_4',
                name: 'Esfera de 4 Estrelas',
                rarity: 'Lendária',
                unlockCondition: { type: 'session_stat', stat: 'healthPickupsCollected', value: 7 },
                unlockHint: 'Colete 7 orbes de vida em uma única partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const r = player.size / 2;
                    ctx.save();
                    ctx.shadowColor = '#F6AD55'; ctx.shadowBlur = 20;
                    const grad = ctx.createRadialGradient(x - r*0.2, y - r*0.3, r*0.1, x, y, r);
                    grad.addColorStop(0, '#FEEBC8'); grad.addColorStop(0.5, '#F6AD55'); grad.addColorStop(1, '#DD6B20');
                    ctx.fillStyle = grad; 
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#742A2A'; ctx.lineWidth = 1;
                    const starPositions = [ {x: -0.3, y: -0.3}, {x: 0.3, y: -0.3}, {x: -0.3, y: 0.3}, {x: 0.3, y: 0.3} ];
                    starPositions.forEach(pos => {
                        const starX = x + r * pos.x; const starY = y + r * pos.y; const starR = r * 0.15;
                        ctx.shadowColor = '#E53E3E'; ctx.shadowBlur = 10;
                        ctx.fillStyle = '#C53030';
                        ctx.beginPath();
                        for(let i=0; i<10; i++) {
                            const angle = (i/10)*Math.PI*2;
                            const radius = i%2===0 ? starR : starR*0.4;
                            ctx.lineTo(starX + Math.cos(angle)*radius, starY + Math.sin(angle)*radius);
                        }
                        ctx.closePath(); ctx.fill();
                        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.stroke();
                    });
                    ctx.restore();
                }
            },
            {
                id: 'skin_hextech',
                name: 'Hextech',
                rarity: 'Lendária',
                unlockCondition: { type: 'session_stat', stat: 'evolvedWeapons', value: 3 },
                unlockHint: 'Evolua 3 armas diferentes em uma única partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size * 1.2;
                    if (!skinStateCache.hextech) {
                        skinStateCache.hextech = {}; const p = document.createElement('canvas'); const pc = p.getContext('2d');
                        p.width = 50; p.height = 50;
                        const g = pc.createLinearGradient(0, 0, 50, 50);
                        g.addColorStop(0, '#8c7853'); g.addColorStop(0.5, '#D4AF37'); g.addColorStop(1, '#8c7853');
                        pc.fillStyle = g; pc.fillRect(0, 0, 50, 50); pc.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        for (let i = 0; i < 30; i++) { pc.beginPath(); pc.moveTo(Math.random() * 50, Math.random() * 50); pc.lineTo(Math.random() * 50, Math.random() * 50); pc.stroke(); }
                        skinStateCache.hextech.metalTexture = ctx.createPattern(p, 'repeat');
                    }
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 8;
                    ctx.fillStyle = '#4a3f2a'; drawHexagon(ctx, x, y, size / 2); ctx.fill(); ctx.shadowColor = 'transparent';
                    ctx.save(); drawHexagon(ctx, x, y, size / 2 * 0.9); ctx.clip(); ctx.fillStyle = skinStateCache.hextech.metalTexture; ctx.fillRect(x - size / 2, y - size / 2, size, size); ctx.restore();
                    ctx.save(); ctx.translate(x, y); ctx.rotate((now / 2000)); ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; drawGear(ctx, 0, 0, size * 0.35, 8); ctx.fill(); ctx.restore();
                    ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 2; ctx.shadowColor = '#00FFFF'; ctx.shadowBlur = 20; ctx.globalAlpha = 0.5 + Math.sin(now / 200) * 0.5;
                    drawHextechCircuits(ctx, x, y, size / 2 * 0.7); ctx.stroke();
                    const coreGrad = ctx.createRadialGradient(x, y, 1, x, y, size * 0.2);
                    coreGrad.addColorStop(0, 'white'); coreGrad.addColorStop(0.3, '#00FFFF'); coreGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(x, y, size * 0.25, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                }
            },
            {
                id: 'skin_celestial_map',
                name: 'Mapa Celestial',
                rarity: 'Lendária',
                unlockCondition: { type: 'global_stat', stat: 'bossKills', bossType: 'sincronizador', value: 5 },
                unlockHint: 'Derrote o Sincronizador (Chefe da Fase 2) 5 vezes no total.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y); ctx.strokeStyle = 'rgba(251, 191, 36, 0.6)'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(0, 0, size*0.2, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, size*0.35, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, size*0.5, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = '#FBBF24'; ctx.beginPath(); ctx.arc(0, 0, size * 0.1, 0, Math.PI*2); ctx.fill();
                    const planets = [ { r: size*0.2, s: 0.002, c: '#9AE6B4', size: 4 }, { r: size*0.35, s: -0.001, c: '#63B3ED', size: 6 }, { r: size*0.5, s: 0.0005, c: '#F56565', size: 5 } ];
                    planets.forEach(p => { const angle = time * p.s; const px = Math.cos(angle) * p.r; const py = Math.sin(angle) * p.r; ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(px, py, p.size, 0, Math.PI * 2); ctx.fill(); });
                    ctx.restore();
                }
            },
                        {
                id: 'skin_cosmic_sundial',
                name: 'Solstício Cósmico',
                rarity: 'Lendária',
                unlockCondition: { type: 'global_stat', stat: 'totalTimePlayed', value: 18000 },
                unlockHint: 'Acumule 5 horas de tempo de jogo total.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position;
                    const size = player.size * 1.4;
                    const time = options.time;

                    if (!player.sundialState) {
                        player.sundialState = {
                            nebulaRotation: 0,
                            ring1Rotation: 0,
                            ring2Rotation: 0,
                        };
                    }
                    const state = player.sundialState;

                    ctx.save();
                    ctx.translate(x, y);

                    const nebulaGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size / 2);
                    const hue = (time / 100) % 360;
                    nebulaGrad.addColorStop(0, `hsl(${hue}, 70%, 50%)`);
                    nebulaGrad.addColorStop(0.7, `hsl(${(hue + 120) % 360}, 60%, 20%)`);
                    nebulaGrad.addColorStop(1, '#020617');
                    
                    ctx.fillStyle = nebulaGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = `hsla(${(hue + 60) % 360}, 100%, 80%, 0.6)`;
                    ctx.lineWidth = 1.5;
                    ctx.shadowColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                    ctx.shadowBlur = 10;
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        const angle = i * (Math.PI*2/3) + time / 8000;
                        ctx.lineTo(Math.cos(angle) * size/2.2, Math.sin(angle) * size/2.2);
                        ctx.stroke();
                    }
                    ctx.shadowColor = 'transparent';

                    const drawRing = (radius, rotation, glyphs) => {
                        ctx.save();
                        ctx.rotate(rotation);
                        ctx.strokeStyle = '#FDE047';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        const glowIndex = Math.floor((time / 200) % glyphs);
                        for(let i=0; i<glyphs; i++) {
                            const angle = i * (Math.PI * 2 / glyphs);
                            const isGlowing = i === glowIndex;
                            ctx.fillStyle = isGlowing ? '#FFFBEB' : '#FDE047';
                            if(isGlowing) {
                                ctx.shadowColor = '#FFFBEB';
                                ctx.shadowBlur = 15;
                            }
                            ctx.fillRect(Math.cos(angle) * radius - 2, Math.sin(angle) * radius - 2, 4, 4);
                            ctx.shadowColor = 'transparent';
                        }
                        ctx.restore();
                    };
                    state.ring1Rotation += 0.0005;
                    state.ring2Rotation -= 0.0008;
                    drawRing(size * 0.4, state.ring1Rotation, 12);
                    drawRing(size * 0.3, state.ring2Rotation, 8);
                    
                    const coreRadius = size * 0.2;
                    const sunPulse = 0.95 + Math.sin(time / 200) * 0.05;
                    const sunGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius * sunPulse);
                    sunGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    sunGrad.addColorStop(0.8, 'rgba(254, 249, 195, 1)');
                    sunGrad.addColorStop(1, 'rgba(251, 146, 60, 0.8)');
                    
                    ctx.fillStyle = sunGrad;
                    ctx.shadowColor = '#FBBF24';
                    ctx.shadowBlur = 30;
                    ctx.beginPath();
                    ctx.arc(0, 0, coreRadius * sunPulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';

                    ctx.restore();
                }
            },
            // --- MÍTICA ---
            {
                id: 'skin_antimatter_reactor',
                name: 'Reator de Antimatéria',
                rarity: 'Mítica',
                unlockCondition: { type: 'combined', conditions: [{ type: 'session_event', event: 'defeat_boss', params: { bossType: 'hivemind_nexus' } }, { type: 'session_stat', stat: 'dashUsed', value: false } ]}, // --- ALTERADO ---
                unlockHint: 'Derrote o Nexus da Colmeia sem usar a habilidade de Dash.', // --- ALTERADO ---
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; ctx.save();
                    const rings = [ { r: size * 0.5, w: 4, s: 0.001, c: '#9CA3AF' }, { r: size * 0.4, w: 2, s: -0.002, c: '#FBBF24' }, { r: size * 0.3, w: 3, s: 0.003, c: '#9CA3AF' } ];
                    rings.forEach(ring => { ctx.strokeStyle = ring.c; ctx.lineWidth = ring.w; ctx.beginPath(); ctx.arc(x, y, ring.r, time * ring.s, time * ring.s + Math.PI * 1.5); ctx.stroke(); });
                    ctx.fillStyle = '#A78BFA';
                    for(let i=0; i<30; i++) {
                        const angle = (i/30)*Math.PI*2 + time/1000; const dist = size/2 * (1 - ((time/500 + i*10)%1));
                        ctx.globalAlpha = 1 - (dist / (size/2)); ctx.fillRect(x + Math.cos(angle)*dist - 1, y + Math.sin(angle)*dist - 1, 2, 2);
                    }
                    const coreRadius = size * 0.25; ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(x, y, coreRadius, 0, Math.PI*2); ctx.fill();
                    ctx.save(); ctx.globalCompositeOperation = 'lighter';
                    for(let i=0; i<3; i++){ if(Math.random() > 0.8) {
                        ctx.strokeStyle = `rgba(167, 139, 250, ${Math.random()*0.8})`; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath(); ctx.moveTo(x,y); const r_angle = Math.random() * Math.PI * 2; ctx.lineTo(x + Math.cos(r_angle)*coreRadius, y + Math.sin(r_angle)*coreRadius); ctx.stroke();
                    }}
                    ctx.restore(); ctx.restore();
                }
            },
            {
                id: 'skin_glitchware',
                name: 'Glitchware',
                rarity: 'Mítica',
                unlockCondition: { type: 'combined', conditions: [
                    { type: 'session_stat', stat: 'reachedInfiniteMode', value: true },
                    { type: 'session_stat', stat: 'dashUsed', value: false },
                    { type: 'session_stat', stat: 'evolvedWeapons', value: 0 }
                ]},
                unlockHint: 'Chegue ao Modo Infinito sem usar Dash e sem evoluir armas.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y;
                    ctx.save(); ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.7)'; drawGlitchwareFragments(ctx, x + 2, y, player.size, now);
                    ctx.fillStyle = 'rgba(255, 0, 150, 0.7)'; drawGlitchwareFragments(ctx, x - 2, y, player.size, now);
                    ctx.restore();
                    ctx.fillStyle = '#FF00FF'; ctx.shadowColor = '#FF00FF'; ctx.shadowBlur = 20;
                    ctx.beginPath(); const coreSize = (player.size / 4) * (1 + Math.sin(now / 150) * 0.1);
                    ctx.arc(x, y, coreSize, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                }
            },
            {
                id: 'skin_nanite_swarm',
                name: 'Enxame Nanotecnológico',
                rarity: 'Mítica',
                unlockCondition: { type: 'session_event', event: 'winWithClass', classId: 'class_technomancer' },
                unlockHint: 'Vença o jogo (derrote o Nexus) com a classe Tecnomante.', // --- ALTERADO ---
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x,y); const naniteCount = 40;
                    for(let i=0; i < naniteCount; i++) {
                        const angle = (time / 2000) + (i / naniteCount) * Math.PI * 2;
                        const orbitRadius = size/3 + Math.sin(time/500 + i*5) * size * 0.15;
                        const naniteX = Math.cos(angle) * orbitRadius; const naniteY = Math.sin(angle) * orbitRadius;
                        const naniteSize = size * 0.05 * (0.8 + Math.sin(time/100 + i)*0.2);
                        const hue = (180 + Math.sin(time/1000 + i) * 30) % 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.shadowColor = `hsl(${hue}, 100%, 50%)`; ctx.shadowBlur = 5;
                        ctx.beginPath(); ctx.moveTo(naniteX, naniteY - naniteSize); ctx.lineTo(naniteX - naniteSize, naniteY + naniteSize); ctx.lineTo(naniteX + naniteSize, naniteY + naniteSize);
                        ctx.closePath(); ctx.fill();
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_bionic_sanfoneiro',
                name: 'Sanfoneiro Biônico',
                rarity: 'Mítica',
                unlockCondition: { type: 'global_stat', stat: 'totalHealthPickupsCollected', value: 150 },
                unlockHint: 'Colete 150 orbes de vida no total (Disponível até 30 de junho de 2025).',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position;
                    const size = player.size;
                    const time = options.time;

                    ctx.save();
                    ctx.translate(x, y);

                    const bodyBob = Math.sin(time / 400) * 4;
                    const bodySway = Math.sin(time / 800) * 0.05;
                    ctx.translate(0, bodyBob);
                    ctx.rotate(bodySway);

                    const accordionPull = (Math.sin(time / 500) + 1) / 2;

                    const hoverGlow = 0.5 + (Math.sin(time / 350) + 1) * 0.15;
                    const hoverGradient = ctx.createRadialGradient(0, size * 0.4, 5, 0, size * 0.4, size * 0.3);
                    hoverGradient.addColorStop(0, `rgba(220, 20, 60, ${hoverGlow})`);
                    hoverGradient.addColorStop(1, 'rgba(220, 20, 60, 0)');
                    ctx.fillStyle = hoverGradient;
                    ctx.fillRect(-size*0.4, size*0.2, size*0.8, size*0.4);
                    
                    ctx.fillStyle = '#424242';
                    ctx.beginPath();
                    ctx.ellipse(0, size * 0.3, size * 0.25, size * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();

                    const torsoGradient = ctx.createLinearGradient(0, -size*0.5, 0, size*0.5);
                    torsoGradient.addColorStop(0, '#BDBDBD');
                    torsoGradient.addColorStop(0.5, '#8D8D8D');
                    torsoGradient.addColorStop(1, '#616161');
                    ctx.fillStyle = torsoGradient;
                    ctx.strokeStyle = '#424242';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(-size*0.22, -size*0.1, size*0.44, size*0.4, 15);
                    ctx.fill();
                    ctx.stroke();
                    
                    const corePulse = 0.8 + (Math.sin(time/200) + 1) * 0.1;
                    ctx.fillStyle = `rgba(255, 80, 80, ${corePulse})`;
                    ctx.shadowColor = 'red';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.roundRect(-size*0.06, size*0.02, size*0.12, size*0.1, 5);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';

                    ctx.save();
                    ctx.rotate(Math.sin(time / 850) * 0.06);
                    
                    ctx.fillStyle = '#616161';
                    ctx.fillRect(-size*0.06, -size*0.2, size*0.12, size*0.12);
                    ctx.fillStyle = torsoGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size*0.2, -size*0.4, size*0.4, size*0.25, 10);
                    ctx.fill();
                    ctx.stroke();
                    const visorGlow = 0.7 + (Math.sin(time / 250) + 1) * 0.15;
                    ctx.fillStyle = `rgba(255, 0, 0, ${visorGlow})`;
                    ctx.shadowColor = 'red'; ctx.shadowBlur = 20;
                    ctx.fillRect(-size*0.16, -size*0.35, size*0.32, size*0.08);
                    ctx.shadowColor = 'transparent';

                    ctx.save();
                    ctx.translate(0, -size * 0.4);
                    ctx.fillStyle = '#E2C275'; ctx.strokeStyle = '#B59458'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.ellipse(0, 0, size * 0.35, size * 0.12, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#D2B468';
                    ctx.beginPath(); ctx.ellipse(0, -size * 0.08, size * 0.2, size * 0.1, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#BF3B3B'; ctx.fillRect(-size*0.1, -size*0.12, size*0.05, size*0.03);
                    ctx.restore();

                    ctx.restore();

                    const accordionCenterY = size * 0.2;
                    const bellowsWidth = size * 0.16 + accordionPull * (size * 0.67);
                    const leftEnd = -bellowsWidth / 2 - (size * 0.21);
                    const rightEnd = bellowsWidth / 2 + (size * 0.21);
                    
                    ctx.fillStyle = '#424242';
                    ctx.beginPath(); ctx.arc(-size*0.22, -size*0.05, size*0.1, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.22, -size*0.05, size*0.1, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#757575';
                    ctx.lineWidth = size * 0.12; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-size * 0.22, -size*0.05); ctx.lineTo(leftEnd, accordionCenterY); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(size * 0.22, -size*0.05); ctx.lineTo(rightEnd, accordionCenterY); ctx.stroke();

                    const bellowsHeight = size * 0.5;
                    ctx.save();
                    ctx.translate(0, accordionCenterY);
                    const folds = 10; const foldWidth = bellowsWidth / folds;
                    const bellowsDark = '#B22222', bellowsLight = '#DC143C', bellowsEdge = '#400000';
                    for(let i = 0; i < folds; i++) {
                        const currentX = -bellowsWidth/2 + i * foldWidth;
                        ctx.beginPath();
                        ctx.moveTo(currentX, -bellowsHeight/2); ctx.lineTo(currentX + foldWidth, -bellowsHeight/2 + size*0.06);
                        ctx.lineTo(currentX + foldWidth, bellowsHeight/2 - size*0.06); ctx.lineTo(currentX, bellowsHeight/2); ctx.closePath();
                        ctx.fillStyle = (i % 2 === 0) ? bellowsLight : bellowsDark; ctx.fill();
                        ctx.strokeStyle = bellowsEdge; ctx.lineWidth = 1.5; ctx.stroke();
                    }
                    ctx.restore();

                    ctx.save();
                    ctx.translate(leftEnd, accordionCenterY);
                    ctx.fillStyle = '#A21111'; ctx.strokeStyle = '#400000'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.roundRect(-size*0.16, -bellowsHeight/2 - size*0.08, size*0.33, bellowsHeight+size*0.16, size*0.06); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#333';
                    for(let i=0; i<3; i++) {
                        for(let j=0; j<5; j++) {
                            ctx.beginPath();
                            ctx.arc(-size*0.06 + i*(size*0.06), -bellowsHeight/2 + size*0.04 + j*(size*0.1), size*0.025, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                    ctx.restore();

                    ctx.save();
                    ctx.translate(rightEnd, accordionCenterY);
                    ctx.fillStyle = '#A21111'; ctx.strokeStyle = '#400000'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.roundRect(-size*0.16, -bellowsHeight/2 - size*0.08, size*0.33, bellowsHeight+size*0.16, size*0.06); ctx.fill(); ctx.stroke();
                    
                    const numKeys = 7;
                    const totalKeyAreaHeight = bellowsHeight + size * 0.14; 
                    const singleKeySlotHeight = totalKeyAreaHeight / numKeys;
                    const keyHeight = singleKeySlotHeight * 0.85; 
                    const keyWidth = size * 0.2;
                    const keyXOffset = -keyWidth / 2;
                    const startY = -bellowsHeight / 2 - size * 0.07; 

                    for(let i = 0; i < numKeys; i++) {
                        const keyY = startY + (i * singleKeySlotHeight);
                        const isGlowing = (Math.floor(time / 200 + i * 3) % 15 === 0);
                        
                        if (isGlowing) {
                            ctx.save();
                            ctx.fillStyle = '#FFFF00';
                            ctx.shadowColor = '#FFFF00';
                            ctx.shadowBlur = 15;
                            ctx.fillRect(keyXOffset, keyY, keyWidth, keyHeight);
                            ctx.restore();
                        } else {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(keyXOffset, keyY, keyWidth, keyHeight);
                        }
                    }
                    ctx.restore();

                    ctx.restore();
                }
            },
            {
                id: 'skin_arc_mechanical_observer',
                name: 'Observador Arc-Mecânico',
                rarity: 'Mítica',
                unlockCondition: { type: 'cost_corrupted', value: 9 },
                unlockHint: 'Custo: 9 Núcleos Corrompidos.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size * 1.1; const time = options.time;
                    const deltaTime = time - (player.lastTimeObs || time); player.lastTimeObs = time;

                    if (!player.observerState) {
                        player.observerState = {
                            rings: [
                                { angle: 0, speed: 0.0001, radius: size * 0.5, runes: 12, width: 3 },
                                { angle: Math.PI, speed: -0.00015, radius: size * 0.4, runes: 8, width: 4 },
                                { angle: Math.PI / 2, speed: 0.0002, radius: size * 0.3, runes: 6, width: 2.5 }
                            ]
                        };
                    }
                    const state = player.observerState;
                    
                    ctx.save(); ctx.translate(x, y);
                    
                    // --- CORREÇÃO APLICADA AQUI ---
                    const fontSize = size * 0.12; 
                    ctx.font = `bold ${fontSize}px "VT323"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // --- FIM DA CORREÇÃO ---

                    state.rings.forEach((ring, ringIdx) => {
                        ring.angle += ring.speed * deltaTime;
                        ctx.save(); ctx.rotate(ring.angle);
                        const ringGrad = ctx.createLinearGradient(-ring.radius, -ring.radius, ring.radius, ring.radius);
                        ringGrad.addColorStop(0, '#f9fafb'); ringGrad.addColorStop(0.5, '#9ca3af'); ringGrad.addColorStop(1, '#6b7280');
                        ctx.strokeStyle = ringGrad; ctx.lineWidth = ring.width; ctx.shadowColor = '#e0f2fe'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.arc(0, 0, ring.radius, 0, Math.PI * 2); ctx.stroke();
                        
                        for(let i=0; i<ring.runes; i++) {
                            const runeAngle = i * (Math.PI*2/ring.runes);
                            const currentAngleInWorld = (ring.angle + runeAngle) % (Math.PI*2);
                            const alignment = Math.min(Math.abs(currentAngleInWorld % (Math.PI/2)), Math.abs((currentAngleInWorld % (Math.PI/2)) - Math.PI/2));
                            const isAligned = alignment < 0.08;
                            const runeHue = (time / 15 + i * (360 / ring.runes) + ringIdx * 60) % 360;
                            const runeColor = `hsl(${runeHue}, 100%, 60%)`;
                            
                            ctx.save(); ctx.rotate(runeAngle); ctx.translate(ring.radius, 0); ctx.rotate(-ring.angle - runeAngle);
                            ctx.globalAlpha = isAligned ? 1 : 0.7; ctx.fillStyle = runeColor;
                            if(isAligned) { ctx.shadowColor = runeColor; ctx.shadowBlur = 30; } 
                            else { ctx.shadowColor = runeColor; ctx.shadowBlur = 10; }
                            ctx.fillText('❖', 0, 0); // Desenhado no centro
                            ctx.restore();
                        }
                        ctx.restore();
                    });
                    
                    ctx.shadowColor = 'transparent';
                    const eyeR = size * 0.25; const openFactor = 0.5 + Math.sin(time/1000) * 0.5;
                    
                    ctx.save(); ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath(); ctx.arc(0, 0, eyeR, 0, Math.PI * 2); ctx.clip();
                    for(let i=0; i<6; i++) {
                        const angle = i * Math.PI/3 + time*0.0005; const hue = (i*60 + (time/10))%360;
                        const grad = ctx.createLinearGradient(0,0, Math.cos(angle)*eyeR, Math.sin(angle)*eyeR);
                        grad.addColorStop(0, `hsla(${hue}, 100%, 60%, 0)`); grad.addColorStop(openFactor, `hsla(${hue}, 100%, 60%, 0.8)`); grad.addColorStop(1, `hsla(${hue}, 100%, 60%, 0)`);
                        ctx.strokeStyle = grad; ctx.lineWidth = eyeR;
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angle)*eyeR, Math.sin(angle)*eyeR); ctx.stroke();
                    }
                    ctx.restore();
                    
                    ctx.strokeStyle = 'rgba(224, 231, 255, 0.7)'; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.arc(0, 0, eyeR, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }
            },
        ];
        // --- END OF game/skins.ts ---

                // --- START OF game/CrisolPatterns.ts ---
        const CRISOL_PLAYER_STATS = {
            size: 40,
            speed: 320,
            lives: 3,
        };

        const CRISOL_ARENA = {
            width: 800,
            height: 800,
            get x() { return (CANVAS_WIDTH - this.width) / 2; },
            get y() { return (CANVAS_HEIGHT - this.height) / 2; },
            get centerX() { return this.x + this.width / 2; },
            get centerY() { return this.y + this.height / 2; },
        };

        const CRISOL_PROJECTILE_TYPES = {
            CLASSIC: { size: 12, color: '#e74c3c' },
            SLOW: { size: 14, color: '#3498db' },
            FAST: { size: 8, color: '#f1c40f' },
            RHYTHM: { size: 16, color: '#9b59b6' },
            WALL: { size: 10, color: '#7f8c8d', isStatic: true, life: 4000 },
            HOMING: { size: 10, color: '#2ecc71', isHoming: true, homingStrength: 0.03, lifetime: 6000 },
            BEAM_WARNING: { color: 'rgba(255, 255, 0, 0.3)'},
            BEAM: { color: '#f1c40f' },
        };

        const CRISOL_CHAMBERS = [
            // ========================= CÂMARA 01: A Geometria do Fluxo (Revisada) =========================
            {
                id: 'chamber_01',
                name: 'Câmara 01: A Geometria do Fluxo',
                reward: { systemCores: 8, corruptedKernels: 0 },
                sequences: [
                    // Minuto 1: Linhas e Espaços (Ensina desvio linear)
                    { duration: 60000, attacks: [
                        { type: 'line_random', from: 'top', count: 8, speed: 180, speedVariation: 0.1, startTime: 2000, interval: 2500, projectile: 'CLASSIC' },
                        { type: 'line_random', from: 'bottom', count: 8, speed: 180, speedVariation: 0.1, startTime: 10000, interval: 2500, projectile: 'CLASSIC' },
                        { type: 'drifting_line', from: 'left', spacing: 120, speed: 150, driftSpeed: 20, alternate: false, startTime: 35000, interval: 5000, projectile: 'SLOW' },
                    ]},

                    // Minuto 2 (1-2 min): Ecos Cinéticos (Introdução ao Ricochete)
                    { duration: 60000, attacks: [
                        // Começa com poucos projéteis para o jogador entender a mecânica
                        { type: 'ricochet', count: 8, speed: 170, startTime: 1000, interval: 6000, projectile: 'FAST' },
                        // Aumenta a quantidade na metade do tempo
                        { type: 'ricochet', count: 4, speed: 180, startTime: 30000, interval: 5000, projectile: 'FAST' },
                        // Adiciona um pulso lento para criar pressão e forçar movimento, sem sobrecarregar
                        { type: 'pulse', count: 8, speed: 130, startTime: 15000, interval: 8000, projectile: 'SLOW' },
                    ]},

                    // Minuto 3: A Dança dos Segmentos (Teste de controle de espaço e "pastoreio")
                    { duration: 60000, attacks: [
                        // Segmentos de projéteis que se movem como uma unidade, forçando o jogador a criar espaço.
                        { type: 'segment_swarm', numSegments: 10, length: 7, speed: 200, startTime: 1000, interval: 5000, projectile: 'RHYTHM' },
                        // Segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 4000, interval: 3000, projectile: 'FAST' },
                        // Mais segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 12000, interval: 3000, projectile: 'FAST' },
                        // Mais segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 24000, interval: 3000, projectile: 'FAST' },
                        // Mais segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 48000, interval: 3000, projectile: 'FAST' },
                    ]},
                    
                    // Minuto 4: O Labirinto de Ecos (Teste de memória de curto prazo e precisão)
                    { duration: 60000, attacks: [
                        // Pulsos de projéteis emanam de um ponto que se move pela arena, criando ondas assimétricas.
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 100, startTime: 1000, interval: 3500, projectile: 'SLOW' },
                        // Projéteis teleguiados impedem que o jogador fique parado ou encontre um ponto cego facilmente.
                        { type: 'homing', count: 2, speed: 170, startTime: 2500, interval: 5000, projectile: 'HOMING' },
                        // Pulsos de projéteis emanam de um ponto que se move pela arena, criando ondas assimétricas.
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 100, startTime: 10000, interval: 3500, projectile: 'SLOW' },
                        // Pulsos de projéteis emanam de um ponto que se move pela arena, criando ondas assimétricas.
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 100, startTime: 35000, interval: 3500, projectile: 'SLOW' },
                        // Projéteis teleguiados impedem que o jogador fique parado ou encontre um ponto cego facilmente.
                        { type: 'homing', count: 2, speed: 170, startTime: 45000, interval: 5000, projectile: 'HOMING' },
                    ]},

                    // Minuto 5: O Pulso Assimétrico (Teste de adaptação a padrões não-centrados)
                    { duration: 60000, attacks: [ 
                        {type: 'spiral',
                numArms: 4,
                projectilesPerArm: 10,
                rotationSpeed: 0.1,
                speed: 135,
                startTime: 10000,
                interval: 8000, // <--- 2. FREQUÊNCIA: Esta linha diz "Execute este ataque a cada 8.000 ms (8 segundos)".
                projectile: 'RHYTHM'},
                        { type: 'wave', from: 'left', count: 6, speed: 200, amplitude: 100, frequency: 0.008, startTime: 2500, interval: 6000, projectile: 'RHYTHM' },
                        { type: 'wave', from: 'right', count: 6, speed: 215, amplitude: 100, frequency: 0.012, startTime: 30000, interval: 6000, projectile: 'RHYTHM' }
                    ]},
                    
                    // Minuto 6: Fusão
                    { duration: 60000, attacks: [
                        //ATK do min1
                        { type: 'line_random', from: 'top', count: 8, speed: 180, speedVariation: 0.1, startTime: 2000, interval: 2500, projectile: 'CLASSIC' },
                        //ATK do min2
                        { type: 'ricochet', count: 8, speed: 170, startTime: 10000, interval: 6000, projectile: 'FAST' },
                        //ATK do min3
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 20000, interval: 3000, projectile: 'FAST' },
                        //ATK do min4
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 30000, startTime: 35000, interval: 3500, projectile: 'SLOW' },
                        //ATK do min5
                        { type: 'wave', from: 'left', count: 6, speed: 200, amplitude: 40000, frequency: 0.008, startTime: 2500, interval: 6000, projectile: 'RHYTHM' },
                    ]},
                ]
            },
            // ========================= CÂMARA 02: RITMO =========================
            {
                id: 'chamber_02',
                name: 'Câmara 02: O Coração da Máquina',
                reward: { systemCores: 6, corruptedKernels: 1 },
                sequences: [
                    // Minuto 1: Ondas Senoidais
                    { duration: 60000, attacks: [ { type: 'wave', from: 'left', count: 20, speed: 200, amplitude: 60, frequency: 0.01, startTime: 2000, interval: 6000, projectile: 'RHYTHM' }] },
                    // Minuto 2: Ondas Cruzadas
                    { duration: 60000, attacks: [ { type: 'wave', from: 'left', count: 15, speed: 210, amplitude: 70, frequency: 0.01, startTime: 0, interval: 5000, projectile: 'RHYTHM' }, { type: 'wave', from: 'top', count: 12, speed: 210, amplitude: 70, frequency: 0.01, startTime: 2500, interval: 5000, projectile: 'RHYTHM' }] },
                    // Minuto 3: Paredes Dançantes
                    { duration: 60000, attacks: [ { type: 'dancing_walls', gapSize: 350, speed: 100, startTime: 1000, interval: 7000, projectile: 'CLASSIC' }] },
                    // Minuto 4: Batida do Monitor (Pulso)
                    { duration: 60000, attacks: [ { type: 'beat_attack', attackType: 'pulse', count: 16, speed: 180, startTime: 3000, interval: 4000, projectile: 'RHYTHM' }] },
                    // Minuto 5: Ondas e Paredes
                    { duration: 60000, attacks: [ { type: 'wave', from: 'right', count: 15, speed: 220, amplitude: 80, frequency: 0.012, startTime: 0, interval: 6000, projectile: 'RHYTHM' }, { type: 'dancing_walls', gapSize: 300, speed: 120, startTime: 3000, interval: 8000, projectile: 'CLASSIC' }] },
                    // Minuto 6: Sincopado (Ondas na batida)
                    { duration: 60000, attacks: [ { type: 'beat_attack', attackType: 'wave', from:'top', count:10, speed: 250, amplitude: 50, frequency: 0.01, startTime: 1000, interval: 3000, projectile: 'RHYTHM' }, { type: 'wave', from: 'left', count: 15, speed: 200, amplitude: 100, frequency: 0.008, startTime: 2500, interval: 6000, projectile: 'RHYTHM' }] },
                ]
            },
            // ========================= CÂMARA 03: LABIRINTO =========================
            {
                id: 'chamber_03',
                name: 'Câmara 03: Arquitetura Hostil',
                reward: { systemCores: 7, corruptedKernels: 2 },
                sequences: [
                    // Minuto 1: Matriz de Cristal Simples
                    { duration: 60000, attacks: [ { type: 'crystal_matrix', rows: 4, cols: 4, speed: 250, holdTime: 3500, startTime: 3000, interval: 8000, projectile: 'WALL' }] },
                    // Minuto 2: Feixes de Varredura
                    { duration: 60000, attacks: [ { type: 'sweep_beam', from: 'left', speed: 80, startTime: 2000, interval: 5000, projectile: 'BEAM' }] },
                    // Minuto 3: Prisão de Contração
                    { duration: 60000, attacks: [ { type: 'shrinking_prison', speed: 200, holdTime: 2500, startTime: 4000, interval: 9000, projectile: 'CLASSIC' }] },
                    // Minuto 4: Feixes + Pulsos
                    { duration: 60000, attacks: [ { type: 'sweep_beam', from: 'top', speed: 90, startTime: 1000, interval: 6000, projectile: 'BEAM' }, { type: 'pulse', count: 8, speed: 150, startTime: 3500, interval: 6000, projectile: 'SLOW' }] },
                    // Minuto 5: Matriz + Feixes
                    { duration: 60000, attacks: [ { type: 'crystal_matrix', rows: 5, cols: 5, speed: 280, holdTime: 3000, startTime: 1000, interval: 8000, projectile: 'WALL' }, { type: 'sweep_beam', from: 'right', speed: 90, startTime: 5000, interval: 8000, projectile: 'BEAM' }] },
                    // Minuto 6: Prisão + Matriz
                    { duration: 60000, attacks: [ { type: 'shrinking_prison', speed: 220, holdTime: 2000, startTime: 1000, interval: 9000, projectile: 'CLASSIC' }, { type: 'crystal_matrix', rows: 3, cols: 3, speed: 300, holdTime: 2500, startTime: 5000, interval: 9000, projectile: 'WALL' }] },
                ]
            },
            // ========================= CÂMARA 04: REAÇÃO =========================
            {
                id: 'chamber_04',
                name: 'Câmara 04: O Jogo da Mente',
                reward: { systemCores: 8, corruptedKernels: 3 },
                sequences: [
                    // Minuto 1: Projéteis Camaleão
                    { duration: 60000, attacks: [ { type: 'chameleon', projectile: 'HOMING', count: 2, speed: 120, startTime: 2000, interval: 4000 }, { type: 'chameleon', projectile: 'FAST', count: 5, speed: 350, startTime: 2000, interval: 4000 } ] },
                    // Minuto 2: Marcação e Ataque
                    { duration: 60000, attacks: [ { type: 'target_player', count: 12, speed: 300, delay: 1500, startTime: 1000, interval: 3500, projectile: 'FAST' }] },
                    // Minuto 3: Ataques de Borda Falsos
                    { duration: 60000, attacks: [ { type: 'fake_out', trueFrom: 'top', falseFrom: 'bottom', count: 8, speed: 280, startTime: 2000, interval: 4000, projectile: 'CLASSIC' }] },
                    // Minuto 4: Camaleões + Marcação
                    { duration: 60000, attacks: [ { type: 'chameleon', projectile: 'HOMING', count: 3, speed: 130, startTime: 1000, interval: 4500 }, { type: 'target_player', count: 8, speed: 320, delay: 1200, startTime: 3000, interval: 4500, projectile: 'FAST' }] },
                    // Minuto 5: Marcação + Borda Falsa
                    { duration: 60000, attacks: [ { type: 'target_player', count: 10, speed: 350, delay: 1000, startTime: 0, interval: 4000, projectile: 'FAST' }, { type: 'fake_out', trueFrom: 'right', falseFrom: 'left', count: 6, speed: 300, startTime: 2000, interval: 4000, projectile: 'CLASSIC' }] },
                    // Minuto 6: Todos Juntos
                    { duration: 60000, attacks: [ { type: 'chameleon', projectile: 'HOMING', count: 2, speed: 140, startTime: 0, interval: 5000 }, { type: 'target_player', count: 6, speed: 380, delay: 900, startTime: 1500, interval: 5000, projectile: 'FAST' }, { type: 'fake_out', trueFrom: 'bottom', falseFrom: 'top', count: 5, speed: 320, startTime: 3500, interval: 5000, projectile: 'CLASSIC' }] },
                ]
            },
            // ========================= CÂMARA 05: SINFONIA =========================
            {
                id: 'chamber_05',
                name: 'Câmara 05: A Prova Final',
                reward: { systemCores: 10, corruptedKernels: 5 },
                sequences: [
                    // Minuto 1: Geometria + Ritmo
                    { duration: 60000, attacks: [ { type: 'line', from: 'top', count: 8, speed: 250, startTime: 1000, interval: 4000, projectile: 'CLASSIC' }, { type: 'wave', from: 'left', count: 15, speed: 220, amplitude: 60, frequency: 0.01, startTime: 3000, interval: 5000, projectile: 'RHYTHM' }] },
                    // Minuto 2: Ritmo + Labirinto
                    { duration: 60000, attacks: [ { type: 'beat_attack', attackType: 'pulse', count: 12, speed: 180, startTime: 1000, interval: 4000, projectile: 'RHYTHM' }, { type: 'sweep_beam', from: 'bottom', speed: 80, startTime: 3000, interval: 6000, projectile: 'BEAM' }] },
                    // Minuto 3: Labirinto + Reação
                    { duration: 60000, attacks: [ { type: 'crystal_matrix', rows: 4, cols: 4, speed: 300, holdTime: 2500, startTime: 1000, interval: 7000, projectile: 'WALL' }, { type: 'chameleon', projectile: 'HOMING', count: 2, speed: 130, startTime: 4000, interval: 7000 } ] },
                    // Minuto 4: Reação + Geometria
                    { duration: 60000, attacks: [ { type: 'target_player', count: 10, speed: 350, delay: 1200, startTime: 0, interval: 3500, projectile: 'FAST' }, { type: 'ricochet', count: 4, speed: 180, startTime: 1500, interval: 3500, projectile: 'FAST' } ] },
                    // Minuto 5: Rotação de Temas
                    { duration: 60000, attacks: [ { type: 'theme_rotation', themes: ['GEOMETRY', 'RHYTHM'], duration: 10000, startTime: 0, interval: 10000 } ] },
                    // Minuto 6: Caos Controlado
                    { duration: 60000, attacks: [ { type: 'theme_rotation', themes: ['LABYRINTH', 'REACTION'], duration: 8000, startTime: 0, interval: 8000 } ] },
                ]
            }
        ];
        // --- END OF game/CrisolPatterns.ts ---

        // --- START OF hooks/useCrisolEngine.ts ---
        const useCrisolEngine = (onGameOver) => {
            const { useState, useCallback, useRef } = React;

            const createInitialState = () => ({
                player: {
                    position: { x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY + 300 },
                    ...CRISOL_PLAYER_STATS,
                    lastMoveDirection: { x:0, y:-1 }, lastHitTime: 0,
                },
                projectiles: [],
                visualEffects: [],
                gameTime: 0,
                sequenceTime: 0,
                sequenceIndex: 0,
                isPausedBetweenSequences: true,
                pauseEndTime: 0,
                mode: null,
                chamberId: null,
                keys: { w: false, a: false, s: false, d: false, ' ': false },
                activeAttacks: {},
                isPaused: false,
            });

            const [gameState, setGameState] = useState(createInitialState);
            const chamberDataRef = useRef(null);
            
            const startChamber = useCallback((chamberId) => {
                const chamber = CRISOL_CHAMBERS.find(c => c.id === chamberId);
                if (!chamber) return;
                chamberDataRef.current = chamber;
                setGameState({
                    ...createInitialState(),
                    mode: 'chamber',
                    chamberId: chamberId,
                    isPausedBetweenSequences: true,
                    pauseEndTime: Date.now() + 3000,
                });
            }, [onGameOver]);

            const startInfinite = useCallback(() => {
                console.warn("Infinite Mode not implemented yet.");
            }, []);
            
            const handleKeys = useCallback((key, isDown) => {
                setGameState(prev => ({ ...prev, keys: { ...prev.keys, [key.toLowerCase()]: isDown } }));
            }, []);

            const pauseGame = useCallback(() => {
                setGameState(prev => ({ ...prev, isPaused: true }));
            }, []);

            const resumeGame = useCallback(() => {
                setGameState(prev => ({ ...prev, isPaused: false }));
            }, []);
            
            const spawnProjectiles = useCallback((attack, projType, now, playerPos, callCount = 0) => {
                const newProjectiles = [];
                const newEffects = [];
                const speed = attack.speed * (1 + (Math.random() - 0.5) * (attack.speedVariation || 0));

                switch(attack.type) {
                    case 'line':
                        for(let i=0; i < attack.count; i++) {
                            let pos, vel;
                            const from = attack.from === 'all' ? ['top', 'bottom', 'left', 'right'][i % 4] : attack.from;
                            const spacingX = CRISOL_ARENA.width / (attack.count + 1);
                            const spacingY = CRISOL_ARENA.height / (attack.count + 1);
                             if(attack.gap) {
                                const gapStart = CRISOL_ARENA.height * attack.gap.start;
                                const gapEnd = gapStart + CRISOL_ARENA.height * attack.gap.size;
                                const yPos = CRISOL_ARENA.y + i * (CRISOL_ARENA.height / (attack.count-1));
                                if (yPos > gapStart && yPos < gapEnd) continue;
                            }
                            if(from === 'top') { pos = { x: CRISOL_ARENA.x + spacingX * (i + 1), y: CRISOL_ARENA.y - 20 }; vel = { x: 0, y: speed }; } 
                            else if(from === 'bottom') { pos = { x: CRISOL_ARENA.x + spacingX * (i + 1), y: CRISOL_ARENA.y + CRISOL_ARENA.height + 20 }; vel = { x: 0, y: -speed }; } 
                            else if(from === 'left') { pos = { x: CRISOL_ARENA.x - 20, y: CRISOL_ARENA.y + (attack.gap ? i * (CRISOL_ARENA.height / (attack.count-1)) : spacingY * (i+1)) }; vel = { x: speed, y: 0 }; } 
                            else if(from === 'right') { pos = { x: CRISOL_ARENA.x + CRISOL_ARENA.width + 20, y: CRISOL_ARENA.y + (attack.gap ? i * (CRISOL_ARENA.height / (attack.count-1)) : spacingY * (i+1)) }; vel = { x: -speed, y: 0 }; }
                            if(pos) newProjectiles.push({ id: `p-${now}-line-${i}`, position: pos, velocity: vel, ...projType });
                        }
                        break;
                    case 'line_random':
                         for(let i = 0; i < attack.count; i++) {
                            let pos, vel;
                            const from = attack.from === 'all' ? ['top', 'bottom', 'left', 'right'][i % 4] : attack.from;
                            if (from === 'top') { pos = { x: CRISOL_ARENA.x + Math.random() * CRISOL_ARENA.width, y: CRISOL_ARENA.y - 20 }; vel = { x: 0, y: speed }; } 
                            else if (from === 'bottom') { pos = { x: CRISOL_ARENA.x + Math.random() * CRISOL_ARENA.width, y: CRISOL_ARENA.y + CRISOL_ARENA.height + 20 }; vel = { x: 0, y: -speed }; } 
                            else if (from === 'left') { pos = { x: CRISOL_ARENA.x - 20, y: CRISOL_ARENA.y + Math.random() * CRISOL_ARENA.height }; vel = { x: speed, y: 0 }; } 
                            else if (from === 'right') { pos = { x: CRISOL_ARENA.x + CRISOL_ARENA.width + 20, y: CRISOL_ARENA.y + Math.random() * CRISOL_ARENA.height }; vel = { x: -speed, y: 0 }; }
                            if(pos) newProjectiles.push({ id: `p-${now}-randline-${i}`, position: pos, velocity: vel, ...projType });
                        }
                        break;
                    case 'drifting_line':
                         const driftDirection = attack.alternate ? (callCount % 2 === 0 ? 1 : -1) : 1;
                        const driftSpeed = (attack.driftSpeed || 0) * driftDirection;
                        const spacing = attack.spacing || 60;
                        if (attack.from === 'top' || attack.from === 'bottom') {
                            const startY = attack.from === 'top' ? CRISOL_ARENA.y - 20 : CRISOL_ARENA.y + CRISOL_ARENA.height + 20;
                            const mainSpeed = attack.from === 'top' ? speed : -speed;
                            for (let currentX = CRISOL_ARENA.x; currentX <= CRISOL_ARENA.x + CRISOL_ARENA.width; currentX += spacing) {
                                newProjectiles.push({ id: `p-${now}-dvert-${currentX}`, position: { x: currentX, y: startY }, velocity: { x: driftSpeed, y: mainSpeed }, ...projType });
                            }
                        } else {
                            const startX = attack.from === 'left' ? CRISOL_ARENA.x - 20 : CRISOL_ARENA.x + CRISOL_ARENA.width + 20;
                            const mainSpeed = attack.from === 'left' ? speed : -speed;
                             for (let currentY = CRISOL_ARENA.y; currentY <= CRISOL_ARENA.y + CRISOL_ARENA.height; currentY += spacing) {
                                newProjectiles.push({ id: `p-${now}-dhoriz-${currentY}`, position: { x: startX, y: currentY }, velocity: { x: mainSpeed, y: driftSpeed }, ...projType });
                            }
                        }
                        break;
                    case 'pulse':
                        for (let i = 0; i < attack.count; i++) {
                            const angle = (i / attack.count) * Math.PI * 2;
                            const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            newProjectiles.push({ id: `p-${now}-pulse-${i}`, position: {x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY}, velocity: vel, ...projType });
                        }
                        break;
                    case 'spiral':
                        const armSpacing = (Math.PI * 2) / attack.numArms;
                        for (let i = 0; i < attack.projectilesPerArm; i++) {
                            setTimeout(() => {
                                setGameState(prev => {
                                    if (prev.isPaused || prev.isPausedBetweenSequences) return prev;
                                    const newProj = [];
                                    const rotation = i * attack.rotationSpeed;
                                    for (let j = 0; j < attack.numArms; j++) {
                                        const angle = j * armSpacing + rotation;
                                        const vel = { x: Math.cos(angle) * attack.speed, y: Math.sin(angle) * attack.speed };
                                        newProj.push({ id: `p-spiral-${now}-${i}-${j}`, position: {x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY}, velocity: vel, ...projType });
                                    }
                                    return { ...prev, projectiles: [...prev.projectiles, ...newProj] };
                                });
                            }, i * 50);
                        }
                        break;
                    case 'ricochet':
                         for (let i = 0; i < attack.count; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            newProjectiles.push({ id: `p-${now}-rico-${i}`, position: {x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY}, velocity: vel, ...projType, bounces: attack.bounces || 4 });
                         }
                        break;
                    case 'wave':
                         for (let i = 0; i < attack.count; i++) {
                             let pos, vel;
                             if(attack.from === 'left' || attack.from === 'right') {
                                pos = { x: attack.from === 'left' ? CRISOL_ARENA.x - 20 : CRISOL_ARENA.x + CRISOL_ARENA.width + 20, y: CRISOL_ARENA.y + (CRISOL_ARENA.height / attack.count) * i };
                                vel = { x: (attack.from === 'left' ? 1 : -1) * speed, y: 0 };
                             } else {
                                pos = { x: CRISOL_ARENA.x + (CRISOL_ARENA.width / attack.count) * i, y: attack.from === 'top' ? CRISOL_ARENA.y - 20 : CRISOL_ARENA.y + CRISOL_ARENA.height + 20 };
                                vel = { x: 0, y: (attack.from === 'top' ? 1 : -1) * speed };
                             }
                             newProjectiles.push({ id: `p-${now}-wave-${i}`, position: pos, velocity: vel, ...projType, wave: { amplitude: attack.amplitude, frequency: attack.frequency, initialPos: {...pos} } });
                         }
                        break;
                    case 'shrinking_prison':
                        const prisonPadding = 80;
                        const prison = { x: Math.max(CRISOL_ARENA.x + prisonPadding, playerPos.x - 200), y: Math.max(CRISOL_ARENA.y + prisonPadding, playerPos.y - 200), width: 400, height: 400, };
                        const gapSize = 100;
                        const gapSide = Math.floor(Math.random() * 4);
                        const spawnWallSegment = (p, v) => newProjectiles.push({ id: `p-prison-${p.x}-${p.y}-${now}`, position: p, velocity: v, ...projType, life: attack.holdTime + 1000 });
                        for (let x = prison.x; x <= prison.x + prison.width; x += projType.size * 1.5) {
                            if (gapSide !== 0 || x < prison.x + prison.width/2 - gapSize/2 || x > prison.x + prison.width/2 + gapSize/2) spawnWallSegment({x, y: prison.y}, {x:0, y:speed});
                            if (gapSide !== 2 || x < prison.x + prison.width/2 - gapSize/2 || x > prison.x + prison.width/2 + gapSize/2) spawnWallSegment({x, y: prison.y + prison.height}, {x:0, y:-speed});
                        }
                        for (let y = prison.y; y <= prison.y + prison.height; y += projType.size * 1.5) {
                            if (gapSide !== 3 || y < prison.y + prison.height/2 - gapSize/2 || y > prison.y + prison.height/2 + gapSize/2) spawnWallSegment({x: prison.x, y}, {x:speed, y:0});
                            if (gapSide !== 1 || y < prison.y + prison.height/2 - gapSize/2 || y > prison.y + prison.height/2 + gapSize/2) spawnWallSegment({x: prison.x + prison.width, y}, {x:-speed, y:0});
                        }
                        break;
                    case 'crystal_matrix':
                        const { rows: cRows, cols: cCols } = attack;
                        const cellWidth = CRISOL_ARENA.width / cCols;
                        const cellHeight = CRISOL_ARENA.height / cRows;
                        for(let r=0; r<cRows; r++){ for(let c=0; c<cCols; c++){ if(Math.random() > 0.35) {
                            const pos = { x: CRISOL_ARENA.x + c * cellWidth + cellWidth/2, y: CRISOL_ARENA.y + r * cellHeight + cellHeight/2 };
                            newProjectiles.push({ id: `p-crystal-${now}-${r}-${c}`, position: pos, velocity: {x:0, y:0}, ...projType, life: attack.holdTime, isStatic: true });
                        }}}
                        break;
                    case 'sweep_beam':
                        const beamWidth = 40;
                        const isHorizontal = attack.from === 'top' || attack.from === 'bottom';
                        newEffects.push({ id: `beam-${now}`, type: 'sweep_beam', from: attack.from, speed: attack.speed, width: beamWidth, startTime: now, duration: (isHorizontal ? CRISOL_ARENA.height / attack.speed : CRISOL_ARENA.width / attack.speed) * 1000 + 500, ...CRISOL_PROJECTILE_TYPES.BEAM, });
                        break;
                    case 'homing':
                        for (let i = 0; i < attack.count; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const spawnDist = 450;
                            const pos = { x: CRISOL_ARENA.centerX + Math.cos(angle) * spawnDist, y: CRISOL_ARENA.centerY + Math.sin(angle) * spawnDist };
                            newProjectiles.push({ id: `p-homing-${now}-${i}`, position: pos, velocity: {x:0, y:0}, ...projType, speed: attack.speed });
                        }
                        break;
                    case 'snipe':
                        newEffects.push({ id: `snipe-warn-${now}`, type: 'line_warning', start: {x: playerPos.x, y: CRISOL_ARENA.y}, end: {x: playerPos.x, y: CRISOL_ARENA.y + CRISOL_ARENA.height}, life: attack.delay });
                        newEffects.push({ id: `snipe-warn-h-${now}`, type: 'line_warning', start: {x: CRISOL_ARENA.x, y: playerPos.y}, end: {x: CRISOL_ARENA.x + CRISOL_ARENA.width, y: playerPos.y}, life: attack.delay });
                        setTimeout(() => {
                            setGameState(prev => {
                                if (prev.isPaused || prev.isPausedBetweenSequences) return prev;
                                const lastKnownPlayerPos = playerPos;
                                const newProj = [];
                                newProj.push({ id: `p-snipe-v-${now}`, position: {x: lastKnownPlayerPos.x, y: CRISOL_ARENA.y - 20}, velocity: {x: 0, y: attack.speed}, ...projType });
                                newProj.push({ id: `p-snipe-h-${now}`, position: {x: CRISOL_ARENA.x - 20, y: lastKnownPlayerPos.y}, velocity: {x: attack.speed, y: 0}, ...projType });
                                return { ...prev, projectiles: [...prev.projectiles, ...newProj] };
                            });
                        }, attack.delay);
                        break;

                    // --- NOVOS CASES PARA ATAQUES DE DESVIO PURO (REFORMULAÇÃO) ---
                    case 'segment_swarm':
                        for(let i=0; i < attack.numSegments; i++) {
                            const angleToPlayer = Math.atan2(playerPos.y - CRISOL_ARENA.centerY, playerPos.x - CRISOL_ARENA.centerX) + (Math.random() - 0.5) * 2;
                            const spawnRadius = 500;
                            const basePos = { x: CRISOL_ARENA.centerX + Math.cos(angleToPlayer) * spawnRadius, y: CRISOL_ARENA.centerY + Math.sin(angleToPlayer) * spawnRadius };
                            const dir = normalizeVector({ x: playerPos.x - basePos.x, y: playerPos.y - basePos.y });
                            const perpDir = { x: -dir.y, y: dir.x };
                            for(let j=0; j < attack.length; j++) {
                                const offset = (j - Math.floor(attack.length / 2)) * (projType.size * 1.5);
                                newProjectiles.push({ id: `p-segswarm-${now}-${i}-${j}`, position: { x: basePos.x + perpDir.x * offset, y: basePos.y + perpDir.y * offset }, velocity: { x: dir.x * speed, y: dir.y * speed }, ...projType });
                            }
                        }
                        break;
                    case 'segment_cutter':
                        const isHorizontalCutter = Math.random() > 0.5;
                        const startEdgeCutter = isHorizontalCutter ? (Math.random() > 0.5 ? CRISOL_ARENA.x - 20 : CRISOL_ARENA.x + CRISOL_ARENA.width + 20) : (Math.random() > 0.5 ? CRISOL_ARENA.y - 20 : CRISOL_ARENA.y + CRISOL_ARENA.height + 20);
                        const startCrossCutter = isHorizontalCutter ? Math.random() * CRISOL_ARENA.height + CRISOL_ARENA.y : Math.random() * CRISOL_ARENA.width + CRISOL_ARENA.x;
                        const velCutter = isHorizontalCutter ? { x: startEdgeCutter < CRISOL_ARENA.centerX ? speed : -speed, y: 0 } : { x: 0, y: startEdgeCutter < CRISOL_ARENA.centerY ? speed : -speed };
                        for(let i=0; i < attack.length; i++) {
                            const pos = isHorizontalCutter ? { x: startEdgeCutter, y: startCrossCutter + (i - Math.floor(attack.length / 2)) * (projType.size * 1.5) } : { x: startCrossCutter + (i - Math.floor(attack.length / 2)) * (projType.size * 1.5), y: startEdgeCutter };
                            newProjectiles.push({ id: `p-segcut-${now}-${i}`, position: pos, velocity: velCutter, ...projType });
                        }
                        break;
                    case 'echo_maze':
                        const { rows: mazeRows, cols: mazeCols, warningTime: mazeWarningTime, projectileLifetime: mazeLifetime } = attack;
                        const mazeCellWidth = CRISOL_ARENA.width / mazeCols;
                        const mazeCellHeight = CRISOL_ARENA.height / mazeRows;
                        const mazeGrid = Array(mazeRows).fill(null).map(() => Array(mazeCols).fill(true));
                        let mazeCurrent = { r: Math.floor(Math.random() * mazeRows), c: Math.floor(Math.random() * mazeCols) };
                        const mazeStack = [mazeCurrent];
                        mazeGrid[mazeCurrent.r][mazeCurrent.c] = false;
                        while(mazeStack.length > 0) {
                            mazeCurrent = mazeStack[mazeStack.length - 1];
                            const neighbors = [];
                            const {r, c} = mazeCurrent;
                            if (r > 1 && mazeGrid[r-2][c]) neighbors.push({r: r-2, c: c, wall: {r: r-1, c: c}});
                            if (r < mazeRows - 2 && mazeGrid[r+2][c]) neighbors.push({r: r+2, c: c, wall: {r: r+1, c: c}});
                            if (c > 1 && mazeGrid[r][c-2]) neighbors.push({r: r, c: c-2, wall: {r: r, c: c-1}});
                            if (c < mazeCols - 2 && mazeGrid[r][c+2]) neighbors.push({r: r, c: c+2, wall: {r: r, c: c+1}});
                            if (neighbors.length > 0) { const next = neighbors[Math.floor(Math.random() * neighbors.length)]; mazeGrid[next.wall.r][next.wall.c] = false; mazeGrid[next.r][next.c] = false; mazeStack.push({r: next.r, c: next.c}); } 
                            else { mazeStack.pop(); }
                        }
                        for(let r=0; r<mazeRows; r++) { for(let c=0; c<mazeCols; c++) { if (mazeGrid[r][c]) {
                            newEffects.push({ id: `maze-warn-${now}-${r}-${c}`, type: 'zone_warning', rect: { x: CRISOL_ARENA.x + c * mazeCellWidth, y: CRISOL_ARENA.y + r * mazeCellHeight, width: mazeCellWidth, height: mazeCellHeight }, life: mazeWarningTime, color: 'rgba(255, 100, 0, 0.4)' });
                        }}}
                        setTimeout(() => { setGameState(prev => { if (prev.isPaused || prev.isPausedBetweenSequences) return prev; const newProj = [];
                            for(let r=0; r<mazeRows; r++) { for(let c=0; c<mazeCols; c++) { if (mazeGrid[r][c]) {
                                newProj.push({ id: `p-maze-${now}-${r}-${c}`, position: { x: CRISOL_ARENA.x + c * mazeCellWidth + mazeCellWidth/2, y: CRISOL_ARENA.y + r * mazeCellHeight + mazeCellHeight/2 }, velocity: {x:0, y:0}, ...projType, life: mazeLifetime, isStatic: true });
                            }}} return { ...prev, projectiles: [...prev.projectiles, ...newProj] }; });
                        }, mazeWarningTime);
                        break;
                    case 'wandering_pulse':
                        const emitterPos = { x: CRISOL_ARENA.x + Math.random() * CRISOL_ARENA.width, y: CRISOL_ARENA.y + Math.random() * CRISOL_ARENA.height };
                        newEffects.push({ id: `emitter-${now}`, type: 'emitter_marker', position: emitterPos, life: 3000, color: 'rgba(255, 255, 0, 0.8)' });
                        for (let i = 0; i < attack.count; i++) {
                            const angle = (i / attack.count) * Math.PI * 2;
                            const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            newProjectiles.push({ id: `p-wandering-${now}-${i}`, position: emitterPos, velocity: vel, ...projType });
                        }
                        break;
                    case 'matrix_corruption':
                        const { rows: mRows, cols: mCols, speed: mSpeed, turnDelay } = attack;
                        const xStep = CRISOL_ARENA.width / (mCols + 1);
                        for(let r=0; r<mRows; r++) {
                            const vel = { x: 0, y: mSpeed };
                            newProjectiles.push({ id: `p-matrix-${now}-${r}`, position: { x: CRISOL_ARENA.x + (r + 1) * xStep, y: CRISOL_ARENA.y - 20 }, velocity: vel, ...projType, color: '#f39c12', special: { type: 'matrix_corruption', turnDelay: now + turnDelay }, baseSpeed: mSpeed });
                        }
                        break;
                }
                return { newProjectiles, newEffects };
            }, [setGameState]);

            //gametick começa aqui

            const gameTick = useCallback((deltaTime) => {
                setGameState(prev => {
                    if (!prev.mode || prev.isPaused) return prev;
                    const newState = JSON.parse(JSON.stringify(prev));
                    const now = Date.now();
                    const { player, projectiles, keys, visualEffects } = newState;

                    if (newState.isPausedBetweenSequences) {
                        if (now >= newState.pauseEndTime) newState.isPausedBetweenSequences = false;
                        return newState;
                    }
                    
                    if (keys[' '] && !player.isDashing && now > player.dashCooldownUntil) {
                        player.isDashing = true; player.dashEndTime = now + DASH_STATS.DURATION; player.dashCooldownUntil = now + DASH_STATS.COOLDOWN * 0.8;
                        const moveDir = normalizeVector({ x: (keys.d ? 1:0) - (keys.a ? 1:0), y: (keys.s ? 1:0) - (keys.w ? 1:0) });
                        player.dashDirection = (moveDir.x === 0 && moveDir.y === 0) ? player.lastMoveDirection : moveDir;
                        SoundManager.play('playerDash');
                    }
                    if (player.isDashing) {
                        if (now > player.dashEndTime) player.isDashing = false;
                        else {
                            player.position.x += player.dashDirection.x * player.speed * DASH_STATS.SPEED_MULTIPLIER * deltaTime;
                            player.position.y += player.dashDirection.y * player.speed * DASH_STATS.SPEED_MULTIPLIER * deltaTime;
                        }
                    } else if (keys.w || keys.a || keys.s || keys.d) {
                        const norm = normalizeVector({x: (keys.d ? 1:0) - (keys.a ? 1:0), y: (keys.s ? 1:0) - (keys.w ? 1:0)});
                        player.lastMoveDirection = norm;
                        player.position.x += norm.x * player.speed * deltaTime;
                        player.position.y += norm.y * player.speed * deltaTime;
                    }
                    player.position.x = Math.max(CRISOL_ARENA.x + player.size / 2, Math.min(CRISOL_ARENA.x + CRISOL_ARENA.width - player.size / 2, player.position.x));
                    player.position.y = Math.max(CRISOL_ARENA.y + player.size / 2, Math.min(CRISOL_ARENA.y + CRISOL_ARENA.height - player.size / 2, player.position.y));

                    if (newState.mode === 'chamber') {
                        newState.gameTime += deltaTime;
                        newState.sequenceTime += deltaTime * 1000;
                        const currentSequence = chamberDataRef.current.sequences[newState.sequenceIndex];
                        
                        if (currentSequence) {
                            currentSequence.attacks.forEach((attack, index) => {
                                const attackState = newState.activeAttacks[index] || { lastSpawnTime: 0, callCount: 0 };
                                if (newState.sequenceTime >= attack.startTime && now - attackState.lastSpawnTime > attack.interval) {
                                    const projType = CRISOL_PROJECTILE_TYPES[attack.projectile];
                                    const { newProjectiles, newEffects } = spawnProjectiles(attack, projType, now, player.position, attackState.callCount);
                                    projectiles.push(...newProjectiles);
                                    visualEffects.push(...newEffects);
                                    newState.activeAttacks[index] = { lastSpawnTime: now, callCount: attackState.callCount + 1 };
                                }
                            });
                        }

                        projectiles.forEach(p => { 
                            if (!p.isStatic) {
                                if (p.isHoming) {
                                    const dirToPlayer = normalizeVector({ x: player.position.x - p.position.x, y: player.position.y - p.position.y });
                                    const homingForce = p.homingStrength || 0.03;
                                    p.velocity.x = p.velocity.x * (1 - homingForce) + (dirToPlayer.x * p.speed * homingForce);
                                    p.velocity.y = p.velocity.y * (1 - homingForce) + (dirToPlayer.y * p.speed * homingForce);
                                    const currentSpeed = Math.sqrt(p.velocity.x**2 + p.velocity.y**2);
                                    if (currentSpeed > p.speed) { p.velocity.x = (p.velocity.x / currentSpeed) * p.speed; p.velocity.y = (p.velocity.y / currentSpeed) * p.speed; }
                                }
                                if (p.special?.type === 'matrix_corruption' && now > p.special.turnDelay) {
                                    const originalSpeed = p.baseSpeed;
                                    const oldVelX = p.velocity.x;
                                    p.velocity.x = 0;
                                    p.velocity.y = (oldVelX !== 0 ? Math.sign(oldVelX) : 1) * originalSpeed; // Vira para baixo ou para cima
                                    p.color = '#e74c3c';
                                    p.special = null;
                                }
                                p.position.x += p.velocity.x * deltaTime;
                                p.position.y += p.velocity.y * deltaTime;
                            }
                            if (p.life) p.life -= deltaTime * 1000;
                            if (p.lifetime) p.lifetime -= deltaTime * 1000;
                            if (p.bounces > 0) {
                               if ((p.position.x <= CRISOL_ARENA.x && p.velocity.x < 0) || (p.position.x >= CRISOL_ARENA.x + CRISOL_ARENA.width && p.velocity.x > 0)) { p.velocity.x *= -1; p.bounces--; }
                               if ((p.position.y <= CRISOL_ARENA.y && p.velocity.y < 0) || (p.position.y >= CRISOL_ARENA.y + CRISOL_ARENA.height && p.velocity.y > 0)) { p.velocity.y *= -1; p.bounces--; }
                            }
                            if (p.wave) {
                               if(p.velocity.x !== 0) { p.position.y = p.wave.initialPos.y + Math.sin((p.position.x - p.wave.initialPos.x) * p.wave.frequency) * p.wave.amplitude; }
                               else { p.position.x = p.wave.initialPos.x + Math.sin((p.position.y - p.wave.initialPos.y) * p.wave.frequency) * p.wave.amplitude; }
                            }
                        });
                        
                        newState.projectiles = projectiles.filter(p => {
                            const padding = p.size / 2 + 5; 
                            if (p.position.x < CRISOL_ARENA.x - padding && p.velocity.x < 0) return false;
                            if (p.position.x > CRISOL_ARENA.x + CRISOL_ARENA.width + padding && p.velocity.x > 0) return false;
                            if (p.position.y < CRISOL_ARENA.y - padding && p.velocity.y < 0) return false;
                            if (p.position.y > CRISOL_ARENA.y + CRISOL_ARENA.height + padding && p.velocity.y > 0) return false;
                            if (p.life && p.life <= 0) return false;
                            if (p.lifetime && p.lifetime <= 0) return false;
                            return true;
                        });
                        
                        newState.visualEffects.forEach(e => e.life -= deltaTime * 1000);
                        newState.visualEffects = visualEffects.filter(e => e.life > 0);

                        if (!player.isDashing && now - player.lastHitTime > 500) {
                            for (const p of projectiles) {
                                if (calculateDistance(p.position, player.position) < p.size/2 + player.size/2) {
                                    SoundManager.play('playerHit');
                                    player.lives--;
                                    player.lastHitTime = now;
                                    if (player.lives <= 0) { onGameOver({ victory: false, chamberId: newState.chamberId }); }
                                    break;
                                }
                            }
                        }

                        if (currentSequence && newState.sequenceTime >= currentSequence.duration) {
                            newState.sequenceIndex++;
                            newState.sequenceTime = 0;
                            player.lives = CRISOL_PLAYER_STATS.lives;
                            
                            if (newState.sequenceIndex >= chamberDataRef.current.sequences.length) {
                                onGameOver({ victory: true, chamberId: newState.chamberId });
                            } else {
                                newState.isPausedBetweenSequences = true;
                                newState.pauseEndTime = now + 3000;
                                newState.projectiles = [];
                                newState.visualEffects = [];
                                newState.activeAttacks = {};
                            }
                        }
                    }
                    return newState;
                });
            }, [onGameOver, spawnProjectiles]);
            
            return { gameState, handleKeys, startChamber, startInfinite, gameTick, pauseGame, resumeGame };
        };
        // --- END OF hooks/useCrisolEngine.ts ---

        // --- START OF hooks/useChat.ts ---
        const useChat = (username, userId) => {
            const [messages, setMessages] = React.useState([]);
            const [error, setError] = React.useState(null);

            // Função para buscar as mensagens iniciais
            const fetchInitialMessages = React.useCallback(async () => {
                try {
                    const { data, error } = await supabase
                        .from('chat_messages')
                        .select('*')
                        .order('created_at', { ascending: false })
                        .limit(50);

                    if (error) throw error;
                    // Invertemos para que as mais antigas fiquem em cima
                    setMessages(data.reverse());
                } catch (err) {
                    console.error("Erro ao buscar mensagens do chat:", err);
                    setError("Não foi possível carregar o histórico do chat.");
                }
            }, []);

            // Configura a subscrição em tempo real
            React.useEffect(() => {
                fetchInitialMessages();

                const channel = supabase.channel('public:chat_messages')
                    .on(
                        'postgres_changes',
                        { event: 'INSERT', schema: 'public', table: 'chat_messages' },
                        (payload) => {
                            setMessages(currentMessages => [...currentMessages, payload.new]);
                        }
                    )
                    .subscribe((status, err) => {
                        if (err) {
                            console.error("Erro na subscrição do chat:", err);
                            setError("Desconectado do chat.");
                        }
                    });
                
                // Limpeza ao desmontar o componente
                return () => {
                    supabase.removeChannel(channel);
                };
            }, [fetchInitialMessages]);

            // Função para enviar uma nova mensagem
            const sendMessage = async (content) => {
                if (!content.trim()) return;

                const { error } = await supabase
                    .from('chat_messages')
                    .insert({ content: content.trim(), username, user_id: userId });

                if (error) {
                    console.error("Erro ao enviar mensagem:", error);
                    setError("Falha ao enviar mensagem.");
                }
            };

            return { messages, sendMessage, error };
        };
        // --- END OF hooks/useChat.ts ---

        // --- NOVO: Funções de Desenho para Inimigos da Fase 4 ---
        function drawRecursiveProcess(ctx, enemy, time) {
            const pulse = Math.sin(time / 400) * 0.1;
            const size = enemy.size * (1 + pulse);
            ctx.save();
            ctx.translate(enemy.position.x, enemy.position.y);
            // Orbitais
            for (let i = 0; i < 3; i++) {
                const angle = (time / 800) + (i * (Math.PI * 2 / 3));
                const orbitRadius = size * 0.8;
                ctx.fillStyle = 'rgba(251, 146, 60, 0.5)';
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * orbitRadius, Math.sin(angle) * orbitRadius, size * 0.15, 0, Math.PI * 2);
                ctx.fill();
            }
            // Núcleo
            ctx.fillStyle = enemy.color;
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(0, -size / 2);
            for (let i = 1; i < 6; i++) {
                const angle = i * (Math.PI * 2 / 6);
                ctx.lineTo(size/2 * Math.cos(angle - Math.PI/2), size/2 * Math.sin(angle - Math.PI/2));
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawChildProcess(ctx, enemy, time) {
            ctx.save();
            ctx.translate(enemy.position.x, enemy.position.y);
            // Rastro de glitch
            if (!enemy.trail) enemy.trail = [];
            enemy.trail.push({x: 0, y: 0});
            if (enemy.trail.length > 5) enemy.trail.shift();
            enemy.trail.forEach((p, i) => {
                ctx.globalAlpha = (i / enemy.trail.length) * 0.5;
                ctx.fillStyle = GAME_COLORS.DATA_FLOW_MAGENTA;
                ctx.fillRect(p.x - enemy.size/2 + (Math.random()-0.5)*4, p.y - enemy.size/2 + (Math.random()-0.5)*4, enemy.size, enemy.size);
            });
            // Corpo principal
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = enemy.color;
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 10;
            ctx.fillRect(-enemy.size/2 + (Math.random()-0.5)*2, -enemy.size/2 + (Math.random()-0.5)*2, enemy.size, enemy.size);
            ctx.restore();
        }
        
        function drawRogueFirewall(ctx, enemy, time) {
            const segments = 6;
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.save();
            ctx.translate(enemy.position.x, enemy.position.y);
            for (let i = 0; i < segments; i++) {
                if (Math.random() > healthPercent * 0.8) continue; // Segmentos falham com dano
                const angle = (i * (Math.PI * 2 / segments)) + time/5000;
                const nextAngle = ((i + 1) * (Math.PI * 2 / segments)) + time/5000;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(enemy.size * Math.cos(angle), enemy.size * Math.sin(angle));
                ctx.lineTo(enemy.size * Math.cos(nextAngle), enemy.size * Math.sin(nextAngle));
                ctx.closePath();
                ctx.fillStyle = `rgba(234, 179, 8, ${0.4 + Math.sin(angle + time/200)*0.2})`;
                ctx.fill();
            }
            ctx.strokeStyle = enemy.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.size * 0.3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        // --- FIM DAS FUNÇÕES DE DESENHO ---

        const ENEMY_DEFAULT_STATS = {
            size: 15, baseSpeed: 75, health: 17, damage: 10, expValue: 30, type: EnemyType.DEFAULT, color: GAME_COLORS.ENEMY_DEFAULT, isConvertible: true
        };
        const ENEMY_MEMORY_LEAK_STATS = {
            size: 18, baseSpeed: 65, health: 30, damage: 12, expValue: 40, type: EnemyType.MEMORY_LEAK, color: GAME_COLORS.ENEMY_MEMORY_LEAK,
            trailDropInterval: 200, trailDamage: 2, trailLifetime: 3000, trailSize: 8, isConvertible: true,
        };
        const ENEMY_SPYWARE_STATS = {
            size: 14, baseSpeed: 90, health: 25, damage: 8, expValue: 35, type: EnemyType.SPYWARE, color: GAME_COLORS.ENEMY_SPYWARE,
            invisibilityDuration: 3000, visibilityDuration: 3000, isConvertible: true,
        };
        const ENEMY_TROJAN_HORSE_STATS = {
            size: 35, baseSpeed: 40, health: 120, damage: 20, expValue: 75, type: EnemyType.TROJAN_HORSE, color: GAME_COLORS.ENEMY_TROJAN,
            fragmentsToSpawn: 3, isConvertible: false,
        };
        const ENEMY_MALWARE_FRAGMENT_STATS = {
            size: 10, baseSpeed: 80, health: 10, damage: 5, expValue: 5, type: EnemyType.MALWARE_FRAGMENT, color: GAME_COLORS.ENEMY_DEFAULT, isConvertible: false,
        };
        const ENEMY_ROOTKIT_STATS = {
            size: 20, baseSpeed: 100, health: 85, damage: 25, expValue: 100, type: EnemyType.ROOTKIT, color: GAME_COLORS.ENEMY_ROOTKIT, isConvertible: false,
        };
        const ENEMY_DDOS_BOT_STATS = {
            size: 12, baseSpeed: 150, health: 16, damage: 7, expValue: 20, type: EnemyType.DDOS_BOT, color: GAME_COLORS.ENEMY_DDOS_BOT,
            swarmCount: 3, isConvertible: true,
        };
        const GLITCH_MINION_STATS = {
            size: 10, baseSpeed: 130, health: 20, damage: 8, expValue: 8, type: EnemyType.GLITCH_MINION, color: GAME_COLORS.ENEMY_GLITCH_MINION, isConvertible: false
        };

        const ENEMY_PROCESSO_CORROMPIDO_STATS = {
            size: 16, baseSpeed: 110, health: 28, damage: 12, expValue: 45, type: EnemyType.PROCESSO_CORROMPIDO, color: GAME_COLORS.ENEMY_PROCESSO_CORROMPIDO, isConvertible: true
        };
        const ENEMY_PONTEIRO_NULO_STATS = {
            size: 18, baseSpeed: 70, health: 45, damage: 18, expValue: 70, type: EnemyType.PONTEIRO_NULO, color: GAME_COLORS.ENEMY_PONTEIRO_NULO,
            teleportChargeTime: 1500, teleportCooldown: 4000, isConvertible: true
        };
        const ENEMY_SEGMENTO_FALHA_STATS = {
            size: 28, baseSpeed: 50, health: 130, damage: 22, expValue: 120, type: EnemyType.SEGMENTO_FALHA, color: GAME_COLORS.ENEMY_SEGMENTO_FALHA,
            shieldDuration: 3000, shieldCooldown: 5000, shieldDamageReduction: 0.8, isConvertible: false
        };
        const ENEMY_PROCESSO_ZUMBI_STATS = {
            size: 22, baseSpeed: 45, health: 160, damage: 15, expValue: 100, type: EnemyType.PROCESSO_ZUMBI, color: GAME_COLORS.ENEMY_PROCESSO_ZUMBI,
            reviveChance: 0.40, reviveTime: 3000, reviveHealthFactor: 0.5, isConvertible: false
        };

        const ENEMY_NANITE_STATS = {
            size: 12, baseSpeed: 120, health: 50, damage: 15, expValue: 60, type: EnemyType.NANITE, color: GAME_COLORS.ENEMY_NANITE, isConvertible: true
        };
        const ENEMY_HEATSINK_STATS = {
            size: 30, baseSpeed: 30, health: 160, damage: 20, expValue: 90, type: EnemyType.HEATSINK, color: GAME_COLORS.ENEMY_HEATSINK, pulseInterval: 2500, isConvertible: false
        };
        const ENEMY_IO_CONTROLLER_STATS = {
            size: 20, baseSpeed: 60, health: 90, damage: 18, expValue: 80, type: EnemyType.IO_CONTROLLER, color: GAME_COLORS.ENEMY_IO_CONTROLLER, fireRate: 3000, projectileSpeed: 200, projectileSize: 8, spread: 20, isConvertible: false
        };
        const ENEMY_VOLATILE_PROCESS_STATS = {
            size: 50, baseSpeed: 80, health: 190, damage: 0, expValue: 100, type: EnemyType.VOLATILE_PROCESS, color: GAME_COLORS.ENEMY_VOLATILE_PROCESS, fuseTime: 8000, explosionDamage: 60, explosionRadius: 100, isConvertible: false
        };

        // --- FASE 4 INIMIGOS (NOVO) ---
        const ENEMY_RECURSIVE_PROCESS_STATS = {
            size: 22, baseSpeed: 80, health: 120, damage: 25, expValue: 0, // XP é dado pelos filhos
            type: EnemyType.RECURSIVE_PROCESS, color: GAME_COLORS.ENEMY_RECURSIVE_PROCESS, isConvertible: true
        };
        const ENEMY_CHILD_PROCESS_STATS = {
            size: 12, baseSpeed: 190, health: 35, damage: 12, expValue: 40, // Cada filho dá XP
            type: EnemyType.CHILD_PROCESS, color: GAME_COLORS.ENEMY_CHILD_PROCESS, isConvertible: false
        };
        const ENEMY_ROGUE_FIREWALL_STATS = {
            size: 60, baseSpeed: 40, health: 300, damage: 25, expValue: 150, 
            type: EnemyType.ROGUE_FIREWALL, color: GAME_COLORS.ENEMY_ROGUE_FIREWALL, isConvertible: false, projectileBlockHealth: 100
        };
        const ENEMY_LATENCY_SPIKE_STATS = {
            size: 25, baseSpeed: 70, health: 150, damage: 10, expValue: 120, 
            type: EnemyType.LATENCY_SPIKE, color: GAME_COLORS.ENEMY_LATENCY_SPIKE, isConvertible: false, slowAuraRadius: 180, slowMagnitude: 0.4
        };
        const ENEMY_PROTOCOL_ANOMALY_STATS = {
            size: 28, baseSpeed: 90, health: 250, damage: 30, expValue: 200, 
            type: EnemyType.PROTOCOL_ANOMALY, color: GAME_COLORS.ENEMY_PROTOCOL_ANOMALY, isConvertible: false, protocolSwitchInterval: 8000
        };

        const ENEMY_SPAWN_TIMES = {
            [EnemyType.MEMORY_LEAK]: 60,
            [EnemyType.SPYWARE]: 120,
            [EnemyType.TROJAN_HORSE]: 180,
            [EnemyType.ROOTKIT]: 240,
            [EnemyType.DDOS_BOT]: 300,
        };
        
        const BOSS_TRIGGER_TIME = 420;
        const BOSS_2_TRIGGER_TIME = 780;
        const BOSS_3_TRIGGER_TIME = 1140;
        const BOSS_4_TRIGGER_TIME = 1500; // --- NOVO --- (25 minutos)

        const BOSS_WARNING_DURATION = 4500;

        const BOSS_PHASE_HEALTH_THRESHOLDS = {
            PHASE_2: 0.70,
            PHASE_3: 0.35,
        };

        const BOSS_STATS = {
            size: 60, coreSize: 25, maxHealth: 5000, damage: 30, speed: 135,
            projectilePhase1Speed: 150, projectilePhase1Size: 30, projectilePhase1Damage: 20, projectilePhase1FireRate: 1500,
            projectilePhase2Speed: 200, projectilePhase2Size: 10, projectilePhase2Damage: 15, projectilePhase2FireRate: 1200, projectilePhase2BurstCount: 3, projectilePhase2BurstInterval: 100,
            pulseAttackCooldown: 5000, pulseAttackRadius: 180, pulseAttackForce: 300,
            corruptedZoneInterval: 5000, corruptedZoneRadius: 90, corruptedZoneDuration: 4000, corruptedZoneDamage: 5, corruptedZoneDamageInterval: 250, 
            glitchMinionSpawnInterval: 7000, glitchMinionSpawnCount: 6,
            dataStreamBarrageInterval: 3000, dataStreamProjectileCount: 12, dataStreamProjectileSize: 7, dataStreamProjectileSpeed: 280, dataStreamProjectileDamage: 10,
            kernelPanicPulseChargeTime: 2500, kernelPanicPulseRadius: 300, kernelPanicPulseDamage: 50, kernelPanicPulseCooldown: 10000, 
        };

        const BOSS_SHIELD_NODE_STATS = {
            count: 3, size: 20, orbitRadius: 100, orbitSpeed: 0.02, maxHealth: 250, color: GAME_COLORS.BOSS_SHIELD_NODE,
        };
        
        const BOSS_2_STATS = {
            size: 70, maxHealth: 9000, damage: 40, 
            phase1EnergyWaveInterval: 4000, phase1EnergyWaveDamage: 15, phase1EnergyWaveRadius: 250,
            phase2HealthThreshold: 1.0, 
            phase3HealthThreshold: 0.40,
            laserChargeTime: 1200, laserFireDuration: 1800, laserDamage: 25, laserWidth: 30, laserRotationSpeed: 0.02, laserCooldown: 8000,
            dataWallSpawnInterval: 6000, dataWallSpeed: 130, dataWallDamage: 20, dataWallWidth: 40, dataWallGap: 200,
            phase3MinionSpawnInterval: 4000, phase3MinionSpawnCount: 10,
            phase2NovaRate: 4000,
            phase2NovaProjectileCount: 20,
            phase2NovaProjectileSpeed: 200,
            phase2NovaProjectileSize: 8,
            phase2NovaProjectileDamage: 12,
        };

        const BOSS_2_SUB_ROUTINE_STATS = {
            count: 4, size: 25, orbitRadius: 200, orbitSpeed: 0.015, maxHealth: 750,
            projectileSpeed: 250, projectileSize: 10, projectileDamage: 15, projectileFireRate: 2000,
        };

        const RAM_SOCKET_STATS = {
            count: 4, size: 60, cleanseTime: 4000,
        };
        
        const BOSS_3_STATS = {
            size: 80,
            maxHealth: 15000,
            phase2HealthThreshold: 0.70,
            phase3HealthThreshold: 0.30,
            vulnerabilityDuration: 9000, 

            dataSmasherRate: 3600,
            dataSmasherRadius: 70,
            dataSmasherDamage: 30,
            dataSmasherWarnTime: 1500,
            corruptionWaveRate: 4000,
            corruptionWaveWidth: 130,
            corruptionWaveSpeed: 300,
            corruptionWaveDamage: 25,

            hostileTakeoverRate: 4500,
            busWarnTime: 2000,
            busFireDuration: 1000,
            busDamage: 30,
            phase2CorruptedPuddleRate: 5000,
            phase2CorruptedPuddleRadius: 110,
            phase2CorruptedPuddleDuration: 3000,
            phase2CorruptedPuddleDamage: 4,
            phase2CorruptedPuddleDamageInterval: 250,
            staticZoneRate: 6000,
            staticZoneCount: 7,
            staticZoneRadius: 100,
            staticZoneDuration: 5000,

            phase3BusOverloadRate: 3000,
            phase3VolatileMemoryRate: 4000,
            phase3VolatilePuddleDuration: 5000,
            phase3VolatilePuddleDamage: 10,
            phase3FinalJudgementRate: 6000,
            phase3AuraInitialRadius: 50,
            phase3AuraExpandRate: 10,
            phase3AuraDamage: 1.5,
            phase3AuraDamageTick: 250,
        };

        // --- CHEFE 4 (NOVO) ---
        const BOSS_4_STATS = {
            size: 90, maxHealth: 25000,
            subRouterCount: 4,
            subRouterHealth: 2000,
            dosWaveRate: 4500,
            dosWaveDamage: 30,
            phase2HealthThreshold: 0.65,
            portScanRate: 6000,
            portScanLaserCount: 3,
            portScanDamage: 25,
            packetFloodRate: 5000,
            quarantineRate: 8000,
            quarantineDamage: 20,
            phase3HealthThreshold: 0.30,
            arenaShrinkRate: 5,
            ghostBossSpawnRate: 12000,
        };

        const HEALTH_PICKUP_STATS = {
            size: 20, healAmount: 30, spawnIntervalMin: 20000, spawnIntervalMax: 30000, 
        };

        const ANTIVIRUS_SCAN_STATS = {
            fireRate: 1200, projectileSpeed: 300, damage: 10, projectileSize: 8,
            systemPurgeProjectilesPerShot: 3, systemPurgeSpreadAngle: 15 * (Math.PI / 180), systemPurgeDamageBonus: 15, systemPurgeSizeMultiplier: 1.2,
            hunterSwarmProjectileSpeed: 220, hunterSwarmDamage: 8, hunterSwarmSizeMultiplier: 1.1, hunterSwarmDotDamagePerTick: 3, hunterSwarmDotDuration: 3000, hunterSwarmDotTickInterval: 500, hunterSwarmSeekForce: 0.1, 
        };

        const FIREWALL_STATS = {
            initialOrbs: 1, radius: 80, angleSpeed: 0.125, orbSize: 18.5, damage: 9, hitCooldown: 500, 
            shardBaseDamage: 8, shardBaseFrequency: 3000, shardSpeed: 400, shardSize: 5, shardLifetime: 750, 
            aegisOrbSizeMultiplier: 1.8, aegisContactDamageBonus: 20, aegisPulseDamage: 10, aegisPulseRadius: 40, aegisPulseFrequency: 1500, aegisShardDamageBonus: 2,
        };
        
        const ACID_VIRUS_STATS = {
            cooldown: 2800,
            projectileSpeed: 350,
            projectileSize: 10,
            puddleRadius: 70,
            puddleDuration: 3000,
            puddleDamagePerTick: 4,
            puddleTickRate: 250,
            pandemicSporeChance: 0.75,
            pandemicSporeSpeed: 200,
            pandemicSporeSize: 8,
        };
        
        const DEFRAG_STATS = {
            cooldown: 1000,
            damage: 16,
            range: 75,
            arc: 110 * (Math.PI / 180),
            spinDamageMultiplier: 1.5,
            spinRangeMultiplier: 1.2,
            comboHitsForSpin: 3,
        };

        const DATA_LEECH_STATS = {
            damagePerTick: 3.5, tickRate: 100, range: 250,
            stillDamageMultiplierMax: 2.5, stillDamageRampUpTime: 2000,
            chainDamageMultiplier: 0.5,
            siphonHealChance: 0.10,
            siphonHealAmount: 3,
        };
        
        const SUB_PROCESS_MINION_STATS = {
            size: 14,
            speed: 180,
            baseHealth: 40,
            healthPerLevel: 5.5,
            baseDamage: 12,
            damagePerLevel: 2.25,
            conversionChance: 0.30,
            maxMinions: 4,
            orbitRadius: 45,
            commandSwitchCooldown: 500, 
            attackCooldown: 1000,
            damageTakenCooldown: 500,
        };

        const UI_BAR_HEIGHT = 88; 
        const INITIAL_EXP_TO_NEXT_LEVEL = 100;
        const EXP_LEVEL_MULTIPLIER = 1.175;
        const ENEMY_SPAWN_INITIAL_DELAY = 3000; 
        const ENEMY_SPAWN_MIN_INTERVAL = 300; 
        const ENEMY_SPAWN_INTERVAL_DECREMENT_FACTOR = 5; 
        const SYSTEM_CORES_PER_BOSS_DEFEAT = 1;
        const SYSTEM_CORES_PER_BOSS_2_DEFEAT = 3;
        const SYSTEM_CORES_PER_BOSS_3_DEFEAT = 5;
        const SYSTEM_CORES_PER_BOSS_4_DEFEAT = 10; // --- NOVO ---
        const DATA_VAULT_TRIGGER_TIME = 300;
        const DATA_VAULT_2_TRIGGER_TIME = 600;
        const DATA_VAULT_3_TRIGGER_TIME = 960;
        const DATA_VAULT_KILL_REQUIREMENT = 75;
        
        // --- START OF achievements.ts ---
        const ACHIEVEMENTS_CONFIG = [
            // --- Conquistas de Progressão (Fáceis) ---
            { id: 'survive_5_min', name: 'Primeiros Ciclos', description: 'Sobreviva por 5 minutos em uma única partida.', unlockHint: 'Sobreviva por 5 minutos.', icon: '⏱️', difficulty: 'Fácil', trigger: { type: 'session_event', event: 'survive_time', value: 300 }, reward: { type: 'permanent_buff', statAffected: 'expModifier', bonus: 0.01, rewardDescription: '+1% Ganho de XP' } },
            { id: 'reach_level_10', name: 'Otimização Inicial', description: 'Alcance o nível 10 em uma única partida.', unlockHint: 'Alcance o nível 10.', icon: '⭐', difficulty: 'Fácil', trigger: { type: 'session_event', event: 'reach_level', value: 10 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 5, rewardDescription: '+5 HP Máximo' } },
            { id: 'kill_1000_total', name: 'Limpador de Cache', description: 'Derrote 1.000 inimigos no total.', unlockHint: 'Derrote 1.000 inimigos no total.', icon: '🧹', difficulty: 'Fácil', trigger: { type: 'stat_tracker', stat: 'totalKills', value: 1000 }, reward: { type: 'permanent_buff', statAffected: 'speed', bonus: 2, rewardDescription: '+2 Velocidade' } },
            { id: 'evolve_first_weapon', name: 'Processo Aprimorado', description: 'Evolua uma arma pela primeira vez.', unlockHint: 'Evolua uma arma pela primeira vez.', icon: '🚀', difficulty: 'Fácil', trigger: { type: 'session_event', event: 'evolve_weapon' }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.01, rewardDescription: '-1% Recarga de Armas' } },
            { id: 'magnetic_attraction', name: 'Atração Magnética', description: 'Colete 5.000 orbes de experiência no total.', unlockHint: 'Colete 5.000 orbes de XP no total.', icon: '🧲', difficulty: 'Fácil', trigger: { type: 'stat_tracker', stat: 'totalXpOrbsCollected', value: 5000 }, reward: { type: 'permanent_buff', statAffected: 'xpMagnetRadius', bonus: 0.03, rewardDescription: '+3% Alcance de Coleta' } },
            { id: 'dash_master', name: 'Mestre do Dash', description: 'Use a habilidade de Dash 250 vezes no total.', unlockHint: 'Use o Dash 250 vezes no total.', icon: '↪️', difficulty: 'Fácil', trigger: { type: 'stat_tracker', stat: 'totalDashes', value: 250 }, reward: { type: 'permanent_buff', statAffected: 'dashCooldown', bonus: -0.05, rewardDescription: '-5% Recarga do Dash' } },

            // --- Conquistas de Dedicação (Médias) ---
            { id: 'defeat_boss_1', name: 'Guardião Neutralizado', description: 'Derrote o Guardião da Fase 1.', unlockHint: 'Derrote o Guardião da Fase 1.', icon: '🛡️', difficulty: 'Média', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'guardian' } }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.02, rewardDescription: '+2% Dano Global' } },
            { id: 'defeat_boss_2', name: 'Sincronia Quebrada', description: 'Derrote o Sincronizador (Chefe da Fase 2).', unlockHint: 'Derrote o Chefe da Fase 2.', icon: '👾', difficulty: 'Média', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'sincronizador' } }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 10, rewardDescription: '+10 HP Máximo' } },
            { id: 'kill_10000_total', name: 'Exterminador de Bugs', description: 'Derrote 10.000 inimigos no total.', unlockHint: 'Derrote 10.000 inimigos no total.', icon: '💥', difficulty: 'Média', trigger: { type: 'stat_tracker', stat: 'totalKills', value: 10000 }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.03, rewardDescription: '+3% Dano Global' } },
            { id: 'survive_11_min', name: 'Maratona de Dados', description: 'Sobreviva por 11 minutos (até o segundo chefe).', unlockHint: 'Sobreviva por 11 minutos.', icon: '🏃‍♂️', difficulty: 'Média', trigger: { type: 'session_event', event: 'survive_time', value: 660 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 10, rewardDescription: '+10 HP Máximo' } },
            { id: 'evolve_3_weapons_session', name: 'Arsenal Completo', description: 'Evolua 3 armas diferentes em uma única partida.', unlockHint: 'Evolua 3 armas em uma partida.', icon: '⚔️', difficulty: 'Média', trigger: { type: 'session_event', event: 'evolve_weapon_count', value: 3 }, reward: { type: 'permanent_buff', statAffected: 'expModifier', bonus: 0.03, rewardDescription: '+3% Ganho de XP' } },
            { id: 'unlock_technomancer', name: 'Tecnomante Online', description: 'Desbloqueie a classe Tecnomante.', unlockHint: 'Desbloqueie a classe Tecnomante.', icon: '🛠️', difficulty: 'Média', trigger: { type: 'stat_tracker', stat: 'classesUnlockedIncludes', value: 'class_technomancer' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.03, rewardDescription: '+3% Dano Global' } },
            { id: 'sentinel_survive_10_min', name: 'Fortaleza Impenetrável', description: 'Sobreviva por 10 minutos com a classe Sentinela.', unlockHint: 'Sobreviva 10 min como Sentinela.', icon: '🏰', difficulty: 'Média', trigger: { type: 'session_event', event: 'survive_time_as_class', value: 600, classId: 'class_sentinel' }, reward: { type: 'permanent_buff', statAffected: 'damageReduction', bonus: 0.01, rewardDescription: '+1% Resistência a Dano' } },
            { id: 'cleanse_20_libraries', name: 'Caçador de Bibliotecas', description: 'Limpe um total de 100 Bibliotecas Corrompidas em todas as suas partidas.', unlockHint: 'Limpe 100 Bibliotecas Corrompidas no total.', icon: '📚✨', difficulty: 'Média', trigger: { type: 'stat_tracker', stat: 'totalCorruptedLibrariesCleansed', value: 100 }, reward: { type: 'permanent_buff', statAffected: 'statusEffectDuration', bonus: 0.03, rewardDescription: '+3% Duração de Efeitos' } },

            // --- Conquistas de Habilidade (Difíceis) ---
            { id: 'defeat_boss_3', name: 'Árbitro Desativado', description: 'Derrote o Árbitro do Sistema (Chefe da Fase 3).', unlockHint: 'Derrote o Chefe da Fase 3.', icon: '⚖️', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'arbiter' } }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 15, rewardDescription: '+15 HP Máximo' } },
            { id: 'reach_infinite_mode', name: 'Loop Infinito', description: 'Entre no Modo Infinito após derrotar o Nexus da Colmeia.', unlockHint: 'Derrote o chefe final para entrar no Modo Infinito.', icon: '♾️', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'reached_infinite' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.05, rewardDescription: '+5% Dano Global' } },
            { id: 'survive_20_min', name: 'Lenda do Sistema', description: 'Sobreviva por 20 minutos em uma única partida.', unlockHint: 'Sobreviva por 20 minutos.', icon: '👑', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'survive_time', value: 1200 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 20, rewardDescription: '+20 HP Máximo' } },
            { id: 'unlock_all_classes', name: 'Coleção de Arquiteturas', description: 'Desbloqueie todas as Classes.', unlockHint: 'Desbloqueie todas as classes.', icon: '📚', difficulty: 'Difícil', trigger: { type: 'stat_tracker', stat: 'classesUnlocked', value: CLASS_DEFINITIONS.length }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.02, rewardDescription: '-2% Recarga de Armas' } },
            { id: 'perfect_sync', name: 'Mira Perfeita', description: 'Derrote o Sincronizador sem sofrer dano DURANTE a luta.', unlockHint: 'Derrote o Sincronizador sem dano.', icon: '🎯', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'defeat_boss_no_damage', params: { bossType: 'sincronizador' } }, reward: { type: 'permanent_buff', statAffected: 'speed', bonus: 10, rewardDescription: '+10 Velocidade' } },
            { id: 'reach_level_50', name: 'Nível Máximo', description: 'Alcance o nível 50 em uma única partida.', unlockHint: 'Alcance o nível 50.', icon: '💯', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'reach_level', value: 50 }, reward: { type: 'permanent_buff', statAffected: 'expModifier', bonus: 0.05, rewardDescription: '+5% Ganho de XP' } },
            { id: 'evolve_quantum_optimizer', name: 'Otimização Final', description: 'Evolua com sucesso a arma Desfragmentador para sua forma final "Otimizador Quântico".', unlockHint: 'Evolua o Desfragmentador para Otimizador Quântico.', icon: '💫', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'evolve_specific_weapon', value: 'evolution_defrag_quantum_optimizer' }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.02, rewardDescription: '-2% Recarga de Armas' } },
            { id: 'nightmare_survive_10_min', name: 'Resistência ao Pesadelo', description: 'Sobreviva por 10 minutos em uma única partida no Modo Pesadelo.', unlockHint: 'Sobreviva por 10 minutos no Modo Pesadelo.', icon: '😨', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'survive_time_in_nightmare', value: 600 }, reward: { type: 'permanent_buff', statAffected: 'damageReduction', bonus: 0.01, rewardDescription: '+1% Redução de Dano' } },
            { id: 'nightmare_defeat_boss_1', name: 'Guardião do Pesadelo', description: 'Derrote o Guardião da Fase 1 em uma partida no Modo Pesadelo.', unlockHint: 'Derrote o Guardião no Modo Pesadelo.', icon: '🛡️‍🔥', difficulty: 'Difícil', trigger: { type: 'session_event', event: 'defeat_boss_in_nightmare', params: { bossType: 'guardian' } }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.05, rewardDescription: '+5% Dano Global' } },
            { id: 'collect_10_corrupted_kernels', name: 'Colecionador Corrompido', description: 'Acumule um total de 10 Núcleos Corrompidos ao longo de todas as suas partidas.', unlockHint: 'Acumule 10 Núcleos Corrompidos no total.', icon: '💜', difficulty: 'Difícil', trigger: { type: 'stat_tracker', stat: 'totalCorruptedKernelsEarned', value: 10 }, reward: { type: 'permanent_buff', statAffected: 'initialRerolls', bonus: 1, rewardDescription: '+1 Reroll Inicial' } },

            // --- Conquistas Épicas (ALTERADAS E NOVAS) ---
            { id: 'defeat_boss_4', name: 'Mente Desconectada', description: 'Derrote o Nexus da Colmeia (Chefe da Fase 4).', unlockHint: 'Derrote o Chefe da Fase 4.', icon: '🧠', difficulty: 'Épica', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'hivemind_nexus' } }, reward: { type: 'permanent_buff', statAffected: 'critDamage', bonus: 0.20, rewardDescription: '+20% Dano Crítico' } },
            { id: 'nightmare_win', name: 'Conquistador do Pesadelo', description: 'Derrote o chefe final, o Nexus da Colmeia, em uma partida no Modo Pesadelo.', unlockHint: 'Derrote o Nexus da Colmeia no Modo Pesadelo.', icon: '😈', difficulty: 'Épica', trigger: { type: 'session_event', event: 'defeat_boss_in_nightmare', params: { bossType: 'hivemind_nexus' } }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 0.04, rewardDescription: '+4% HP Máximo' } },
            { id: 'win_one_weapon', name: 'Monocultura', description: 'Derrote o Nexus da Colmeia sem adquirir nenhuma arma adicional além da inicial da sua classe.', unlockHint: 'Vença o jogo (derrote o Nexus) usando apenas sua arma inicial.', icon: '☝️', difficulty: 'Épica', trigger: { type: 'session_event', event: 'win_with_one_weapon' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.08, rewardDescription: '+8% Dano Global' } },
            { id: 'unlock_all_evolutions', name: 'Perfeccionista', description: 'Realize com sucesso cada uma das evoluções de armas listadas no Guia de Evoluções pelo menos uma vez.', unlockHint: 'Desbloqueie todas as evoluções de armas do Guia.', icon: '🎓', difficulty: 'Épica', trigger: { type: 'stat_tracker', stat: 'allEvolutionsUnlocked' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.04, rewardDescription: '+4% Dano Global' } },
            { id: 'immovable_object', name: 'Torre Imóvel', description: 'Sobreviva por 4 minutos sem mover seu personagem.', unlockHint: 'Sobreviva por 4 min sem se mover.', icon: '🗼', difficulty: 'Épica', trigger: { type: 'session_event', event: 'survive_time_no_move', value: 240 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 20, rewardDescription: '+20 HP Máximo' } },
            { id: 'master_decompiler', name: 'Mestre Decompiler', description: 'Complete a análise (Tier 4) de todos os inimigos no Decompiler.', unlockHint: 'Complete o Decompiler.', icon: '🔬', difficulty: 'Épica', trigger: { type: 'stat_tracker', stat: 'decompiler_complete' }, reward: { type: 'permanent_buff', statAffected: 'initialRerolls', bonus: 1, rewardDescription: '+1 Reroll Inicial' } },
            { id: 'judgment_dodged', name: 'Julgamento Evitado', description: 'Derrote o Árbitro sem sofrer dano DURANTE a luta.', unlockHint: 'Derrote o Árbitro sem dano.', icon: '🔨', difficulty: 'Épica', trigger: { type: 'session_event', event: 'defeat_boss_no_damage', params: { bossType: 'arbiter' } }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.03, rewardDescription: '-3% Recarga de Armas' } },
            { id: 'complete_all_achievements', name: 'Mestre do Sistema', description: 'Complete todas as outras conquistas.', unlockHint: 'Desbloqueie todas as outras conquistas.', icon: '🌟', difficulty: 'Épica', trigger: { type: 'unlock_all' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.10, rewardDescription: '+10% Dano Global (Final)' } }
        ];
        // --- END OF achievements.ts ---

        const BESTIARY_DATA = [
            { name: "Bug Comum", type: EnemyType.DEFAULT, description: "Unidade básica de corrupção. Persegue o processo principal incansavelmente.", visual: { color: GAME_COLORS.ENEMY_DEFAULT, size: ENEMY_DEFAULT_STATS.size } },
            { name: "Memory Leak", type: EnemyType.MEMORY_LEAK, description: "Rasteja, deixando um rastro de dados corrompidos que causam dano.", visual: { color: GAME_COLORS.ENEMY_MEMORY_LEAK, size: ENEMY_MEMORY_LEAK_STATS.size } },
            { name: "Spyware", type: EnemyType.SPYWARE, description: "Fica invisível periodicamente para emboscar.", visual: { color: GAME_COLORS.ENEMY_SPYWARE, size: ENEMY_SPYWARE_STATS.size } },
            { name: "Trojan Horse", type: EnemyType.TROJAN_HORSE, description: "Resistente. Ao ser destruído, libera Malware Fragments perigosos.", visual: { color: GAME_COLORS.ENEMY_TROJAN, size: ENEMY_TROJAN_HORSE_STATS.size } },
            { name: "Malware Fragment", type: EnemyType.MALWARE_FRAGMENT, description: "Pequeno e rápido, um fragmento liberado por Trojans.", visual: { color: GAME_COLORS.ENEMY_DEFAULT, size: ENEMY_MALWARE_FRAGMENT_STATS.size } },
            { name: "Rootkit", type: EnemyType.ROOTKIT, description: "Inimigo de elite: rápido, resistente e causa dano massivo.", visual: { color: GAME_COLORS.ENEMY_ROOTKIT, size: ENEMY_ROOTKIT_STATS.size } },
            { name: "DDoS Bot", type: EnemyType.DDOS_BOT, description: "Aparece em enxames, sobrecarregando o sistema com números.", visual: { color: GAME_COLORS.ENEMY_DDOS_BOT, size: ENEMY_DDOS_BOT_STATS.size } },
            { name: "Glitch Minion", type: EnemyType.GLITCH_MINION, description: "Fragmento instável invocado pelo Guardião. Rápido e errático.", visual: { color: GAME_COLORS.ENEMY_GLITCH_MINION, size: GLITCH_MINION_STATS.size } },
            { name: "[Fase 2] Processo Corrompido", type: EnemyType.PROCESSO_CORROMPIDO, description: "Uma ameaça angular e veloz que habita as partições mais profundas do sistema.", visual: { color: GAME_COLORS.ENEMY_PROCESSO_CORROMPIDO, size: ENEMY_PROCESSO_CORROMPIDO_STATS.size } },
            { name: "[Fase 2] Ponteiro Nulo", type: EnemyType.PONTEIRO_NULO, description: "Desaparece e reaparece em locais inesperados, atacando de surpresa.", visual: { color: GAME_COLORS.ENEMY_PONTEIRO_NULO, size: ENEMY_PONTEIRO_NULO_STATS.size } },
            { name: "[Fase 2] Segmento de Falha", type: EnemyType.SEGMENTO_FALHA, description: "Extremamente resistente, ativa um escudo que nega a maior parte do dano recebido.", visual: { color: GAME_COLORS.ENEMY_SEGMENTO_FALHA, size: ENEMY_SEGMENTO_FALHA_STATS.size } },
            { name: "[Fase 2] Processo Zumbi", type: EnemyType.PROCESSO_ZUMBI, description: "Lento e durável. Possui uma chance de se reanimar com metade da vida após ser destruído.", visual: { color: GAME_COLORS.ENEMY_PROCESSO_ZUMBI, size: ENEMY_PROCESSO_ZUMBI_STATS.size } },
            { name: "[Fase 3] Nanite de Reparo", type: EnemyType.NANITE, description: "Move-se em um padrão ondulado imprevisível, difícil de atingir.", visual: { color: GAME_COLORS.ENEMY_NANITE, size: ENEMY_NANITE_STATS.size } },
            { name: "[Fase 3] Dissipador de Calor", type: EnemyType.HEATSINK, description: "Lento e resistente. Emite pulsos de calor que destroem projéteis próximos.", visual: { color: GAME_COLORS.ENEMY_HEATSINK, size: ENEMY_HEATSINK_STATS.size } },
            { name: "[Fase 3] Controlador I/O", type: EnemyType.IO_CONTROLLER, description: "Dispara uma rajada de projéteis em cone, controlando o fluxo de dados.", visual: { color: GAME_COLORS.ENEMY_IO_CONTROLLER, size: ENEMY_IO_CONTROLLER_STATS.size } },
            { name: "[Fase 3] Processo Volátil", type: EnemyType.VOLATILE_PROCESS, description: "Persegue o jogador e se autodestrói em uma grande explosão após um curto período.", visual: { color: GAME_COLORS.ENEMY_VOLATILE_PROCESS, size: ENEMY_VOLATILE_PROCESS_STATS.size } },
            // --- FASE 4 (NOVO) ---
            { name: "[Fase 4] Processo Recursivo", type: EnemyType.RECURSIVE_PROCESS, description: "Processo estável que, ao ser destruído, se divide em duas instâncias filhas, mais rápidas.", visual: { color: GAME_COLORS.ENEMY_RECURSIVE_PROCESS, size: ENEMY_RECURSIVE_PROCESS_STATS.size } },
            { name: "[Fase 4] Processo Filho", type: EnemyType.CHILD_PROCESS, description: "Instância instável e rápida, gerada pela destruição de um Processo Recursivo.", visual: { color: GAME_COLORS.ENEMY_CHILD_PROCESS, size: ENEMY_CHILD_PROCESS_STATS.size } },
            { name: "[Fase 4] Firewall Desonesto", type: EnemyType.ROGUE_FIREWALL, description: "Lento e resistente, bloqueia projéteis do jogador com sua própria vida.", visual: { color: GAME_COLORS.ENEMY_ROGUE_FIREWALL, size: ENEMY_ROGUE_FIREWALL_STATS.size } },
            { name: "[Fase 4] Pico de Latência", type: EnemyType.LATENCY_SPIKE, description: "Não ataca, mas projeta uma grande aura de lentidão ao seu redor.", visual: { color: GAME_COLORS.ENEMY_LATENCY_SPIKE, size: ENEMY_LATENCY_SPIKE_STATS.size } },
            { name: "[Fase 4] Anomalia de Protocolo", type: EnemyType.PROTOCOL_ANOMALY, description: "Alterna entre um modo lento e resistente e um modo rápido que dispara projéteis.", visual: { color: GAME_COLORS.ENEMY_PROTOCOL_ANOMALY, size: ENEMY_PROTOCOL_ANOMALY_STATS.size } },
        ];

        // --- TALENT TREE CONFIG ---
        const TALENT_TREE_CONFIG = [
            // --- NÓS CENTRAIS (LINHA 1) ---
            { id: 'core_defense_unlock', title: 'Protocolos Defensivos', icon: '🛡️', description: 'Desbloqueia o ramo de Defesa.', maxLevel: 1, costPerLevel: [1], x: 20, y: 5, branch: 'defense' },
            { id: 'core_offense_unlock', title: 'Protocolos Ofensivos', icon: '💥', description: 'Desbloqueia o ramo de Ofensa.', maxLevel: 1, costPerLevel: [1], x: 50, y: 5, branch: 'offense' },
            { id: 'core_utility_unlock', title: 'Protocolos de Utilidade', icon: '⚙️', description: 'Desbloqueia o ramo de Utilidade.', maxLevel: 1, costPerLevel: [1], x: 80, y: 5, branch: 'utility' },

            // --- RAMO DE DEFESA ---
            { id: 'perm_hp_boost', title: 'Integridade do Casco', icon: '❤️', description: (level) => `+${level * 12} HP máximo inicial.`, maxLevel: 5, costPerLevel: [1, 1, 2, 2, 3], statAffected: 'maxHealth', bonusPerLevel: 12, type: 'additive', requires: ['core_defense_unlock'], x: 10, y: 35, branch: 'defense' },
            { id: 'perm_damage_reduction', title: 'Blindagem de Nanocarbono', icon: '🧱', description: (level) => `+${(level * 1.2).toFixed(1)}% de Redução de Dano.`, maxLevel: 5, costPerLevel: [2, 2, 3, 3, 4], statAffected: 'damageReduction', bonusPerLevel: 0.012, type: 'multiplicative_add', requires: ['core_defense_unlock'], x: 30, y: 35, branch: 'defense' },
            { id: 'perm_regen', title: 'Reparo Automático', icon: '💉', description: (level) => `Regenera +${(level * 0.25).toFixed(2)} HP por segundo.`, maxLevel: 5, costPerLevel: [3, 3, 4, 4, 5], statAffected: 'regenAmount', bonusPerLevel: 0.25, type: 'additive', requires: ['perm_hp_boost', 'perm_damage_reduction'], x: 20, y: 65, branch: 'defense' },
            { id: 'perm_dash_invuln', title: 'Matriz de Fase', icon: '👻', description: (level) => `Aumenta a duração da invencibilidade do Dash em ${level * 10}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'dashDuration', bonusPerLevel: 0.10, type: 'multiplicative_add', requires: ['perm_regen'], x: 10, y: 95, branch: 'defense' },
            { id: 'perm_last_stand', title: 'Último Recurso', icon: '💫', description: (level) => `Ao receber dano fatal, sobrevive com 1 HP e fica invencível por ${1 + level * 0.6}s. (1x por partida)`, maxLevel: 3, costPerLevel: [5, 6, 7], statAffected: 'lastStandCharges', bonusPerLevel: 1, type: 'additive', requires: ['perm_regen'], x: 30, y: 95, branch: 'defense' },
            { id: 'capstone_defense', title: 'Protocolo de Redundância', icon: '💾', description: 'Aumenta permanentemente a Redução de Dano em +5% e a Regeneração de HP em +1.5 HP/s.', maxLevel: 1, costPerLevel: [10], statAffected: 'redundancyProtocol', bonusPerLevel: 1, type: 'flag', requires: ['perm_dash_invuln', 'perm_last_stand'], x: 20, y: 125, branch: 'defense' },

            // --- RAMO DE OFENSA ---
            { id: 'perm_global_damage', title: 'Otimizador de Dano', icon: '🔥', description: (level) => `Aumenta todo o dano em ${(level * 2.5).toFixed(1)}%.`, maxLevel: 5, costPerLevel: [1, 2, 2, 3, 3], statAffected: 'globalDamageFactor', bonusPerLevel: 0.025, type: 'multiplicative_add', requires: ['core_offense_unlock'], x: 50, y: 35, branch: 'offense' },
            { id: 'perm_cooldown_modifier', title: 'Redutor de Latência', icon: '⚡', description: (level) => `Reduz recarga de armas em ${(level * 1.8).toFixed(1)}%.`, maxLevel: 4, costPerLevel: [2, 3, 4, 5], statAffected: 'cooldownModifier', bonusPerLevel: 0.018, type: 'multiplicative_subtract', requires: ['perm_global_damage'], x: 40, y: 65, branch: 'offense' },
            { id: 'perm_projectile_speed', title: 'Acelerador Magnético', icon: '➡️', description: (level) => `Aumenta a velocidade dos projéteis em ${level * 6}%.`, maxLevel: 4, costPerLevel: [2, 3, 3, 4], statAffected: 'projectileSpeed', bonusPerLevel: 0.06, type: 'multiplicative_add', requires: ['perm_global_damage'], x: 60, y: 65, branch: 'offense' },
            { id: 'perm_crit_chance', title: 'Análise Preditiva', icon: '🎯', description: (level) => `Ganha +${(level * 1.5).toFixed(1)}% de Chance de Acerto Crítico.`, maxLevel: 5, costPerLevel: [3, 4, 5, 6, 7], statAffected: 'critChance', bonusPerLevel: 0.015, type: 'additive', requires: ['perm_cooldown_modifier', 'perm_projectile_speed'], x: 50, y: 95, branch: 'offense' },
            { id: 'capstone_offense', title: 'Aniquilação', icon: '💣', description: (level) => `Aumenta o Dano Crítico em 60% e acertos críticos causam uma pequena explosão.`, maxLevel: 1, costPerLevel: [10], statAffected: 'critDamage', bonusPerLevel: 0.6, type: 'additive', requires: ['perm_crit_chance'], x: 50, y: 125, branch: 'offense' },

            // --- RAMO DE UTILIDADE ---
            { id: 'perm_xp_modifier', title: 'Compressão de Dados', icon: '✨', description: (level) => `Aumenta ganho de XP em ${level * 4}%.`, maxLevel: 5, costPerLevel: [1, 1, 2, 2, 3], statAffected: 'expModifier', bonusPerLevel: 0.04, type: 'multiplicative_add', requires: ['core_utility_unlock'], x: 70, y: 35, branch: 'utility' },
            { id: 'perm_speed_boost', title: 'Otimização de Clock', icon: '🏃', description: (level) => `Aumenta velocidade de movimento em ${(level * 2.5).toFixed(1)}%.`, maxLevel: 5, costPerLevel: [1, 2, 2, 3, 3], statAffected: 'speed', bonusPerLevel: 0.025, type: 'multiplicative_add', requires: ['core_utility_unlock'], x: 90, y: 35, branch: 'utility' },
            { id: 'perm_magnet_radius', title: 'Campo de Atração', icon: '🧲', description: (level) => `Aumenta o alcance de coleta em ${level * 10}%.`, maxLevel: 5, costPerLevel: [2, 2, 3, 3, 4], statAffected: 'xpMagnetRadius', bonusPerLevel: 0.10, type: 'multiplicative_add', requires: ['perm_xp_modifier', 'perm_speed_boost'], x: 80, y: 65, branch: 'utility' },
            { id: 'perm_rerolls', title: 'Algoritmo de Sorte', icon: '🎲', description: (level) => `Começa cada partida com +${level} Reroll.`, maxLevel: 3, costPerLevel: [4, 5, 6], statAffected: 'initialRerolls', bonusPerLevel: 1, type: 'additive', requires: ['perm_magnet_radius'], x: 70, y: 95, branch: 'utility' },
            { id: 'perm_status_effect_duration', title: 'Intensificador de Efeitos', icon: '🌀', description: (level) => `Aumenta a duração dos efeitos de status em ${level * 6}%.`, maxLevel: 4, costPerLevel: [3, 4, 4, 5], statAffected: 'statusEffectDuration', bonusPerLevel: 0.06, type: 'multiplicative_add', requires: ['perm_magnet_radius'], x: 90, y: 95, branch: 'utility' },
            { id: 'capstone_utility', title: 'Processamento Paralelo', icon: '♻️', description: 'Ao subir de nível, tem 25% de chance de receber uma opção de upgrade adicional.', maxLevel: 1, costPerLevel: [10], statAffected: 'extraUpgradeChoice', bonusPerLevel: 0.25, type: 'flag', requires: ['perm_rerolls', 'perm_status_effect_duration'], x: 80, y: 125, branch: 'utility' },
            
            // --- TALENTO SUPREMO ---
            { id: 'perm_ultimate_synergy', title: 'Sinergia do Kernel', icon: '🌟', description: 'Desbloqueia o poder total do núcleo. Aumenta todos os danos, HP e velocidade em 8%.', maxLevel: 1, costPerLevel: [20], statAffected: 'ultimate', bonusPerLevel: 0.08, type: 'multiplicative_add', requires: ['capstone_defense', 'capstone_offense', 'capstone_utility'], x: 50, y: 155, branch: 'ultimate' },

            // --- NOVO NÓ CENTRAL CORROMPIDO ---
            { id: 'corrupted_core_unlock', title: 'Kernel Corrompido', icon: '💠', description: 'Absorve a corrupção para desbloquear poderes proibidos e a parte final da árvore.', maxLevel: 1, costPerLevel: [1], requires: ['perm_ultimate_synergy'], x: 50, y: 190, branch: 'corrupted_ultimate', isCorrupted: true },

            // --- RAMO CORROMPIDO DE DEFESA ---
            { id: 'corr_hp_multiplier', title: 'Redundância de Casco', icon: '❤️‍🩹', description: (level) => `Aumenta a eficácia de TODOS os bônus de HP Máximo em +${10 * level}%.`, maxLevel: 3, costPerLevel: [2, 3, 4], statAffected: 'hpBonusMultiplier', bonusPerLevel: 0.10, type: 'additive', requires: ['corrupted_core_unlock'], x: 20, y: 220, branch: 'corrupted_defense', isCorrupted: true },
            { id: 'corr_dot_reduction', title: 'Matriz Defletora', icon: '🛡️', description: (level) => `Sua Redução de Dano agora também se aplica a ${15 + 10 * level}% do dano contínuo (DoT).`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'dotDamageReduction', bonusPerLevel: 0.10, type: 'additive', requires: ['corr_hp_multiplier'], x: 10, y: 250, branch: 'corrupted_defense', isCorrupted: true },
            { 
                id: 'corr_dash_improvement', 
                title: 'Imaterialidade Aprimorada', 
                description: (level) => `Reduz a recarga do Dash em 10% e aumenta a invencibilidade em +5% por nível. (Total: -${level * 10}%, +${level * 5}%)`, 
                maxLevel: 3, 
                costPerLevel: [4, 5, 6], 
                statAffected: 'dashCooldownAndDuration', 
                bonusPerLevel: { cooldown: 0.10, duration: 0.05 }, 
                requires: ['corr_hp_multiplier'], 
                x: 30, y: 250, branch: 'corrupted_defense', isCorrupted: true 
            },
            { id: 'corr_capstone_defense', title: 'Vontade Inquebrável', icon: '💎', description: 'Seu "Último Recurso" agora deixa você com 25% da vida máxima. A invencibilidade também dobra sua velocidade.', maxLevel: 1, costPerLevel: [10], statAffected: 'lastStandUpgrade', bonusPerLevel: 1, type: 'flag', requires: ['corr_dot_reduction', 'corr_dash_improvement'], x: 20, y: 280, branch: 'corrupted_defense', isCorrupted: true },

            // --- RAMO CORROMPIDO DE OFENSA ---
            { id: 'corr_base_damage', title: 'Saturação de Dano', icon: '💥', description: (level) => `Aumenta o dano base de todas as suas armas em +${8 * level}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'baseDamage', bonusPerLevel: 0.08, type: 'multiplicative_add', requires: ['corrupted_core_unlock'], x: 50, y: 220, branch: 'corrupted_offense', isCorrupted: true },
            { id: 'corr_projectile_mastery', title: 'Aceleração de Projéteis', icon: '🚀', description: (level) => `Aumenta a velocidade e o alcance de todos os projéteis em +${10 * level}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'projectileRange', bonusPerLevel: 0.10, type: 'multiplicative_add', requires: ['corr_base_damage'], x: 40, y: 250, branch: 'corrupted_offense', isCorrupted: true },
            { id: 'corr_crit_damage', title: 'Análise de Vulnerabilidade', icon: '🎯', description: (level) => `Bônus de Dano Crítico aumentado em +${25 * level}%.`, maxLevel: 3, costPerLevel: [4, 5, 6], statAffected: 'critDamage', bonusPerLevel: 0.25, type: 'additive', requires: ['corr_base_damage'], x: 60, y: 250, branch: 'corrupted_offense', isCorrupted: true },
            { id: 'corr_capstone_offense', title: 'Fúria Infinita', icon: '🔥', description: 'A cada 150 inimigos derrotados na partida, ganhe +1% de Dano e Vel. de Ataque (acumulativo, reseta no fim da partida).', maxLevel: 1, costPerLevel: [12], statAffected: 'infiniteFury', bonusPerLevel: 1, type: 'flag', requires: ['corr_projectile_mastery', 'corr_crit_damage'], x: 50, y: 280, branch: 'corrupted_offense', isCorrupted: true },

            // --- RAMO CORROMPIDO DE UTILIDADE ---
            { id: 'corr_magnet_radius', title: 'Coleta Magnética Superior', icon: '🧲', description: (level) => `Aumenta permanentemente o seu raio de coleta de orbes em +${15 + level * 5}%.`, maxLevel: 3, costPerLevel: [2, 3, 4], statAffected: 'xpMagnetRadius', bonusPerLevel: 0.15, requires: ['corrupted_core_unlock'], x: 80, y: 220, branch: 'corrupted_utility', isCorrupted: true },
            { id: 'corr_status_duration', title: 'Persistência de Efeitos', icon: '⏳', description: (level) => `Aumenta a duração de todos os efeitos de status que você aplica em +${20 * level}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'statusEffectDuration', bonusPerLevel: 0.20, type: 'multiplicative_add', requires: ['corr_magnet_radius'], x: 70, y: 250, branch: 'corrupted_utility', isCorrupted: true },
            { id: 'corr_exp_boost', title: 'Eficiência de Cache', icon: '✨', description: (level) => `Aumenta o ganho de experiência de todas as fontes em +${5 * level}%.`, maxLevel: 3, costPerLevel: [4, 5, 6], statAffected: 'expModifier', bonusPerLevel: 0.05, type: 'multiplicative_add', requires: ['corr_magnet_radius'], x: 90, y: 250, branch: 'corrupted_utility', isCorrupted: true },
            { id: 'corr_capstone_utility', title: 'Reescrita de Protocolo', icon: '♻️', description: 'Ganha +1 Reroll inicial e uma opção de upgrade adicional a cada nível.', maxLevel: 1, costPerLevel: [15], statAffected: 'protocolRewrite', bonusPerLevel: 1, type: 'flag', requires: ['corr_status_duration', 'corr_exp_boost'], x: 80, y: 280, branch: 'corrupted_utility', isCorrupted: true },

            // --- CAPSTONE FINAL CORROMPIDO ---
            { id: 'corr_ultimate_singularity', title: 'Singularidade do Kernel', icon: '🌟', description: 'Domínio absoluto. Aumenta permanentemente todos os danos, HP e velocidade em +12%.', maxLevel: 1, costPerLevel: [20], statAffected: 'ultimateCorrupted', bonusPerLevel: 0.12, type: 'multiplicative_add', requires: ['corr_capstone_defense', 'corr_capstone_offense', 'corr_capstone_utility'], x: 50, y: 310, branch: 'corrupted_ultimate', isCorrupted: true },
        ];

        // --- START OF NEW MODIFIER DEFINITIONS ---
        const MODIFIER_DEFINITIONS = [
            // === BUFFS PARA O JOGADOR (CUSTAM PONTOS - valor negativo) ===
            { id: 'mod_buff_start_level', name: 'Inicialização Acelerada', command: 'init --boost', description: 'Comece a partida com +1 nível e um upgrade gratuito.', points: -3, effects: [{ stat: 'initialLevel', operation: 'add', value: 1 }, { stat: 'initialFreeUpgrades', operation: 'add', value: 1 }] },
            { id: 'mod_buff_regen', name: 'Protocolo de Nanoreparos', command: 'enable --autorepair', description: 'Concede +0.3 HP de regeneração passiva por segundo.', points: -4, effects: [{ stat: 'regenAmount', operation: 'add', value: 0.3 }] },
            { id: 'mod_buff_damage', name: 'Otimizador de Saída', command: 'set_dmg --amp 0.12', description: 'Aumenta todo o dano causado em +12%.', points: -5, effects: [{ stat: 'globalDamageFactor', operation: 'multiply', value: 1.12 }] },
            { id: 'mod_buff_speed', name: 'Overclock de Mobilidade', command: 'set_speed --factor 1.10', description: 'Aumenta a velocidade de movimento em +10%.', points: -3, effects: [{ stat: 'speed', operation: 'multiply', value: 1.10 }] },
            { id: 'mod_buff_health', name: 'Casco Reforçado', command: 'patch --integrity', description: 'Aumenta a vida máxima inicial em +20%.', points: -4, effects: [{ stat: 'maxHealth', operation: 'multiply', value: 1.20 }] },
            { id: 'mod_buff_crit', name: 'Análise de Fraqueza', command: 'load --crit_matrix', description: 'Aumenta a chance de acerto crítico em +8%.', points: -4, effects: [{ stat: 'critChance', operation: 'add', value: 0.08 }] },
            { id: 'mod_buff_xp', name: 'Dados Privilegiados', command: 'set_xp --mod 0.15', description: 'Ganha 15% a mais de experiência de todas as fontes.', points: -3, effects: [{ stat: 'expModifier', operation: 'add', value: 0.15 }] },
            { id: 'mod_buff_magnet', name: 'Campo de Atração', command: 'extend --magnet', description: 'Aumenta o raio de coleta de orbes em +35%.', points: -2, effects: [{ stat: 'xpMagnetRadius', operation: 'multiply', value: 1.35 }] },
            { id: 'mod_buff_reroll', name: 'Recursos Iniciais', command: 'grant --resources', description: 'Comece com +1 Reroll e +1 Opção de Upgrade a cada nível.', points: -2, effects: [{ stat: 'initialRerolls', operation: 'add', value: 1 }, { stat: 'extraUpgradeChoices', operation: 'add', value: 1 }] },
            { id: 'mod_buff_less_boss_hp', name: 'Ponto Fraco Exposto', command: 'scan --boss_vuln', description: 'Chefes têm 15% a menos de vida.', points: -4, effects: [{ stat: 'bossHealthMultiplier', operation: 'multiply', value: 0.85 }] },

            // === DEBUFFS PARA O JOGADOR (CONCEDEM PONTOS - valor positivo) ===
            { id: 'mod_debuff_enemy_speed', name: 'Processos Acelerados', command: 'threat_mod --speed 1.15', description: 'Todos os inimigos são 15% mais rápidos.', points: 4, effects: [{ stat: 'enemySpeedMultiplier', operation: 'multiply', value: 1.15 }] },
            { id: 'mod_debuff_enemy_hp', name: 'Blindagem Inimiga', command: 'threat_mod --hp 1.20', description: 'Todos os inimigos têm 20% a mais de vida.', points: 3, effects: [{ stat: 'enemyHealthMultiplier', operation: 'multiply', value: 1.20 }] },
            { id: 'mod_debuff_less_xp', name: 'Corrupção de Dados', command: 'filter_xp --level 0.85', description: 'Você ganha 15% a menos de experiência.', points: 3, effects: [{ stat: 'expModifier', operation: 'add', value: -0.15 }] },
            { id: 'mod_debuff_player_slow', name: 'Sistema Lento', command: 'throttle --self', description: 'Sua velocidade de movimento é reduzida em -10%.', points: 5, effects: [{ stat: 'speed', operation: 'multiply', value: 0.90 }] },
            { id: 'mod_debuff_less_health_pickups', name: 'Recursos Escassos', command: 'set_drops --rare', description: 'A chance de Orbes de Vida aparecerem é reduzida em 40%.', points: 2, effects: [{ stat: 'healthPickupSpawnRateMultiplier', operation: 'multiply', value: 0.60 }] },
            { id: 'mod_debuff_more_elites', name: 'Evolução Agressiva', command: 'promote --elites 0.10', description: 'Inimigos têm 10% de chance de se tornarem uma variante Elite (vida e dano dobrados).', points: 3, effects: [{ stat: 'eliteChance', operation: 'set', value: 0.10 }] },
            { id: 'mod_debuff_no_invincibility', name: 'Vulnerabilidade Exposta', command: 'patch --no_iframes', description: 'Remove os frames de invencibilidade após sofrer dano.', points: 5, effects: [{ stat: 'damageCooldown', operation: 'set', value: 50 }] },
            { id: 'mod_debuff_boss_rush', name: 'Confronto Direto', command: 'trigger --boss_rush', description: 'Os Chefes aparecem 60 segundos mais cedo.', points: 2, effects: [{ stat: 'bossTimerModifier', operation: 'add', value: -60 }] },
            { id: 'mod_debuff_enemy_damage', name: 'Armamento Aprimorado', command: 'threat_mod --dmg 1.20', description: 'Inimigos causam 20% a mais de dano.', points: 4, effects: [{ stat: 'enemyDamageMultiplier', operation: 'multiply', value: 1.20 }] },
            { id: 'mod_debuff_expensive_upgrades', name: 'Crise de Processamento', command: 'set_cost --high', description: 'Você precisa de 25% a mais de XP para subir de nível.', points: 4, effects: [{ stat: 'expToNextLevelMultiplier', operation: 'multiply', value: 1.25 }] },
        ];
        // --- END OF NEW MODIFIER DEFINITIONS ---

        const getEnemySpawnPosition = () => {
            const side = Math.floor(Math.random() * 4);
            let x = 0, y = 0;
            const padding = 30; 
            if (side === 0) { x = Math.random() * CANVAS_WIDTH; y = -padding; } 
            else if (side === 1) { x = CANVAS_WIDTH + padding; y = Math.random() * CANVAS_HEIGHT; } 
            else if (side === 2) { x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT + padding; } 
            else { x = -padding; y = Math.random() * CANVAS_HEIGHT; } 
            return { x, y };
        };

        const getRandomCanvasPosition = (padding = 50) => {
            return {
                x: padding + Math.random() * (CANVAS_WIDTH - padding * 2),
                y: padding + Math.random() * (CANVAS_HEIGHT - padding * 2),
            };
        };
        // --- END OF constants.ts ---

        // --- START OF utils/helpers.ts ---
        const formatTime = (totalSeconds) => {
            if (typeof totalSeconds !== 'number' || isNaN(totalSeconds)) totalSeconds = 0;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };

        const calculateDistance = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const dx = pos1.x - pos2.x;
            const dy = pos1.y - pos2.y;
            return Math.sqrt(dx * dx + dy * dy);
        };

        // >>> ADICIONE ESTA FUNÇÃO AQUI <<<
        const calculateDistanceSq = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const dx = pos1.x - pos2.x;
            const dy = pos1.y - pos2.y;
            return dx * dx + dy * dy; // A única mudança é remover Math.sqrt()
        };

        const normalizeVector = (pos) => {
            const magnitude = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
            if (magnitude === 0) return { x: 0, y: 0 };
            return { x: pos.x / magnitude, y: pos.y / magnitude };
        };
        // --- END OF utils/helpers.ts ---

        // --- START OF utils/ProfileManager.ts ---
        const PROFILE_KEY = 'os_survivors_user_profile';

        function getOrCreateProfile() {
            try {
                const storedProfile = localStorage.getItem(PROFILE_KEY);
                if (storedProfile) {
                    const parsedProfile = JSON.parse(storedProfile);
                    // Garante que o perfil tem todos os campos esperados
                    const defaultProfile = getNewProfileStructure();
                    return { ...defaultProfile, ...parsedProfile };
                }
            } catch (e) {
                console.error("Failed to parse user profile, creating a new one.", e);
            }
            
            const newProfile = getNewProfileStructure();
            saveProfile(newProfile);
            return newProfile;
        }

        function getNewProfileStructure() {
            return {
                userId: crypto.randomUUID(),
                username: `Processo_${Math.random().toString(16).substr(2, 4).toUpperCase()}`,
                bio: "Defendendo o Kernel, um processo de cada vez.",
                createdAt: new Date().toISOString(),
                equippedAvatarId: 'avatar_default',
                equippedTitleId: 'title_survivor',
                equippedBannerId: 'banner_grid',
                featuredAchievementIds: [],
                featuredStatKeys: [],
            };
        }

        function saveProfile(profile) {
            localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
        }
        // --- END OF utils/ProfileManager.ts ---

        // --- START OF game/upgrades.ts ---
                const UPGRADE_POOL = [
            // --- ARMAS NOVAS ---
            {
                id: 'weapon_antivirus', title: 'Instalar Antivírus', description: 'Dispara automaticamente no inimigo mais próximo.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'antivirus')) {
                        weapons.push({ id: 'antivirus', level: 1, lastShotTime: 0, isEvolved: false });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            {
                id: 'weapon_firewall', title: 'Instalar Firewall', description: 'Cria um escudo orbital que causa dano.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'firewall')) {
                        weapons.push({
                            id: 'firewall', level: 1, orbs: FIREWALL_STATS.initialOrbs, currentAngle: 0,
                            lastShardTimes: {}, orbHitCooldowns: {}, isEvolved: false
                        });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            {
                id: 'weapon_acid_virus', title: 'Instalar Vírus Ácido', description: 'Dispara um projétil que cria uma poça de dados corrosivos no impacto, causando dano contínuo aos inimigos.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'acid_virus')) {
                         weapons.push({ id: 'acid_virus', level: 1, lastShotTime: 0, isEvolved: false });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
             {
                id: 'weapon_defrag', title: 'Instalar Desfragmentador', description: 'Ataque em arco de curto alcance que atinge múltiplos alvos.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'defrag')) {
                         weapons.push({ id: 'defrag', level: 1, lastShotTime: 0, isEvolved: false, comboCounter: 0 });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
             {
                id: 'weapon_data_leech', title: 'Instalar Data Leech', description: 'Raio contínuo no inimigo mais próximo. Causa mais dano ao ficar parado.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'data_leech')) {
                         weapons.push({ 
                             id: 'data_leech', level: 1, lastTickTime: 0, targetId: null,
                             stillTime: 0, lastPlayerPos: {x: player.position.x, y: player.position.y},
                             isEvolved: false,
                             isCriticallySurging: false,
                             critSurgeEndTime: 0,
                             lastCritCheckTime: 0,
                        });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            // --- UPGRADES ANTIVIRUS ---
            {
                id: 'antivirus_rate', title: 'Antivírus: Overclock', description: 'Aumenta a cadência de tiro em 15%.',
                level: 0, maxLevel: 5, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w }) 
            },
            {
                id: 'antivirus_damage', title: 'Antivírus: DB Update', description: 'Aumenta o dano do projétil em 8.',
                level: 0, maxLevel: 5, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'antivirus_pierce', title: 'Antivírus: Heurística Penetrante', description: 'Projéteis atravessam +1 inimigo.',
                level: 0, maxLevel: 3, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'antivirus_cryo_rounds', title: 'Antivírus: Crio-Munição', 
                description: (level) => level < 4 
                    ? `Projéteis têm ${20 + level * 5}% de chance de aplicar LENTIDÃO.`
                    : `Projéteis agora têm 15% de chance de CONGELAR inimigos por ${STATUS_EFFECT_PARAMS[StatusEffectType.FREEZE].baseDuration / 1000}s.`,
                level: 0, maxLevel: 4, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w }) 
            },
            // --- UPGRADES FIREWALL ---
            {
                id: 'firewall_orbs', title: 'Firewall: Multi-Core', description: 'Adiciona +1 escudo orbital.',
                level: 0, maxLevel: 4, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (player, weapons) => {
                    const firewall = weapons.find(w => w.id === 'firewall');
                    if (firewall && firewall.orbs !== undefined) firewall.orbs++;
                    return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            {
                id: 'firewall_damage', title: 'Firewall: Heurística Avançada', description: 'Aumenta o dano do escudo em 8.',
                level: 0, maxLevel: 5, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'firewall_shards', title: 'Firewall: Fragmentos de Dados', description: 'Escudos disparam fragmentos (+dano/freq).',
                level: 0, maxLevel: 3, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
             {
                id: 'firewall_vulnerability_matrix', title: 'Firewall: Matriz de Vulnerabilidade', description: (level) => `Escudos aplicam VULNERABILIDADE por ${STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseDuration/1000}s (inimigos recebem +${Math.round(((STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseMagnitude + (level-1)*0.05)-1)*100)}% dano).`,
                level: 0, maxLevel: 3, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            // --- UPGRADES VÍRUS ÁCIDO ---
            {
                id: 'acid_virus_potency', title: 'Vírus Ácido: Potencializar Corrosão', description: 'Aumenta o dano da poça de ácido em 3 por tick.',
                level: 0, maxLevel: 5, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'acid_virus_spread', title: 'Vírus Ácido: Agente Expansivo', description: 'Aumenta a área de efeito da poça em 15%.',
                level: 0, maxLevel: 4, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'acid_virus_duration', title: 'Vírus Ácido: Estabilizador Químico', description: 'Aumenta a duração da poça de ácido em 1 segundo.',
                level: 0, maxLevel: 4, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'acid_virus_viscosity', title: 'Vírus Ácido: Aumento de Viscosidade', description: 'Inimigos dentro da poça têm sua velocidade de movimento reduzida (LENTIDÃO).',
                level: 0, maxLevel: 1, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            // --- UPGRADES DEFRAGMENTADOR ---
            {
                id: 'defrag_damage', title: 'Defrag: Otimizar Sincronia', description: 'Aumenta o dano do ataque em 12.',
                level: 0, maxLevel: 5, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'defrag_cooldown', title: 'Defrag: Acelerar Leitura', description: 'Reduz a recarga do ataque em 12%.',
                level: 0, maxLevel: 4, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'defrag_range', title: 'Defrag: Ampliar Setor', description: 'Aumenta o alcance de todos os ataques em 15%.',
                level: 0, maxLevel: 4, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'defrag_fragments', title: 'Defrag: Fragmentos Otimizados', description: 'O ataque giratório agora dispara 6 fragmentos perfurantes em todas as direções.',
                level: 0, maxLevel: 3, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
             // --- UPGRADES DATA LEECH ---
            {
                id: 'leech_damage', title: 'Data Leech: Aumentar Largura de Banda', description: 'Aumenta o dano base em 7.5 por segundo.',
                level: 0, maxLevel: 5, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'leech_range', title: 'Data Leech: Otimizar Conexão', description: 'Aumenta o alcance do raio em 20%.',
                level: 0, maxLevel: 4, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'leech_slow', title: 'Data Leech: Corromper Dados', description: 'Raio aplica LENTIDÃO no alvo primário.',
                level: 0, maxLevel: 1, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'leech_chain', title: 'Data Leech: Conexões Múltiplas', description: 'O raio atinge +1 alvo próximo com 50% do dano.',
                level: 0, maxLevel: 3, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            // --- UPGRADES PASSIVOS ---
            {
                id: 'player_speed', title: 'Otimização de Clock', description: 'Aumenta sua velocidade em 10%.',
                level: 0, maxLevel: 5, type: 'player_passive',
                apply: (player, weapons) => { player.speed *= 1.1; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_health', title: 'Partição de Backup', description: 'Aumenta sua vida máxima em 25.',
                level: 0, maxLevel: 5, type: 'player_passive',
                apply: (player, weapons) => { player.maxHealth += 25; player.health += 25; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_magnet', title: 'Coletor de Dados', description: 'Atrai experiência e vida de uma área maior.',
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { player.xpMagnetRadius += 50; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_exp_boost', title: 'Cache L3', description: 'Ganha 10% a mais de experiência.',
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { player.expModifier += 0.1; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_cooldown', title: 'Overclock Global', description: 'Reduz a recarga de todas as armas em 8%.',
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { player.cooldownModifier *= 0.92; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_regen', title: 'Núcleo Regenerativo', 
                description: (level) => `Regenera +${(level * 2.5).toFixed(1)} HP a cada 5 segundos.`,
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { 
                    player.regenAmount = (player.regenAmount || 0) + 0.5;
                    return { updatedPlayer: player, updatedWeapons: weapons }; 
                } 
            },
            {
                id: 'player_overdrive', title: 'Sistema de Sobrecarga', 
                description: (level) => `Abaixo de 25% HP: Invencibilidade e +${15 + level * 5}% Dano por 5s. (Cooldown: 30s)`,
                level: 0, maxLevel: 3, type: 'player_passive',
                apply: (player, weapons) => { return { updatedPlayer: player, updatedWeapons: weapons }; } 
            },
            {
                id: 'passive_fear_protocol', title: 'Protocolo de Pânico Induzido', description: (level) => `Ao receber dano, ${15 + level * 5}% de chance de causar MEDO em inimigos próximos por ${STATUS_EFFECT_PARAMS[StatusEffectType.FEAR].baseDuration/1000}s.`,
                level: 0, maxLevel: 3, type: 'player_passive',
                apply: (p,w) => ({updatedPlayer: p, updatedWeapons: w})
            }
        ];
        // --- END OF game/upgrades.ts ---

        // --- START OF game/evolutions.ts ---
        const WEAPON_EVOLUTIONS = [
            {
                evolutionId: "evolution_antivirus_system_purge",
                name: "System Purge Protocol",
                description: "Antivirus dispara uma devastadora rajada de 3 projéteis teleguiados com dano e tamanho aumentados.",
                baseWeaponId: "antivirus",
                requiredUpgradeIds: [
                    { id: "antivirus_damage", level: 5 },
                    { id: "antivirus_rate", level: 5 }
                ],
                catalystPassiveId: "player_cooldown",
                evolvedWeaponProperties: {
                    newId: "antivirus_system_purge",
                }
            },
            {
                evolutionId: "evolution_firewall_aegis_shield",
                name: "Aegis Shield",
                description: "Escudos do Firewall ficam maiores, causam mais dano de contato e pulsam uma onda de dano periodicamente. Fragmentos são aprimorados.",
                baseWeaponId: "firewall",
                requiredUpgradeIds: [
                    { id: "firewall_orbs", level: 4 },
                    { id: "firewall_damage", level: 5 }
                ],
                catalystPassiveId: "player_health",
                evolvedWeaponProperties: {
                    newId: "firewall_aegis_shield",
                }
            },
            {
                evolutionId: "evolution_acid_virus_pandemic",
                name: "Pandemia Corrosiva",
                description: "Poças de ácido aplicam VULNERABILIDADE. Inimigos derrotados dentro da poça explodem, lançando um esporo teleguiado que cria uma nova poça de ácido, espalhando a infecção.",
                baseWeaponId: "acid_virus",
                requiredUpgradeIds: [
                    { id: "acid_virus_potency", level: 5 },
                    { id: "acid_virus_spread", level: 4 },
                    { id: "acid_virus_duration", level: 4 },
                    { id: "acid_virus_viscosity", level: 1 }
                ],
                catalystPassiveId: "player_overdrive",
                evolvedWeaponProperties: {
                    newId: "acid_virus_pandemic",
                }
            },
            {
                evolutionId: "evolution_antivirus_hunter_swarm",
                name: "Hunter-Seeker Swarm",
                description: "Projéteis do Antivirus se tornam mísseis teleguiados mais lentos que aplicam dano contínuo (DoT).",
                baseWeaponId: "antivirus",
                requiredUpgradeIds: [
                    { id: "antivirus_pierce", level: 3 },
                    { id: "antivirus_damage", level: 5 } 
                ],
                catalystPassiveId: "player_magnet", 
                evolvedWeaponProperties: {
                    newId: "antivirus_hunter_swarm",
                }
            },
            {
                evolutionId: "evolution_antivirus_tesla_coil",
                name: "Antivirus: Protocolo Tesla",
                description: "Projéteis do Antivirus agora ricocheteiam entre inimigos próximos, causando dano elétrico em cadeia. Dano reduzido por salto.",
                baseWeaponId: "antivirus",
                requiredUpgradeIds: [
                    { id: "antivirus_cryo_rounds", level: 4 }, 
                    { id: "antivirus_rate", level: 5 }
                ],
                catalystPassiveId: "player_speed", 
                evolvedWeaponProperties: {
                    newId: "antivirus_tesla_coil",
                }
            },
            {
                evolutionId: "evolution_defrag_quantum_optimizer",
                name: "Otimizador Quântico",
                description: "O ciclo de combo é removido. TODOS os ataques são giros de 360° que disparam Fragmentos Otimizados. Cadência e dano aumentados.",
                baseWeaponId: "defrag",
                requiredUpgradeIds: [
                    { id: "defrag_damage", level: 5 },
                    { id: "defrag_range", level: 4 },
                    { id: "defrag_fragments", level: 3 }
                ],
                catalystPassiveId: "player_speed",
                evolvedWeaponProperties: {
                    newId: "defrag_quantum_optimizer",
                }
            },
            {
                evolutionId: "evolution_leech_siphon_chain",
                name: "Corrente de Sifão",
                description: "Aumenta o número de alvos em +4. Inimigos derrotados pelo raio têm 25% de chance de gerar um orbe que cura 5 HP.",
                baseWeaponId: "data_leech",
                requiredUpgradeIds: [
                    { id: "leech_chain", level: 3 },
                    { id: "leech_range", level: 4 }
                ],
                catalystPassiveId: "player_magnet",
                evolvedWeaponProperties: {
                    newId: "leech_siphon_chain",
                }
            }
        ];
        // --- END OF game/evolutions.ts ---

        // --- START OF hooks/useGameEngine.ts ---
const { useState: useGameEngineState, useCallback: useGameEngineCallback, useRef: useGameEngineRef, useEffect: useGameEngineEffect } = React;

const createPlayer = (permanentBuffs = {}, achievementBuffs = {}, selectedSkinId, modifierIds = []) => {
    // ESTA FUNÇÃO PERMANECE IDÊNTICA. Não precisa de Immer pois ela cria um objeto novo do zero.
    const selectedClass = CLASS_DEFINITIONS.find(c => c.id === permanentBuffs.selectedClassId) || CLASS_DEFINITIONS[0];

    let currentSpeed = PLAYER_INITIAL_STATS.baseSpeed;
    let currentMaxHealth = PLAYER_INITIAL_STATS.baseMaxHealth;
    let currentXpMagnetRadius = PLAYER_INITIAL_STATS.baseXpMagnetRadius;
    let currentExpModifier = PLAYER_INITIAL_STATS.baseExpModifier;
    let currentCooldownModifier = PLAYER_INITIAL_STATS.baseCooldownModifier;
    let currentGlobalDamageFactor = PLAYER_INITIAL_STATS.globalDamageFactor;
    let currentDamageReduction = PLAYER_INITIAL_STATS.baseDamageReduction;
    let currentCritChance = PLAYER_INITIAL_STATS.baseCritChance;
    let currentCritDamage = PLAYER_INITIAL_STATS.baseCritDamage;
    let dashCooldownModifier = 1.0;
    let currentRegenAmount = PLAYER_INITIAL_STATS.regenAmount;
    let currentStatusEffectDuration = PLAYER_INITIAL_STATS.statusEffectDuration;
    let currentProjectileSpeed = 1.0;
    let dashDurationModifier = 1.0;
    let lastStandCharges = 0;
    
    // New stats from corrupted tree
    let hpBonusMultiplier = 1.0;
    let dotDamageReduction = 0.0;
    let lastStandHealthPercent = 0.01; // Default to 1 HP (or 1%)
    let lastStandSpeedBoost = false;
    let baseDamageMultiplier = 1.0;
    let projectileRangeMultiplier = 1.0;
    let initialLevel = 1;
    let hasInitialFreeUpgrade = false;
    let extraUpgradeChoices = 0;
    let hasInfiniteFury = false;


    if (selectedClass.statModifiers) {
        currentSpeed += selectedClass.statModifiers.baseSpeed || 0;
        currentMaxHealth += selectedClass.statModifiers.baseMaxHealth || 0;
        currentXpMagnetRadius += selectedClass.statModifiers.baseXpMagnetRadius || 0;
        currentExpModifier += selectedClass.statModifiers.baseExpModifier || 0;
        currentGlobalDamageFactor += selectedClass.statModifiers.globalDamageFactor || 0;
    }
    
    const allTalents = TALENT_TREE_CONFIG;
    allTalents.forEach(talentConfig => {
        const purchasedLevel = permanentBuffs.shop[talentConfig.id] || 0;
        if (purchasedLevel > 0) {
            const totalBonus = talentConfig.bonusPerLevel * purchasedLevel;
            switch (talentConfig.statAffected) {
                case 'speed': currentSpeed *= (1 + totalBonus); break;
                case 'maxHealth': currentMaxHealth += totalBonus; break;
                case 'expModifier': currentExpModifier += totalBonus; break;
                case 'cooldownModifier': currentCooldownModifier -= totalBonus; break;
                case 'damageReduction': currentDamageReduction += totalBonus; break;
                case 'globalDamageFactor': currentGlobalDamageFactor += totalBonus; break;
                case 'regenAmount': currentRegenAmount += totalBonus; break;
                case 'statusEffectDuration': currentStatusEffectDuration += totalBonus; break;
                case 'projectileSpeed': currentProjectileSpeed += totalBonus; break;
                case 'critChance': currentCritChance += totalBonus; break;
                case 'critDamage': currentCritDamage += totalBonus; break;
                case 'dashDuration': dashDurationModifier += totalBonus; break;
                case 'xpMagnetRadius': currentXpMagnetRadius *= (1 + totalBonus); break;
                case 'lastStandCharges': lastStandCharges += totalBonus; break;
                case 'redundancyProtocol':
                    if (purchasedLevel > 0) {
                        currentDamageReduction += 0.05;
                        currentRegenAmount += 1.5;
                    }
                    break;
                case 'ultimate':
                    if (purchasedLevel > 0) {
                        currentMaxHealth *= (1 + totalBonus);
                        currentGlobalDamageFactor += totalBonus;
                        currentSpeed *= (1 + totalBonus);
                    }
                    break;
                // Corrupted Talents
                case 'hpBonusMultiplier': hpBonusMultiplier += totalBonus; break;
                case 'dotDamageReduction': dotDamageReduction = 0.15 + 0.10 * purchasedLevel; break;
                case 'dashCooldownAndDuration':
                    const dashTalent = allTalents.find(t => t.id === talentConfig.id);
                    if (dashTalent) {
                        dashCooldownModifier -= dashTalent.bonusPerLevel.cooldown * purchasedLevel;
                        dashDurationModifier += dashTalent.bonusPerLevel.duration * purchasedLevel;
                    }
                    break;
                case 'lastStandUpgrade': if(purchasedLevel > 0) { lastStandHealthPercent = 0.25; lastStandSpeedBoost = true; } break;
                case 'baseDamage': baseDamageMultiplier += totalBonus; break;
                case 'projectileRange': projectileRangeMultiplier += totalBonus; break;
                case 'protocolRewrite': if(purchasedLevel > 0) { extraUpgradeChoices += 1; } break;
                case 'infiniteFury': if(purchasedLevel > 0) hasInfiniteFury = true; break;
                case 'ultimateCorrupted':
                        if (purchasedLevel > 0) {
                        currentMaxHealth *= (1 + totalBonus);
                        currentGlobalDamageFactor += totalBonus;
                        currentSpeed *= (1 + totalBonus);
                    }
                    break;
            }
        }
    });

    Object.keys(achievementBuffs).forEach(stat => {
        const bonus = achievementBuffs[stat];
        switch (stat) {
            case 'speed': currentSpeed += bonus; break;
            case 'maxHealth': 
                if (stat === 'maxHealth' && bonus < 1) { // Handle percentage-based HP buffs
                        currentMaxHealth *= (1 + bonus);
                } else {
                    currentMaxHealth += bonus;
                }
                break;
            case 'expModifier': currentExpModifier += bonus; break;
            case 'cooldownModifier': currentCooldownModifier += bonus; break;
            case 'globalDamageFactor': currentGlobalDamageFactor += bonus; break;
            case 'damageReduction': currentDamageReduction += bonus; break;
            case 'xpMagnetRadius': currentXpMagnetRadius *= (1 + bonus); break;
            case 'dashCooldown': dashCooldownModifier -= bonus; break;
            case 'critDamage': currentCritDamage += bonus; break;
            case 'statusEffectDuration': currentStatusEffectDuration += bonus; break;
            case 'initialRerolls': extraUpgradeChoices += bonus; break;
        }
    });

    const activeModifiers = modifierIds.map(id => MODIFIER_DEFINITIONS.find(m => m.id === id)).filter(Boolean);

    activeModifiers.forEach(mod => {
        (mod.effects || []).forEach(effect => {
            switch(effect.stat) {
                case 'globalDamageFactor': if(effect.operation === 'multiply') currentGlobalDamageFactor *= effect.value; break;
                case 'maxHealth': if(effect.operation === 'multiply') currentMaxHealth *= effect.value; break;
                case 'speed': if(effect.operation === 'multiply') currentSpeed *= effect.value; break;
                case 'critChance': if(effect.operation === 'add') currentCritChance += effect.value; break;
                case 'regenAmount': if(effect.operation === 'add') currentRegenAmount += effect.value; break;
                case 'expModifier': if(effect.operation === 'add') currentExpModifier += effect.value; break;
                case 'xpMagnetRadius': if(effect.operation === 'multiply') currentXpMagnetRadius *= effect.value; break;
                case 'initialRerolls': if(effect.operation === 'add') extraUpgradeChoices += effect.value; break;
                case 'extraUpgradeChoices': if(effect.operation === 'add') extraUpgradeChoices += effect.value; break;
            }
        });
    });

    currentMaxHealth = Math.ceil(currentMaxHealth * hpBonusMultiplier);
    currentGlobalDamageFactor *= baseDamageMultiplier;
    currentProjectileSpeed *= projectileRangeMultiplier;
    
    currentCooldownModifier = Math.max(0.1, currentCooldownModifier);
    currentMaxHealth = Math.max(10, currentMaxHealth);
    currentSpeed = Math.max(50, currentSpeed);
    currentDamageReduction = Math.max(0, Math.min(0.9, currentDamageReduction));

    const activePassives = [];
    if (selectedClass.uniquePassive) {
        activePassives.push(selectedClass.uniquePassive.id);
    }
    
    const uniquePassiveData = {};
    if (selectedClass.id === 'class_technomancer') {
        uniquePassiveData.commandMode = 'ASSAULT';
        uniquePassiveData.lastCommandSwitch = 0;
    }

    return {
        id: `player-${Date.now()}`, classId: selectedClass.id, color: selectedClass.iconColor,
        skinId: selectedSkinId || 'skin_default',
        position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 }, velocity: { x: 0, y: 0 },
        size: PLAYER_INITIAL_STATS.size, speed: currentSpeed, maxHealth: currentMaxHealth, health: currentMaxHealth,
        damageReduction: currentDamageReduction,
        dotDamageReduction,
        regenAmount: currentRegenAmount,
        critChance: currentCritChance, critDamage: currentCritDamage,
        statusEffectDuration: currentStatusEffectDuration,
        projectileSpeedModifier: currentProjectileSpeed,
        projectileRangeModifier: projectileRangeMultiplier,
        lastHitTime: 0, weapons: [], xpMagnetRadius: currentXpMagnetRadius, expModifier: currentExpModifier,
        cooldownModifier: currentCooldownModifier, globalDamageFactor: currentGlobalDamageFactor,
        lastRegenTime: 0, overdriveActive: false, overdriveEndTime: 0, overdriveCooldownUntil: 0,
        overdriveDamageBonusFactor: 1, activeUniquePassiveIds: activePassives, uniquePassiveData,
        lastMoveDirection: { ...PLAYER_INITIAL_STATS.lastMoveDirection }, isDashing: false, dashEndTime: 0,
        dashCooldownUntil: 0, dashCooldownModifier: dashCooldownModifier, dashDirection: { x: 0, y: 0 }, temporaryBuffs: [],
        dashDurationModifier: dashDurationModifier,
        lastStandCharges: lastStandCharges, lastStandUsed: false,
        lastStandHealthPercent: lastStandHealthPercent,
        lastStandSpeedBoost: lastStandSpeedBoost,
        initialLevel, hasInitialFreeUpgrade,
        extraUpgradeChoices,
        hasInfiniteFury,
        furyStacks: 0,
        activeModifiers,
    };
};
    
const useGameEngine = (
    onGameOverCallback,
    onLevelUpCallback,
    isGameActive,
    onBossWarningStartCallback,
    onBossFightStartCallback,
    onStageClearCallback,
    permanentBuffs = {},
    achievementBuffs = {},
    decompilerBonuses = {},
    weaponMasteryStats = {}
) => {
    const sessionStatsRef = useGameEngineRef(null);

    const getInitialSessionStats = () => ({
        kills: Object.fromEntries(Object.values(EnemyType).map(type => [type, 0])),
        totalKills: 0,
        damageTaken: 0,
        damageDealtByWeapon: {},
        damageTakenDuringBoss: {},
        levelReached: 1,
        timeSurvived: 0,
        score: 0,
        evolvedWeapons: new Set(),
        defeatedBosses: new Set(),
        dataCachesCollectedInSession: 0,
        killsWhileBuffedInSession: 0,
        damageTakenInFirst5Minutes: 0,
        dashUsedInSession: false,
        reachedInfiniteMode: false,
        totalXpOrbsCollected: 0,
        totalDashes: 0,
        timeWithoutMoving: 0,
        lastMoveTime: 0,
        evolvedWeaponIds: new Set(),
        healthPickupsCollected: 0, 
        isNightmareMode: false,
        weaponsAcquiredCount: 0,
        corruptedLibrariesCleansed: 0,
        corruptedKernelsEarnedInSession: 0,
        furyKillCounter: 0,
    });

    const [gameState, setGameState] = useImmerState(() => {
        const initialPlayer = createPlayer(permanentBuffs, achievementBuffs, permanentBuffs.selectedSkinId);
        return {
            player: initialPlayer,
            enemies: [], projectiles: [], particles: [], expOrbs: [], healthPickups: [], corruptedZones: [],
            acidPuddles: [], 
            revivingProcesses: [], dataWalls: [], laserBeams: [],
            interactables: [], alliedMinions: [],
            knowledgeOrbs: [],
            unstableSectors: [],
            ramSockets: [],
            bossAttacks: [],
            score: 0, experience: 0, level: initialPlayer.initialLevel, expToNextLevel: INITIAL_EXP_TO_NEXT_LEVEL,
            gameTime: 0, isPaused: false, keys: { w: false, a: false, s: false, d: false, ' ': false }, 
            nextEnemySpawnTime: Date.now() + ENEMY_SPAWN_INITIAL_DELAY,
            nextHealthPickupSpawnTime: Date.now() + HEALTH_PICKUP_STATS.spawnIntervalMin + Math.random() * (HEALTH_PICKUP_STATS.spawnIntervalMax - HEALTH_PICKUP_STATS.spawnIntervalMin),
            nextInteractableSpawnTime: Date.now() + INTERACTABLE_STATS.SPAWN_INTERVAL_MIN,
            nextUnstableSectorTime: 0,
            boss: null,
            bossShieldNodes: [],
            isBossEventTriggered: false,
            stage: 1, 
            isInfiniteMode: false,
            isNightmareMode: false,
            eventActive: null,
            eventKillCounter: 0,
            eventKillsSoFar: 0,
            dataVault: null,
        };
    });
    const ownedUpgradesRef = useGameEngineRef(new Map()); 

    const resetGame = useAppCallback((newPermanentBuffs, newAchievementBuffs, newSelectedSkinId, isNightmare, modifierIds = []) => {
        setGameState(draft => {
            const initialPlayer = createPlayer(newPermanentBuffs, newAchievementBuffs, newSelectedSkinId, modifierIds);
            ownedUpgradesRef.current.clear();
            sessionStatsRef.current = getInitialSessionStats();
            sessionStatsRef.current.isNightmareMode = isNightmare;
            sessionStatsRef.current.lastMoveTime = Date.now();
            skinStateCache = {};

            const selectedClassDef = CLASS_DEFINITIONS.find(c => c.id === newPermanentBuffs.selectedClassId) || CLASS_DEFINITIONS[0];
            const startingWeaponId = selectedClassDef.startingWeaponId;
            let initialWeapons = [];

            if(startingWeaponId){
                const startingWeaponUpgradeId = `weapon_${startingWeaponId}`;
                const startingWeaponUpgrade = UPGRADE_POOL.find(u => u.id === startingWeaponUpgradeId);
                if (startingWeaponUpgrade && startingWeaponUpgrade.type === 'weapon_new') {
                    const tempDraftState = { player: { ...initialPlayer }, weapons: [] };
                    startingWeaponUpgrade.apply(tempDraftState.player, tempDraftState.weapons);
                    initialWeapons = tempDraftState.weapons.map(w => ({...w, level: 1})); 
                    ownedUpgradesRef.current.set(startingWeaponUpgrade.id, 1);
                    sessionStatsRef.current.weaponsAcquiredCount = 1;
                }
            }
            
            const gameModifiers = {
                enemyHealthMultiplier: 1.0, enemySpeedMultiplier: 1.0, enemyDamageMultiplier: 1.0,
                bossHealthMultiplier: 1.0, healthPickupSpawnRateMultiplier: 1.0,
                expToNextLevelMultiplier: 1.0, bossTimerModifier: 0, eliteChance: 0
            };
            
            const activeModifiersOnReset = modifierIds.map(id => MODIFIER_DEFINITIONS.find(m => m.id === id)).filter(Boolean);
            
            activeModifiersOnReset.forEach(mod => {
                (mod.effects || []).forEach(effect => {
                    switch(effect.stat) {
                        case 'enemyHealthMultiplier': gameModifiers.enemyHealthMultiplier *= effect.value; break;
                        case 'enemySpeedMultiplier': gameModifiers.enemySpeedMultiplier *= effect.value; break;
                        case 'enemyDamageMultiplier': gameModifiers.enemyDamageMultiplier *= effect.value; break;
                        case 'bossHealthMultiplier': gameModifiers.bossHealthMultiplier *= effect.value; break;
                        case 'healthPickupSpawnRateMultiplier': gameModifiers.healthPickupSpawnRateMultiplier *= effect.value; break;
                        case 'expToNextLevelMultiplier': gameModifiers.expToNextLevelMultiplier *= effect.value; break;
                        case 'bossTimerModifier': gameModifiers.bossTimerModifier += effect.value; break;
                        case 'eliteChance': gameModifiers.eliteChance = effect.value; break;
                    }
                });
            });
            
            const startLevelMod = activeModifiersOnReset.find(m => m.effects.some(e => e.stat === 'initialLevel'));
            if (startLevelMod) {
                const levelEffect = startLevelMod.effects.find(e => e.stat === 'initialLevel');
                if (levelEffect.operation === 'add') initialPlayer.initialLevel += levelEffect.value;
            }
            const freeUpgradeMod = activeModifiersOnReset.find(m => m.effects.some(e => e.stat === 'initialFreeUpgrades'));
            if (freeUpgradeMod) {
                initialPlayer.hasInitialFreeUpgrade = true; 
            }

            Object.assign(draft, {
                player: {...initialPlayer, weapons: initialWeapons},
                enemies: [], projectiles: [], particles: [], expOrbs: [], healthPickups: [], corruptedZones: [],
                acidPuddles: [],
                revivingProcesses: [], dataWalls: [], laserBeams: [], interactables: [], alliedMinions: [],
                knowledgeOrbs: [], unstableSectors: [], ramSockets: [], bossAttacks: [],
                score: 0, experience: 0, level: initialPlayer.initialLevel,                     
                expToNextLevel: Math.floor(INITIAL_EXP_TO_NEXT_LEVEL * Math.pow(EXP_LEVEL_MULTIPLIER * gameModifiers.expToNextLevelMultiplier, initialPlayer.initialLevel - 1)),
                gameModifiers,
                gameTime: 0, isPaused: false, keys: { w: false, a: false, s: false, d: false, ' ': false },
                nextEnemySpawnTime: Date.now() + ENEMY_SPAWN_INITIAL_DELAY,
                nextHealthPickupSpawnTime: Date.now() + HEALTH_PICKUP_STATS.spawnIntervalMin + Math.random() * (HEALTH_PICKUP_STATS.spawnIntervalMax - HEALTH_PICKUP_STATS.spawnIntervalMin),
                nextInteractableSpawnTime: Date.now() + INTERACTABLE_STATS.SPAWN_INTERVAL_MIN + Math.random() * (INTERACTABLE_STATS.SPAWN_INTERVAL_MAX - INTERACTABLE_STATS.SPAWN_INTERVAL_MIN),
                nextUnstableSectorTime: Date.now() + 8000,
                boss: null,
                bossShieldNodes: [],
                isBossEventTriggered: false,
                stage: 1,
                isInfiniteMode: false,
                isNightmareMode: isNightmare,
                eventActive: null,
                eventKillCounter: 0,
                eventKillsSoFar: 0,
                dataVault: null,
            });

            if (initialPlayer.hasInitialFreeUpgrade) {
                const freeUpgradesCount = (freeUpgradeMod.effects.find(e => e.stat === 'initialFreeUpgrades') || {}).value || 0;
                for (let i = 0; i < freeUpgradesCount; i++) {
                    setTimeout(() => onLevelUpCallback(true), 100 * (i + 1));
                }
            }
        });
    }, [onLevelUpCallback, setGameState]);

    const spawnBoss = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 1) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const nightmareDamageMultiplier = isNightmareMode ? 1.25 : 1;
            const initialAngle = Math.random() * 2 * Math.PI;
            const bossData = {
                id: `boss-${now}`,
                bossType: 'guardian', 
                position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 4 },
                size: BOSS_STATS.size,
                coreSize: BOSS_STATS.coreSize,
                health: BOSS_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                damage: BOSS_STATS.damage * nightmareDamageMultiplier * draft.gameModifiers.enemyDamageMultiplier,
                color: GAME_COLORS.BOSS_CORE, speed: BOSS_STATS.speed,
                velocity: { x: Math.cos(initialAngle) * BOSS_STATS.speed, y: Math.sin(initialAngle) * BOSS_STATS.speed },
                phase: 1, isInvulnerable: true, 
                lastPhase1AttackTime: now, lastPhase2AttackTime: now, phase2BurstCounter: 0, lastPulseAttackTime: now,
                lastCorruptedZoneTime: now, lastGlitchMinionSpawnTime: now, lastDataStreamAttackTime: now,
                lastKernelPanicPulseTime: now, kernelPanicChargeStartTime: 0,
                statusEffects: [], 
            };
            const shieldNodes = [];
            for (let i = 0; i < BOSS_SHIELD_NODE_STATS.count; i++) {
                shieldNodes.push({
                    id: `shieldnode-${bossData.id}-${i}`,
                    angle: (Math.PI * 2 / BOSS_SHIELD_NODE_STATS.count) * i, position: { x: 0, y: 0 }, 
                    size: BOSS_SHIELD_NODE_STATS.size,
                    health: BOSS_SHIELD_NODE_STATS.maxHealth * nightmareMultiplier, maxHealth: BOSS_SHIELD_NODE_STATS.maxHealth * nightmareMultiplier,
                    color: GAME_COLORS.BOSS_SHIELD_NODE, statusEffects: [], 
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.bossShieldNodes = shieldNodes;
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);

    const spawnBoss2 = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 2) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const nightmareDamageMultiplier = isNightmareMode ? 1.25 : 1;

            const bossData = {
                id: `boss2-${now}`,
                bossType: 'sincronizador',
                position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                size: BOSS_2_STATS.size,
                health: BOSS_2_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_2_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                damage: BOSS_2_STATS.damage * nightmareDamageMultiplier * draft.gameModifiers.enemyDamageMultiplier,
                color: GAME_COLORS.BOSS_2_CORE, speed: 0, 
                phase: 1, isInvulnerable: true, 
                lastEnergyWaveTime: now,
                lastLaserTime: now,
                lastDataWallTime: now,
                lastMinionSpawnTime: now,
                lastNovaAttackTime: now,
                statusEffects: [], 
            };
            const subRoutines = [];
            for (let i = 0; i < BOSS_2_SUB_ROUTINE_STATS.count; i++) {
                subRoutines.push({
                    id: `subroutine-${bossData.id}-${i}`,
                    angle: (Math.PI * 2 / BOSS_2_SUB_ROUTINE_STATS.count) * i,
                    position: { x: 0, y: 0 }, 
                    size: BOSS_2_SUB_ROUTINE_STATS.size,
                    health: BOSS_2_SUB_ROUTINE_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                    maxHealth: BOSS_2_SUB_ROUTINE_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                    color: GAME_COLORS.BOSS_2_SUB_ROUTINE,
                    statusEffects: [], 
                    lastShotTime: now + i * 500,
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.bossShieldNodes = subRoutines;
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);
    
    const spawnBoss3 = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 3) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const bossData = {
                id: `boss3-${now}`, bossType: 'arbiter', position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                size: BOSS_3_STATS.size, health: BOSS_3_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_3_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                color: GAME_COLORS.BOSS_3_CORE, phase: 1, statusEffects: [], vulnerableEndTime: 0,
                lastAttackTime: {}, hasStarted: false,
                phase3AuraRadius: BOSS_3_STATS.phase3AuraInitialRadius, lastPhase3AuraDamageTime: 0,
            };
            const sockets = [];
            const padding = 200;
            const positions = [
                { x: padding, y: padding }, { x: CANVAS_WIDTH - padding, y: padding },
                { x: padding, y: CANVAS_HEIGHT - padding }, { x: CANVAS_WIDTH - padding, y: CANVAS_HEIGHT - padding }
            ];
            for (let i = 0; i < RAM_SOCKET_STATS.count; i++) {
                sockets.push({
                    id: `ram-${bossData.id}-${i}`, position: positions[i],
                    isCorrupted: false, cleanseProgress: 0,
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.ramSockets = sockets;
            draft.bossShieldNodes = [];
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
            draft.bossAttacks = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);

    const spawnBoss4 = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 4) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const bossData = {
                id: `boss4-${now}`, bossType: 'hivemind_nexus', position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                size: BOSS_4_STATS.size, health: BOSS_4_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_4_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                color: GAME_COLORS.BOSS_4_CORE, phase: 1, statusEffects: [],
                lastAttackTime: {}, arenaShrinkAmount: 0,
            };
            const subRouters = [];
            const padding = 150;
            const positions = [ { x: padding, y: padding }, { x: CANVAS_WIDTH - padding, y: padding }, { x: padding, y: CANVAS_HEIGHT - padding }, { x: CANVAS_WIDTH - padding, y: CANVAS_HEIGHT - padding }];
            for (let i = 0; i < BOSS_4_STATS.subRouterCount; i++) {
                subRouters.push({
                    id: `subrouter-${bossData.id}-${i}`, position: positions[i],
                    size: 40, health: BOSS_4_STATS.subRouterHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_4_STATS.subRouterHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                    color: GAME_COLORS.BOSS_4_SUB_ROUTER, statusEffects: []
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.bossShieldNodes = subRouters;
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
            draft.bossAttacks = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);

    const startNextStage = useAppCallback((stageNumber) => {
        setGameState(draft => {
            let healthBonus = 0;
            if (stageNumber === 2) healthBonus = 50;
            if (stageNumber === 3) healthBonus = 100;
            if (stageNumber === 4) healthBonus = 150;

            draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + healthBonus);
            draft.stage = stageNumber;
            draft.enemies = [];
            draft.projectiles = [];
            draft.particles = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
            draft.boss = null;
            draft.bossShieldNodes = [];
            draft.isBossEventTriggered = false;
            draft.nextEnemySpawnTime = Date.now() + ENEMY_SPAWN_INITIAL_DELAY;
        });
    }, [setGameState]);

    const _applyStatusEffectToEntity = useGameEngineCallback((entity, effect, now) => {
        if (!entity.statusEffects) entity.statusEffects = [];
        const existingEffectIndex = entity.statusEffects.findIndex(ef => ef.type === effect.type && ef.sourceId === effect.sourceId);
        const newEffectEntry = { ...effect, startTime: now };

        if (existingEffectIndex !== -1) { 
            const existing = entity.statusEffects[existingEffectIndex];
            existing.startTime = newEffectEntry.startTime;
            existing.duration = newEffectEntry.duration; 
            if (newEffectEntry.magnitude) { 
                    existing.magnitude = effect.type === StatusEffectType.VULNERABILITY ? Math.max(existing.magnitude || 1, newEffectEntry.magnitude) : newEffectEntry.magnitude;
            }
        } else {
            entity.statusEffects.push(newEffectEntry);
        }
    },[]);
    
    const handleGameOverWithStats = useAppCallback(() => {
        sessionStatsRef.current.timeSurvived = gameState.gameTime;
        sessionStatsRef.current.levelReached = gameState.level;
        sessionStatsRef.current.score = gameState.score;
        sessionStatsRef.current.reachedInfiniteMode = gameState.isInfiniteMode;
        sessionStatsRef.current.evolvedWeaponIds = new Set(gameState.player.weapons.filter(w => w.isEvolved).map(w => w.evolutionId));
        onGameOverCallback(sessionStatsRef.current);
    }, [gameState.gameTime, gameState.level, gameState.score, gameState.isInfiniteMode, gameState.player.weapons, onGameOverCallback]);

    const gameTick = useAppCallback((deltaTime) => {

            try {
                setGameState(draft => {

                    if (draft.isPaused || !isGameActive) {
                        return; // Se estiver pausado, simplesmente não fazemos nada e saímos.
                    }
                    const now = Date.now();
                    const { gameModifiers } = draft;
                    
                    const gameTimeSeconds = Math.floor(draft.gameTime);
                    const shouldTriggerDataVault = 
                        (gameTimeSeconds === DATA_VAULT_TRIGGER_TIME) ||
                        (gameTimeSeconds === DATA_VAULT_2_TRIGGER_TIME) ||
                        (gameTimeSeconds === DATA_VAULT_3_TRIGGER_TIME);

                    if (!draft.eventActive && !draft.boss && shouldTriggerDataVault) {
                        draft.eventActive = 'DATA_VAULT';
                        const killRequirementMultiplier = 
                            gameTimeSeconds === DATA_VAULT_2_TRIGGER_TIME ? 1.5 :
                            gameTimeSeconds === DATA_VAULT_3_TRIGGER_TIME ? 2.0 : 1.0;
                        
                        draft.eventKillCounter = Math.floor(DATA_VAULT_KILL_REQUIREMENT * killRequirementMultiplier);
                        draft.eventKillsSoFar = 0;
                        draft.dataVault = { position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 } };
                        SoundManager.play('eventStart');
                    }

                    const bossShouldTrigger = 
                        (draft.stage === 1 && draft.gameTime >= (BOSS_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode) ||
                        (draft.stage === 2 && draft.gameTime >= (BOSS_2_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode) ||
                        (draft.stage === 3 && draft.gameTime >= (BOSS_3_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode) ||
                        (draft.stage === 4 && draft.gameTime >= (BOSS_4_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode);

                    if (bossShouldTrigger && !draft.isBossEventTriggered) {
                        draft.isBossEventTriggered = true;
                        draft.isPaused = true; 
                        draft.enemies = [];
                        draft.projectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
                        draft.expOrbs = []; draft.healthPickups = []; draft.particles = []; draft.corruptedZones = []; draft.acidPuddles = []; draft.interactables = []; draft.alliedMinions = []; draft.unstableSectors = [];
                        onBossWarningStartCallback(draft.stage); 
                        SoundManager.play('bossWarning');
                        return; 
                    }

                    const isBossFightActive = draft.boss !== null;
                    if(isBossFightActive && sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] === undefined){
                        sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] = 0;
                    }
                    const shouldSpawnNormalEnemies = !isBossFightActive;

                    let playerSpeedMultiplier = 1;
                    let playerCooldownMultiplier = 1;
                    let playerDamageMultiplier = 1;
                    let playerDamageReductionMultiplier = 1;
                    let tempRegenPerSecond = 0;
                    
                    if (draft.player.hasInfiniteFury) {
                        playerDamageMultiplier *= (1 + (draft.player.furyStacks || 0) * 0.01);
                        playerCooldownMultiplier *= (1 - (draft.player.furyStacks || 0) * 0.01);
                    }

                    draft.player.temporaryBuffs = draft.player.temporaryBuffs.filter(buff => {
                        if (now >= buff.endTime) return false;
                        switch(buff.type) {
                            case TemporaryBuffType.MOVE_SPEED: playerSpeedMultiplier *= buff.magnitude; break;
                            case TemporaryBuffType.ATTACK_SPEED: playerCooldownMultiplier *= buff.magnitude; break;
                            case TemporaryBuffType.DAMAGE_AMP: playerDamageMultiplier *= buff.magnitude; break;
                            case TemporaryBuffType.REGEN: tempRegenPerSecond += buff.magnitude; break;
                            case TemporaryBuffType.DAMAGE_REDUCTION: playerDamageReductionMultiplier *= buff.magnitude; break;
                        }
                        return true;
                    });
                    const finalPlayerDamageReduction = 1 - ((1 - (draft.player.damageReduction || 0)) * playerDamageReductionMultiplier);

                    const libraryPlayerIsOn = draft.interactables.find(i => i.type === InteractableType.CORRUPTED_LIBRARY && calculateDistance(draft.player.position, i.position) < i.radius);
                    if (libraryPlayerIsOn) {
                        playerCooldownMultiplier *= INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].DEBUFF_MAGNITUDE;
                    }
                    
                    draft.bossAttacks.forEach(attack => {
                        if(attack.type === BossAttackType.STATIC_ZONE && calculateDistance(draft.player.position, attack.position) < BOSS_3_STATS.staticZoneRadius) {
                            playerSpeedMultiplier *= 0.4;
                        }
                    });

                    draft.particles.forEach(p => {
                        if (p.type === 'slow_puddle' && calculateDistance(p.position, draft.player.position) < p.radius) {
                            playerSpeedMultiplier *= 0.5;
                        }
                    });
                    
                    const currentDashCooldown = DASH_STATS.COOLDOWN * (draft.player.dashCooldownModifier || 1.0);
                    if (draft.keys[' '] && !draft.player.isDashing && now > draft.player.dashCooldownUntil) {
                        draft.player.isDashing = true;
                        draft.player.dashEndTime = now + (DASH_STATS.DURATION * (draft.player.dashDurationModifier || 1.0));
                        draft.player.dashCooldownUntil = now + currentDashCooldown;
                        const moveDir = normalizeVector({ x: (draft.keys.d ? 1:0) - (draft.keys.a ? 1:0), y: (draft.keys.s ? 1:0) - (draft.keys.w ? 1:0) });
                        if(moveDir.x === 0 && moveDir.y === 0) {
                            draft.player.dashDirection = { ...draft.player.lastMoveDirection };
                        } else {
                            draft.player.dashDirection = moveDir;
                        }
                        sessionStatsRef.current.dashUsedInSession = true;
                        sessionStatsRef.current.totalDashes++;
                        SoundManager.play('playerDash');
                    }
                    
                    if (draft.player.isDashing) {
                        if (now > draft.player.dashEndTime) {
                            draft.player.isDashing = false;
                        } else {
                            draft.particles.push({ id: `p-dash-${now}-${Math.random()}`, position: { ...draft.player.position }, velocity: { x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*10 }, size: Math.random()*3+2, color: draft.player.color, life: 20 });
                        }
                    }
                    
                    const playerMoved = (draft.keys.w || draft.keys.a || draft.keys.s || draft.keys.d);
                    if(playerMoved) {
                        sessionStatsRef.current.lastMoveTime = now;
                        sessionStatsRef.current.timeWithoutMoving = 0;
                    } else {
                        sessionStatsRef.current.timeWithoutMoving = now - sessionStatsRef.current.lastMoveTime;
                    }

                    if (draft.player.isDashing) {
                        const dashSpeed = draft.player.speed * DASH_STATS.SPEED_MULTIPLIER * playerSpeedMultiplier;
                        draft.player.position.x += draft.player.dashDirection.x * dashSpeed * deltaTime;
                        draft.player.position.y += draft.player.dashDirection.y * dashSpeed * deltaTime;
                    } else if (playerMoved) {
                        let dx = 0, dy = 0;
                        if (draft.keys.w) dy -= 1; if (draft.keys.s) dy += 1;
                        if (draft.keys.a) dx -= 1; if (draft.keys.d) dx += 1;
                        const norm = normalizeVector({ x: dx, y: dy });
                        draft.player.lastMoveDirection = { ...norm };
                        draft.player.position.x += norm.x * draft.player.speed * playerSpeedMultiplier * deltaTime;
                        draft.player.position.y += norm.y * draft.player.speed * playerSpeedMultiplier * deltaTime;
                    }
                    draft.player.position.x = Math.max(draft.player.size / 2, Math.min(CANVAS_WIDTH - draft.player.size / 2, draft.player.position.x));
                    draft.player.position.y = Math.max(draft.player.size / 2, Math.min(CANVAS_HEIGHT - draft.player.size / 2, draft.player.position.y));
                    
                    if (draft.player.classId === 'class_technomancer') {
                        draft.alliedMinions.forEach((minion, index) => {
                            minion.angle = minion.angle || 0;
                            
                            let currentTarget = [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].find(e => e.id === minion.targetId && e.health > 0);
                            if (!currentTarget) {
                                let closestEnemy = null, minDistance = Infinity;
                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                    if (target.health > 0) {
                                        const dist = calculateDistance(minion.position, target.position);
                                        if (dist < minDistance) { minDistance = dist; closestEnemy = target; }
                                    }
                                });
                                if (closestEnemy) minion.targetId = closestEnemy.id;
                                currentTarget = closestEnemy;
                            }
                            if (currentTarget) {
                                const dir = normalizeVector({ x: currentTarget.position.x - minion.position.x, y: currentTarget.position.y - minion.position.y });
                                minion.position.x += dir.x * minion.speed * deltaTime;
                                minion.position.y += dir.y * minion.speed * deltaTime;
                                minion.angle = Math.atan2(dir.y, dir.x);
                            }
                        });
                    }

                    const permanentRegen = draft.player.regenAmount || 0;
                    if ((permanentRegen > 0 || tempRegenPerSecond > 0) && now - (draft.player.lastRegenTime || 0) > 1000) { 
                        let totalRegen = tempRegenPerSecond + permanentRegen;
                        draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + totalRegen);
                        draft.player.lastRegenTime = now;
                    }

                    if (draft.player.overdriveActive && now > draft.player.overdriveEndTime) { draft.player.overdriveActive = false; draft.player.overdriveDamageBonusFactor = 1; }
                    const overdriveLevel = ownedUpgradesRef.current.get('player_overdrive') || 0;
                    if (overdriveLevel > 0 && !draft.player.overdriveActive && now > draft.player.overdriveCooldownUntil && (draft.player.health / draft.player.maxHealth) < 0.25) { draft.player.overdriveActive = true; draft.player.overdriveEndTime = now + 5000; draft.player.overdriveCooldownUntil = now + 5000 + 30000; draft.player.overdriveDamageBonusFactor = 1 + (0.15 + overdriveLevel * 0.05); }

                    if (shouldSpawnNormalEnemies && now > draft.nextEnemySpawnTime) {
                        const spawnPos = getEnemySpawnPosition();
                        const timeForDifficulty = draft.isInfiniteMode ? draft.gameTime - BOSS_4_TRIGGER_TIME : (draft.stage === 2 ? draft.gameTime - BOSS_TRIGGER_TIME : (draft.stage === 3 ? draft.gameTime - BOSS_2_TRIGGER_TIME : (draft.stage === 4 ? draft.gameTime - BOSS_3_TRIGGER_TIME : draft.gameTime)));
                        let difficultyMultiplier = 1 + Math.floor(timeForDifficulty / 60) * 0.15;
                        let healthMultiplier = 1 + Math.floor(timeForDifficulty / 45) * 0.20;
                        let damageMultiplier = 1 + Math.floor(timeForDifficulty / 60) * 0.15;

                        if (draft.isNightmareMode) {
                            healthMultiplier *= 2;
                            damageMultiplier *= 1.25;
                        }

                        let enemyConfig;
                        if (draft.stage === 1) {
                            const eligibleTypes = [EnemyType.DEFAULT, EnemyType.MEMORY_LEAK, EnemyType.SPYWARE, EnemyType.TROJAN_HORSE, EnemyType.ROOTKIT, EnemyType.DDOS_BOT]
                                .filter(type => draft.gameTime > (ENEMY_SPAWN_TIMES[type] || -1));
                            if(eligibleTypes.length === 0) eligibleTypes.push(EnemyType.DEFAULT);
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch (selectedType) {
                                case EnemyType.MEMORY_LEAK: enemyConfig = ENEMY_MEMORY_LEAK_STATS; break;
                                case EnemyType.SPYWARE: enemyConfig = ENEMY_SPYWARE_STATS; break;
                                case EnemyType.TROJAN_HORSE: enemyConfig = ENEMY_TROJAN_HORSE_STATS; break;
                                case EnemyType.ROOTKIT: enemyConfig = ENEMY_ROOTKIT_STATS; break;
                                case EnemyType.DDOS_BOT: enemyConfig = ENEMY_DDOS_BOT_STATS; break;
                                default: enemyConfig = ENEMY_DEFAULT_STATS;
                            }
                        } else if (draft.stage === 2) {
                            const eligibleTypes = [EnemyType.PROCESSO_CORROMPIDO, EnemyType.PONTEIRO_NULO, EnemyType.SEGMENTO_FALHA, EnemyType.PROCESSO_ZUMBI];
                            const timeInStage2 = draft.gameTime - BOSS_TRIGGER_TIME;
                            if (timeInStage2 < 90) eligibleTypes.splice(3, 1);
                            if (timeInStage2 < 60) eligibleTypes.splice(2, 1);
                            if (timeInStage2 < 30) eligibleTypes.splice(1, 1);
                            
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch (selectedType) {
                                case EnemyType.PONTEIRO_NULO: enemyConfig = ENEMY_PONTEIRO_NULO_STATS; break;
                                case EnemyType.SEGMENTO_FALHA: enemyConfig = ENEMY_SEGMENTO_FALHA_STATS; break;
                                case EnemyType.PROCESSO_ZUMBI: enemyConfig = ENEMY_PROCESSO_ZUMBI_STATS; break;
                                default: enemyConfig = ENEMY_PROCESSO_CORROMPIDO_STATS;
                            }
                        } else if (draft.stage === 3) { 
                            const eligibleTypes = [EnemyType.NANITE, EnemyType.HEATSINK, EnemyType.IO_CONTROLLER, EnemyType.VOLATILE_PROCESS];
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch(selectedType) {
                                case EnemyType.HEATSINK: enemyConfig = ENEMY_HEATSINK_STATS; break;
                                case EnemyType.IO_CONTROLLER: enemyConfig = ENEMY_IO_CONTROLLER_STATS; break;
                                case EnemyType.VOLATILE_PROCESS: enemyConfig = ENEMY_VOLATILE_PROCESS_STATS; break;
                                default: enemyConfig = ENEMY_NANITE_STATS;
                            }
                        } else if (draft.stage === 4) {
                            const eligibleTypes = [EnemyType.RECURSIVE_PROCESS, EnemyType.ROGUE_FIREWALL, EnemyType.LATENCY_SPIKE, EnemyType.PROTOCOL_ANOMALY];
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch(selectedType) {
                                case EnemyType.ROGUE_FIREWALL: enemyConfig = ENEMY_ROGUE_FIREWALL_STATS; break;
                                case EnemyType.LATENCY_SPIKE: enemyConfig = ENEMY_LATENCY_SPIKE_STATS; break;
                                case EnemyType.PROTOCOL_ANOMALY: enemyConfig = ENEMY_PROTOCOL_ANOMALY_STATS; break;
                                default: enemyConfig = ENEMY_RECURSIVE_PROCESS_STATS;
                            }
                        }

                        const createEnemyObject = (config, specificSpawnPos) => {
                            const enemy = {
                                id: `enemy-${now}-${Math.random().toString(36).substr(2, 5)}`,
                                type: config.type, position: specificSpawnPos || spawnPos, size: config.size,
                                baseSpeed: config.baseSpeed, speed: config.baseSpeed * difficultyMultiplier * gameModifiers.enemySpeedMultiplier,
                                color: config.color,
                                health: config.health * healthMultiplier * gameModifiers.enemyHealthMultiplier, maxHealth: config.health * healthMultiplier * gameModifiers.enemyHealthMultiplier,
                                damage: config.damage * damageMultiplier * gameModifiers.enemyDamageMultiplier,
                                expValue: Math.floor(config.expValue * (1 + Math.floor(draft.gameTime / 45) * 0.115)), 
                                isVisible: true, dotEffects: [], statusEffects: [],
                                isConvertible: config.isConvertible,
                            };
                            if (config.type === EnemyType.MEMORY_LEAK) { enemy.trail = []; enemy.lastTrailDropTime = now; } 
                            else if (config.type === EnemyType.SPYWARE) { enemy.invisibilityToggleTime = now + config.visibilityDuration; enemy.isCurrentlyVisible = true; }
                            else if (config.type === EnemyType.PONTEIRO_NULO) { enemy.teleportCooldownUntil = now + 2000; enemy.isChargingTeleport = false; }
                            else if (config.type === EnemyType.SEGMENTO_FALHA) { enemy.isShielded = false; enemy.shieldCooldownUntil = now + 3000; }
                            else if (config.type === EnemyType.PROCESSO_ZUMBI) { enemy.hasRevived = false; }
                            else if (config.type === EnemyType.NANITE) { enemy.waveOffset = Math.random() * Math.PI * 2; }
                            else if (config.type === EnemyType.HEATSINK) { enemy.lastPulseTime = now; }
                            else if (config.type === EnemyType.IO_CONTROLLER) { enemy.lastShotTime = now; }
                            else if (config.type === EnemyType.VOLATILE_PROCESS) { enemy.fuseEndTime = now + config.fuseTime; }
                            else if (config.type === EnemyType.PROTOCOL_ANOMALY) { enemy.protocol = 'TCP'; enemy.lastProtocolSwitch = now; }
                            return enemy;
                        };
                        
                        const newlySpawnedEnemies = [];
                        if (enemyConfig.type === EnemyType.DDOS_BOT) {
                            for (let i = 0; i < ENEMY_DDOS_BOT_STATS.swarmCount; i++) {
                                newlySpawnedEnemies.push(createEnemyObject(enemyConfig, getEnemySpawnPosition()));
                            }
                        } else {
                            newlySpawnedEnemies.push(createEnemyObject(enemyConfig, spawnPos));
                        }

                        newlySpawnedEnemies.forEach(enemy => {
                            if (gameModifiers.eliteChance > 0 && Math.random() < gameModifiers.eliteChance && !enemy.isElite) {
                                enemy.isElite = true;
                                enemy.health *= 2;
                                enemy.maxHealth *= 2;
                                enemy.damage *= 1.5;
                                enemy.size *= 1.2;
                                enemy.color = '#FFD700';
                                enemy.expValue = Math.floor(enemy.expValue * 1.5);
                            }
                        });
                        
                        draft.enemies.push(...newlySpawnedEnemies);
                        
                        let spawnDelay = Math.max(ENEMY_SPAWN_MIN_INTERVAL, ENEMY_SPAWN_INITIAL_DELAY - draft.gameTime * ENEMY_SPAWN_INTERVAL_DECREMENT_FACTOR);
                        if (draft.isNightmareMode) {
                            spawnDelay *= 0.75; 
                        }

                        if (draft.stage === 2 && !draft.isInfiniteMode && (draft.gameTime - BOSS_TRIGGER_TIME < 60)) {
                            spawnDelay *= 2; 
                        }

                        if (draft.stage === 3 && !draft.isInfiniteMode && (draft.gameTime - BOSS_2_TRIGGER_TIME < 70)) {
                            spawnDelay *= 2.5;
                        }
                        if (draft.stage === 4 && !draft.isInfiniteMode && (draft.gameTime - BOSS_3_TRIGGER_TIME < 80)) {
                            spawnDelay *= 3;
                        }

                        draft.nextEnemySpawnTime = now + spawnDelay;
                    }
                    
                    if (now > draft.nextInteractableSpawnTime && !isBossFightActive) {
                        const type = Math.random() < 0.6 ? InteractableType.DATA_CACHE : InteractableType.CORRUPTED_LIBRARY;
                        const pos = getRandomCanvasPosition(100);
                        let newInteractable;

                        if (type === InteractableType.DATA_CACHE) {
                            const stats = INTERACTABLE_STATS[InteractableType.DATA_CACHE];
                            const buffTemplate = stats.BUFFS[Math.floor(Math.random() * stats.BUFFS.length)];
                            newInteractable = {
                                id: `interact-${now}`, type: InteractableType.DATA_CACHE, position: pos, size: stats.SIZE,
                                creationTime: now, duration: stats.DURATION, buff: { ...buffTemplate }
                            };
                        } else {
                            const stats = INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY];
                            newInteractable = {
                                id: `interact-${now}`, type: InteractableType.CORRUPTED_LIBRARY, position: pos, radius: stats.RADIUS,
                                creationTime: now, duration: stats.DURATION, cleanseProgress: 0, wasInsideLastFrame: false,
                            };
                        }
                        draft.interactables.push(newInteractable);
                        draft.nextInteractableSpawnTime = now + INTERACTABLE_STATS.SPAWN_INTERVAL_MIN + Math.random() * (INTERACTABLE_STATS.SPAWN_INTERVAL_MAX - INTERACTABLE_STATS.SPAWN_INTERVAL_MIN);
                    }

                     if (draft.stage === 3 && !isBossFightActive && now > draft.nextUnstableSectorTime) {
                        draft.unstableSectors = [];
                        const count = 15 + Math.floor(Math.random() * 6);
                        for (let i = 0; i < count; i++) {
                            draft.unstableSectors.push({
                                x: Math.floor(Math.random() * (CANVAS_WIDTH / 40)) * 40,
                                y: Math.floor(Math.random() * (CANVAS_HEIGHT / 40)) * 40,
                                endTime: now + 5000
                            });
                        }
                        draft.nextUnstableSectorTime = now + 8000;
                    }
                    draft.unstableSectors = draft.unstableSectors.filter(s => now < s.endTime);


                    const interactablesToRemove = new Set();
                    draft.interactables.forEach(i => {
                        if (now > i.creationTime + i.duration) { interactablesToRemove.add(i.id); return; }
                        if (i.type === InteractableType.DATA_CACHE) {
                            const interactionRadiusSq = (draft.player.size / 2 + i.size / 2) ** 2;
                            if (calculateDistanceSq(draft.player.position, i.position) < interactionRadiusSq) {
                                const newBuff = { ...i.buff, endTime: now + i.buff.duration, id: `buff-${now}` };
                                draft.player.temporaryBuffs.push(newBuff); interactablesToRemove.add(i.id); SoundManager.play('pickupBuff');
                                sessionStatsRef.current.dataCachesCollectedInSession++;
                            }
                        } else if (i.type === InteractableType.CORRUPTED_LIBRARY) {
                            const isInside = calculateDistanceSq(draft.player.position, i.position) < i.radius * i.radius;
                            if (isInside) {
                                if (!i.wasInsideLastFrame) SoundManager.play('enterDebuffZone');
                                i.cleanseProgress += (1 / INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].CLEANSE_TIME) * (deltaTime * 1000);
                                if (i.cleanseProgress >= 1) {
                                    SoundManager.play('cleanseComplete');
                                    sessionStatsRef.current.corruptedLibrariesCleansed++;
                                    const rewardType = Math.random() < 0.4 ? 'HEALTH' : 'XP';
                                    if (rewardType === 'HEALTH') {
                                        draft.healthPickups.push({ id: `hp-lib-${now}`, position: i.position, size: HEALTH_PICKUP_STATS.size, healAmount: HEALTH_PICKUP_STATS.healAmount, color: GAME_COLORS.HEALTH_PICKUP, });
                                    } else {
                                        const { REWARD_XP_COUNT, REWARD_XP_VALUE } = INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY];
                                        for(let j=0; j < REWARD_XP_COUNT; j++) {
                                                draft.expOrbs.push({ id: `xp-lib-${now}-${j}`, position: {x: i.position.x + (Math.random()-0.5)*20, y: i.position.y + (Math.random()-0.5)*20}, size: 10, value: REWARD_XP_VALUE, color: GAME_COLORS.XP_ORB });
                                        }
                                    }
                                    interactablesToRemove.add(i.id);
                                }
                            } else {
                                i.cleanseProgress = Math.max(0, i.cleanseProgress - (INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].DECAY_RATE / INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].CLEANSE_TIME) * (deltaTime * 1000));
                            }
                            i.wasInsideLastFrame = isInside;
                        }
                    });
                    if (interactablesToRemove.size > 0) {
                        draft.interactables = draft.interactables.filter(i => !interactablesToRemove.has(i.id));
                    }

                    if (draft.revivingProcesses.length > 0) {
                        const newlyRevived = [];
                        draft.revivingProcesses = draft.revivingProcesses.filter(proc => {
                            if (now >= proc.reviveAt) {
                                SoundManager.play('zombieRevive');
                                const nightmareDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                const enemy = {
                                    id: `enemy-revived-${now}-${Math.random().toString(36).substr(2, 5)}`, type: ENEMY_PROCESSO_ZUMBI_STATS.type, position: proc.position, size: ENEMY_PROCESSO_ZUMBI_STATS.size,
                                    baseSpeed: ENEMY_PROCESSO_ZUMBI_STATS.baseSpeed, speed: ENEMY_PROCESSO_ZUMBI_STATS.baseSpeed, color: ENEMY_PROCESSO_ZUMBI_STATS.color, health: proc.maxHealth * ENEMY_PROCESSO_ZUMBI_STATS.reviveHealthFactor, maxHealth: proc.maxHealth,
                                    damage: ENEMY_PROCESSO_ZUMBI_STATS.damage * nightmareDamageMultiplier, expValue: 0, isVisible: true, dotEffects: [], statusEffects: [], hasRevived: true,
                                };
                                newlyRevived.push(enemy); for(let k=0; k<15; ++k) draft.particles.push({ id: `p-revive-${enemy.id}-${k}`, position: { ...enemy.position }, velocity: { x: (Math.random()-0.5)*70, y: (Math.random()-0.5)*70 }, size: Math.random()*2+2, color: GAME_COLORS.ENEMY_PROCESSO_ZUMBI, life: 80 });
                                return false;
                            }
                            return true;
                        });
                        if (newlyRevived.length > 0) { draft.enemies.push(...newlyRevived); }
                    }

                    if (now > draft.nextHealthPickupSpawnTime && !isBossFightActive) { 
                        draft.healthPickups.push({ id: `hp-${now}`, position: getRandomCanvasPosition(), size: HEALTH_PICKUP_STATS.size, healAmount: HEALTH_PICKUP_STATS.healAmount, color: GAME_COLORS.HEALTH_PICKUP, });
                        const intervalMin = HEALTH_PICKUP_STATS.spawnIntervalMin / gameModifiers.healthPickupSpawnRateMultiplier;
                        const intervalMax = HEALTH_PICKUP_STATS.spawnIntervalMax / gameModifiers.healthPickupSpawnRateMultiplier;
                        draft.nextHealthPickupSpawnTime = now + intervalMin + Math.random() * (intervalMax - intervalMin);
                    }
                    
                    draft.enemies.forEach(e => {
                        let currentSpeedMultiplier = 1; let isFrozen = false; let isFeared = false; e.vulnerabilityFactor = 1; 
                        const statusEffectDuration = (draft.player.statusEffectDuration || 1.0);
                        e.statusEffects = e.statusEffects.filter(effect => { if (now > effect.startTime + (effect.duration * statusEffectDuration)) return false; switch (effect.type) { case StatusEffectType.SLOW: currentSpeedMultiplier = Math.min(currentSpeedMultiplier, effect.magnitude || 0.5); break; case StatusEffectType.FREEZE: isFrozen = true; break; case StatusEffectType.VULNERABILITY: e.vulnerabilityFactor = Math.max(e.vulnerabilityFactor, effect.magnitude || 1.2); break; case StatusEffectType.FEAR: isFeared = true; break; } return true; });
                        if (e.dotEffects && e.dotEffects.length > 0) { e.dotEffects = e.dotEffects.filter(dot => { if (now - dot.lastTickTime >= dot.tickInterval) { e.health -= dot.damagePerTick * e.vulnerabilityFactor; dot.ticksRemaining--; dot.lastTickTime = now; draft.particles.push({ id: `p-dot-${e.id}-${now}-${Math.random()}`, position: {x: e.position.x + (Math.random()-0.5)*e.size, y: e.position.y + (Math.random()-0.5)*e.size}, size: 2, color: GAME_COLORS.ENEMY_DOT_EFFECT, life: 20 }); } return dot.ticksRemaining > 0; }); }
                        if (e.type === EnemyType.MEMORY_LEAK && e.trail && now - (e.lastTrailDropTime || 0) > ENEMY_MEMORY_LEAK_STATS.trailDropInterval) { e.trail.push({ x: e.position.x, y: e.position.y, createdAt: now, id: `trail-${e.id}-${now}` }); e.lastTrailDropTime = now; if (e.trail.length > 20) e.trail.shift(); }
                        if (e.type === EnemyType.SPYWARE && now > (e.invisibilityToggleTime || 0)) { e.isCurrentlyVisible = !e.isCurrentlyVisible; e.invisibilityToggleTime = now + (e.isCurrentlyVisible ? ENEMY_SPYWARE_STATS.visibilityDuration : ENEMY_SPYWARE_STATS.invisibilityDuration); }
                        if (e.type === EnemyType.HEATSINK && now > (e.lastPulseTime || 0) + ENEMY_HEATSINK_STATS.pulseInterval) { draft.particles.push({ id: `hs-pulse-${e.id}`, type: 'heatsink_pulse', position: { ...e.position }, radius: 0, targetRadius: 80, life: 500, initialLife: 500, destroysProjectiles: true }); e.lastPulseTime = now; }
                        if (e.type === EnemyType.IO_CONTROLLER && now > (e.lastShotTime || 0) + ENEMY_IO_CONTROLLER_STATS.fireRate) { const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); const baseAngle = Math.atan2(dirToPlayer.y, dirToPlayer.x); const totalSpread = ENEMY_IO_CONTROLLER_STATS.spread * (Math.PI / 180); for(let i=-1; i<=1; i++) { const angle = baseAngle + i * (totalSpread / 2); const velocity = { x: Math.cos(angle) * ENEMY_IO_CONTROLLER_STATS.projectileSpeed, y: Math.sin(angle) * ENEMY_IO_CONTROLLER_STATS.projectileSpeed }; draft.projectiles.push({ id: `io-proj-${e.id}-${i}`, position: {...e.position}, velocity, size: ENEMY_IO_CONTROLLER_STATS.projectileSize, color: e.color, damage: e.damage, ownerId: e.id, lifetime: 4000 }); } e.lastShotTime = now; }
                        if (e.type === EnemyType.VOLATILE_PROCESS && now >= e.fuseEndTime) { draft.particles.push({ id: `vol-exp-${e.id}`, type: 'volatile_explosion', position: {...e.position}, radius: 0, targetRadius: ENEMY_VOLATILE_PROCESS_STATS.explosionRadius, color: e.color, life: 300, initialLife: 300, damage: ENEMY_VOLATILE_PROCESS_STATS.explosionDamage, ownerId: e.id }); e.health = 0; }
                        if (e.type === EnemyType.LATENCY_SPIKE) {
                            if (calculateDistanceSq(e.position, draft.player.position) < e.slowAuraRadius * e.slowAuraRadius) {
                                playerSpeedMultiplier *= e.slowMagnitude;
                            }
                            if (now > (e.lastShotTime || 0) + 4000) {
                                const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y });
                                draft.projectiles.push({ id: `latency-proj-${e.id}-${now}`, position: { ...e.position }, velocity: { x: dirToPlayer.x * 200, y: dirToPlayer.y * 200 }, size: 15, color: GAME_COLORS.ENEMY_LATENCY_SPIKE, damage: 0, ownerId: e.id, lifetime: 4000, type: 'latency_spike_shot' });
                                e.lastShotTime = now;
                            }
                        }
                        if (e.type === EnemyType.PROTOCOL_ANOMALY) {
                            if (now > (e.lastProtocolSwitch || 0) + ENEMY_PROTOCOL_ANOMALY_STATS.protocolSwitchInterval) {
                                e.protocol = e.protocol === 'TCP' ? 'UDP' : 'TCP';
                                e.lastProtocolSwitch = now;
                                const healthPercent = e.health / e.maxHealth;
                                if (e.protocol === 'UDP') {
                                    e.speed = e.baseSpeed * 2.5;
                                    e.maxHealth = ENEMY_PROTOCOL_ANOMALY_STATS.health * 0.6;
                                } else {
                                    e.speed = e.baseSpeed;
                                    e.maxHealth = ENEMY_PROTOCOL_ANOMALY_STATS.health;
                                }
                                e.health = e.maxHealth * healthPercent;
                            }
                            if (e.protocol === 'UDP' && now > (e.lastShotTime || 0) + 1500) {
                                const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y });
                                draft.projectiles.push({ id: `anomaly-proj-${e.id}-${now}`, position: { ...e.position }, velocity: { x: dirToPlayer.x * 300, y: dirToPlayer.y * 300 }, size: 10, color: '#ff4757', damage: e.damage, ownerId: e.id, lifetime: 3000, });
                                e.lastShotTime = now;
                            }
                        }
                        
                        let canEnemyMove = true;
                        if (e.type === EnemyType.PONTEIRO_NULO) {
                            if (e.isChargingTeleport) { canEnemyMove = false;
                                if (now > e.teleportChargeStartTime + ENEMY_PONTEIRO_NULO_STATS.teleportChargeTime) { SoundManager.play('teleportExecute'); const dist = calculateDistance(e.position, draft.player.position); const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); e.position.x += dirToPlayer.x * Math.min(dist - e.size, 200); e.position.y += dirToPlayer.y * Math.min(dist - e.size, 200); e.isChargingTeleport = false; e.teleportCooldownUntil = now + ENEMY_PONTEIRO_NULO_STATS.teleportCooldown; }
                            } else if (now > e.teleportCooldownUntil) { SoundManager.play('teleportCharge'); e.isChargingTeleport = true; e.teleportChargeStartTime = now; }
                        }
                        if (e.type === EnemyType.SEGMENTO_FALHA) { if (e.isShielded && now > e.shieldActivateTime + ENEMY_SEGMENTO_FALHA_STATS.shieldDuration) { SoundManager.play('shieldBreak'); e.isShielded = false; e.shieldCooldownUntil = now + ENEMY_SEGMENTO_FALHA_STATS.shieldCooldown; } else if (!e.isShielded && now > e.shieldCooldownUntil) { SoundManager.play('shieldActivate'); e.isShielded = true; e.shieldActivateTime = now; } }
                        if (e.type === EnemyType.SPYWARE && !e.isCurrentlyVisible) canEnemyMove = false;
                        if (isFrozen) canEnemyMove = false;

                        if (canEnemyMove) { 
                            const actualSpeed = e.speed * currentSpeedMultiplier; 
                            if (isFeared) { 
                                const dirAwayFromPlayer = normalizeVector({ x: e.position.x - draft.player.position.x, y: e.position.y - draft.player.position.y }); 
                                e.position.x += dirAwayFromPlayer.x * actualSpeed * deltaTime; 
                                e.position.y += dirAwayFromPlayer.y * actualSpeed * deltaTime; 
                            } else {
                                if (e.type === EnemyType.NANITE) { 
                                    const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); 
                                    const perpendicular = { x: -dirToPlayer.y, y: dirToPlayer.x }; 
                                    const waveFactor = Math.sin(now / 350 + e.waveOffset) * 80; 
                                    e.position.x += (dirToPlayer.x * actualSpeed * deltaTime) + (perpendicular.x * waveFactor * deltaTime); 
                                    e.position.y += (dirToPlayer.y * actualSpeed * deltaTime) + (perpendicular.y * waveFactor * deltaTime); 
                                } else { 
                                    const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); 
                                    e.position.x += dirToPlayer.x * actualSpeed * deltaTime; 
                                    e.position.y += dirToPlayer.y * actualSpeed * deltaTime; 
                                }
                            } 
                        }
                    });
                    draft.enemies.forEach(e => { if (e.type === EnemyType.MEMORY_LEAK && e.trail) { e.trail = e.trail.filter(segment => now - segment.createdAt < ENEMY_MEMORY_LEAK_STATS.trailLifetime); } });

                    if (draft.boss) {
                        const boss = draft.boss;

                        let activeShieldNodesCount = (draft.bossShieldNodes || []).filter(node => node.health > 0).length;
                         
                         let isInvulnerableThisTick = false;
                         if (boss.bossType === 'guardian' || boss.bossType === 'sincronizador' || boss.bossType === 'hivemind_nexus') {
                             isInvulnerableThisTick = boss.phase === 1 && activeShieldNodesCount > 0;
                         } else if (boss.bossType === 'arbiter') {
                             isInvulnerableThisTick = boss.phase < 3 && draft.ramSockets.some(s => s.isCorrupted);
                         }
                         boss.isInvulnerable = isInvulnerableThisTick;

                         let bossCurrentSpeedMultiplier = 1; let bossIsFrozen = false; boss.vulnerabilityFactor = 1;
                         boss.statusEffects = boss.statusEffects.filter(effect => { if (now > effect.startTime + effect.duration) return false; switch (effect.type) { case StatusEffectType.SLOW: bossCurrentSpeedMultiplier = Math.min(bossCurrentSpeedMultiplier, effect.magnitude || 0.5); break; case StatusEffectType.FREEZE: bossIsFrozen = true; break; case StatusEffectType.VULNERABILITY: boss.vulnerabilityFactor = Math.max(boss.vulnerabilityFactor, effect.magnitude || 1.2); break; } return true; });
                         if (!bossIsFrozen) {
                            if (boss.bossType === 'guardian') {
                                boss.position.x += boss.velocity.x * bossCurrentSpeedMultiplier * deltaTime;
                                boss.position.y += boss.velocity.y * bossCurrentSpeedMultiplier * deltaTime;

                                if ((boss.position.x - boss.size / 2 <= 0 && boss.velocity.x < 0) || (boss.position.x + boss.size / 2 >= CANVAS_WIDTH && boss.velocity.x > 0)) {
                                    boss.velocity.x *= -1;
                                }
                                if ((boss.position.y - boss.size / 2 <= 0 && boss.velocity.y < 0) || (boss.position.y + boss.size / 2 >= CANVAS_HEIGHT && boss.velocity.y > 0)) {
                                    boss.velocity.y *= -1;
                                }
                                
                                boss.position.x = Math.max(boss.size / 2, Math.min(CANVAS_WIDTH - boss.size / 2, boss.position.x));
                                boss.position.y = Math.max(boss.size / 2, Math.min(CANVAS_HEIGHT - boss.size / 2, boss.position.y));
                                
                                const projectileDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                const projectileDamage = BOSS_STATS.projectilePhase1Damage * projectileDamageMultiplier;
                                if (boss.phase === 1) { if (now - boss.lastPhase1AttackTime > BOSS_STATS.projectilePhase1FireRate) { const dirToPlayer = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y }); draft.projectiles.push({ id: `bproj1-${now}`, position: { ...boss.position }, velocity: { x: dirToPlayer.x * BOSS_STATS.projectilePhase1Speed, y: dirToPlayer.y * BOSS_STATS.projectilePhase1Speed }, size: BOSS_STATS.projectilePhase1Size, color: GAME_COLORS.BOSS_PROJECTILE_PHASE1, damage: projectileDamage, ownerId: boss.id, lifetime: 5000, type: 'boss_phase1', baseSpeed: BOSS_STATS.projectilePhase1Speed }); boss.lastPhase1AttackTime = now; } } 
                                else if (boss.phase === 2) {  if (now - boss.lastPhase2AttackTime > BOSS_STATS.projectilePhase2FireRate && boss.phase2BurstCounter === 0) { boss.phase2BurstCounter = BOSS_STATS.projectilePhase2BurstCount; boss.lastPhase2AttackTime = now - BOSS_STATS.projectilePhase2BurstInterval; } if (boss.phase2BurstCounter > 0 && now - boss.lastPhase2AttackTime > BOSS_STATS.projectilePhase2BurstInterval) { const dirToPlayer = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y }); const angleOffset = (Math.random() - 0.5) * 0.3;  const finalDirX = Math.cos(Math.atan2(dirToPlayer.y, dirToPlayer.x) + angleOffset); const finalDirY = Math.sin(Math.atan2(dirToPlayer.y, dirToPlayer.x) + angleOffset); draft.projectiles.push({ id: `bproj2-${now}-${boss.phase2BurstCounter}`, position: { ...boss.position }, velocity: { x: finalDirX * BOSS_STATS.projectilePhase2Speed, y: finalDirY * BOSS_STATS.projectilePhase2Speed }, size: BOSS_STATS.projectilePhase2Size, color: GAME_COLORS.BOSS_PROJECTILE_PHASE2, damage: BOSS_STATS.projectilePhase2Damage * projectileDamageMultiplier, ownerId: boss.id, lifetime: 4000, type: 'boss_phase2', baseSpeed: BOSS_STATS.projectilePhase2Speed }); boss.lastPhase2AttackTime = now; boss.phase2BurstCounter--; } if (now - boss.lastCorruptedZoneTime > BOSS_STATS.corruptedZoneInterval) { SoundManager.play('corruptedZoneAppear'); const zonePos = { x: Math.random() * (CANVAS_WIDTH - BOSS_STATS.corruptedZoneRadius*2) + BOSS_STATS.corruptedZoneRadius, y: Math.random() * (CANVAS_HEIGHT - BOSS_STATS.corruptedZoneRadius*2 - UI_BAR_HEIGHT) + BOSS_STATS.corruptedZoneRadius}; draft.corruptedZones.push({ id: `czone-${now}`, position: zonePos, radius: BOSS_STATS.corruptedZoneRadius, creationTime: now, duration: BOSS_STATS.corruptedZoneDuration, damage: BOSS_STATS.corruptedZoneDamage * projectileDamageMultiplier, damageInterval: BOSS_STATS.corruptedZoneDamageInterval, lastDamageTime: 0 }); boss.lastCorruptedZoneTime = now; } if (now - boss.lastGlitchMinionSpawnTime > BOSS_STATS.glitchMinionSpawnInterval) { SoundManager.play('minionSpawn'); for (let i = 0; i < BOSS_STATS.glitchMinionSpawnCount; i++) { const spawnOffsetAngle = Math.random() * Math.PI * 2; const spawnOffsetDist = boss.size * 0.75; draft.enemies.push({ id: `glitch-${now}-${i}`, type: EnemyType.GLITCH_MINION, position: { x: boss.position.x + Math.cos(spawnOffsetAngle) * spawnOffsetDist, y: boss.position.y + Math.sin(spawnOffsetAngle) * spawnOffsetDist }, size: GLITCH_MINION_STATS.size, baseSpeed: GLITCH_MINION_STATS.baseSpeed, speed: GLITCH_MINION_STATS.baseSpeed, health: GLITCH_MINION_STATS.health, damage: GLITCH_MINION_STATS.damage * projectileDamageMultiplier, expValue: GLITCH_MINION_STATS.expValue, color: GAME_COLORS.ENEMY_GLITCH_MINION, isVisible: true, dotEffects: [], statusEffects: [] }); } boss.lastGlitchMinionSpawnTime = now; } } 
                                else if (boss.phase === 3) { if (now - boss.lastCorruptedZoneTime > BOSS_STATS.corruptedZoneInterval * 0.8) { SoundManager.play('corruptedZoneAppear'); const zonePos = { x: Math.random() * (CANVAS_WIDTH - BOSS_STATS.corruptedZoneRadius*2) + BOSS_STATS.corruptedZoneRadius, y: Math.random() * (CANVAS_HEIGHT - BOSS_STATS.corruptedZoneRadius*2 - UI_BAR_HEIGHT) + BOSS_STATS.corruptedZoneRadius}; draft.corruptedZones.push({ id: `czone-${now}`, position: zonePos, radius: BOSS_STATS.corruptedZoneRadius, creationTime: now, duration: BOSS_STATS.corruptedZoneDuration, damage: BOSS_STATS.corruptedZoneDamage * projectileDamageMultiplier, damageInterval: BOSS_STATS.corruptedZoneDamageInterval, lastDamageTime: 0 }); boss.lastCorruptedZoneTime = now; } if (now - boss.lastGlitchMinionSpawnTime > BOSS_STATS.glitchMinionSpawnInterval * 0.7) { SoundManager.play('minionSpawn'); for (let i = 0; i < BOSS_STATS.glitchMinionSpawnCount + 1; i++) { const spawnOffsetAngle = Math.random() * Math.PI * 2; const spawnOffsetDist = boss.size * 0.75; draft.enemies.push({ id: `glitch-${now}-${i}`, type: EnemyType.GLITCH_MINION, position: { x: boss.position.x + Math.cos(spawnOffsetAngle) * spawnOffsetDist, y: boss.position.y + Math.sin(spawnOffsetAngle) * spawnOffsetDist }, size: GLITCH_MINION_STATS.size, baseSpeed: GLITCH_MINION_STATS.baseSpeed * 1.1, speed: GLITCH_MINION_STATS.baseSpeed * 1.1, health: GLITCH_MINION_STATS.health, damage: GLITCH_MINION_STATS.damage * projectileDamageMultiplier, expValue: GLITCH_MINION_STATS.expValue, color: GAME_COLORS.ENEMY_GLITCH_MINION, isVisible: true, dotEffects: [], statusEffects: [] }); } boss.lastGlitchMinionSpawnTime = now; } if (now - boss.lastDataStreamAttackTime > BOSS_STATS.dataStreamBarrageInterval && !boss.kernelPanicChargeStartTime) { SoundManager.play('dataStreamFire'); const playerDir = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y }); const baseAngle = Math.atan2(playerDir.y, playerDir.x); const spread = Math.PI / 4; for (let i = 0; i < BOSS_STATS.dataStreamProjectileCount; i++) { const angle = baseAngle - spread / 2 + (spread / (BOSS_STATS.dataStreamProjectileCount -1)) * i + (Math.random()-0.5)*0.1; const velocity = { x: Math.cos(angle) * BOSS_STATS.dataStreamProjectileSpeed, y: Math.sin(angle) * BOSS_STATS.dataStreamProjectileSpeed }; draft.projectiles.push({ id: `dstream-${now}-${i}`, position: { ...boss.position }, velocity, size: BOSS_STATS.dataStreamProjectileSize, color: GAME_COLORS.PROJECTILE_DATA_STREAM, damage: BOSS_STATS.dataStreamProjectileDamage * projectileDamageMultiplier, ownerId: boss.id, lifetime: 3000, type: 'boss_data_stream', baseSpeed: BOSS_STATS.dataStreamProjectileSpeed }); } boss.lastDataStreamAttackTime = now; } if (!boss.kernelPanicChargeStartTime && now - boss.lastKernelPanicPulseTime > BOSS_STATS.kernelPanicPulseCooldown) { boss.kernelPanicChargeStartTime = now; SoundManager.play('kernelPanicCharge'); draft.particles.push({ id: `kpanicwarn-${now}`, type: 'kernel_panic_warning', position: {...boss.position}, radius: BOSS_STATS.kernelPanicPulseRadius, targetRadius: BOSS_STATS.kernelPanicPulseRadius, color: GAME_COLORS.KERNEL_PANIC_PULSE_WARNING, life: BOSS_STATS.kernelPanicPulseChargeTime, size: 0 }); } if (boss.kernelPanicChargeStartTime && now > boss.kernelPanicChargeStartTime + BOSS_STATS.kernelPanicPulseChargeTime) { SoundManager.play('kernelPanicExecute'); draft.particles.push({ id: `kpanicboom-${now}`, type: 'kernel_panic_explosion', position: {...boss.position}, radius: 0, targetRadius: BOSS_STATS.kernelPanicPulseRadius, color: GAME_COLORS.TEXT_RED, life: 500, initialLife: 500, size: 0 }); if (calculateDistance(draft.player.position, boss.position) < BOSS_STATS.kernelPanicPulseRadius + draft.player.size/2) { if (!draft.player.overdriveActive && !draft.player.isDashing) { draft.player.health -= BOSS_STATS.kernelPanicPulseDamage * projectileDamageMultiplier; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } boss.kernelPanicChargeStartTime = 0; boss.lastKernelPanicPulseTime = now; } }
                            }
                            else if (boss.bossType === 'sincronizador') {
                                const projectileDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                
                                if (boss.phase === 1) { 
                                    if (now - boss.lastEnergyWaveTime > BOSS_2_STATS.phase1EnergyWaveInterval) {
                                        draft.particles.push({ id: `b2-wave-${now}`, type: 'boss_pulse', position: {...boss.position}, radius: 0, targetRadius: BOSS_2_STATS.phase1EnergyWaveRadius, color: GAME_COLORS.BOSS_2_ENERGY_WAVE, life: 700, initialLife: 700, size: 0, damage: BOSS_2_STATS.phase1EnergyWaveDamage * projectileDamageMultiplier, ownerId: boss.id });
                                        boss.lastEnergyWaveTime = now;
                                    }
                                } else {
                                    const novaCooldown = boss.phase === 3 ? BOSS_2_STATS.phase2NovaRate * 0.8 : BOSS_2_STATS.phase2NovaRate;
                                    if (now - boss.lastNovaAttackTime > novaCooldown) {
                                        boss.lastNovaAttackTime = now;
                                        SoundManager.play('dataStreamFire');
                                        for (let i = 0; i < BOSS_2_STATS.phase2NovaProjectileCount; i++) {
                                            const angle = (i / BOSS_2_STATS.phase2NovaProjectileCount) * Math.PI * 2;
                                            const velocity = { x: Math.cos(angle) * BOSS_2_STATS.phase2NovaProjectileSpeed, y: Math.sin(angle) * BOSS_2_STATS.phase2NovaProjectileSpeed };
                                            draft.projectiles.push({
                                                id: `b2-nova-${now}-${i}`,
                                                position: { ...boss.position },
                                                velocity,
                                                size: BOSS_2_STATS.phase2NovaProjectileSize,
                                                color: GAME_COLORS.BOSS_PROJECTILE_PHASE2,
                                                damage: BOSS_2_STATS.phase2NovaProjectileDamage * projectileDamageMultiplier,
                                                ownerId: boss.id,
                                                lifetime: 4000
                                            });
                                        }
                                    }
                                    if (now - boss.lastLaserTime > BOSS_2_STATS.laserCooldown) {
                                        SoundManager.play('laserCharge');
                                        draft.laserBeams.push({ id: `laser-${now}`, chargeStartTime: now, fireStartTime: now + BOSS_2_STATS.laserChargeTime, endTime: now + BOSS_2_STATS.laserChargeTime + BOSS_2_STATS.laserFireDuration, angle: Math.random() * Math.PI * 2, lastHitTime: 0, damage: BOSS_2_STATS.laserDamage * projectileDamageMultiplier });
                                        boss.lastLaserTime = now + BOSS_2_STATS.laserCooldown;
                                    }
                                    const wallCooldown = boss.phase === 3 ? BOSS_2_STATS.dataWallSpawnInterval * 0.7 : BOSS_2_STATS.dataWallSpawnInterval;
                                    if (now - boss.lastDataWallTime > wallCooldown) {
                                        const isHorizontal = Math.random() > 0.5;
                                        const startPos = isHorizontal ? -BOSS_2_STATS.dataWallWidth : CANVAS_WIDTH + BOSS_2_STATS.dataWallWidth;
                                        const numWalls = Math.floor((isHorizontal ? CANVAS_WIDTH : CANVAS_HEIGHT) / (BOSS_2_STATS.dataWallGap));
                                        for (let i = 0; i < numWalls; i++) {
                                            const wall = {
                                                id: `wall-${now}-${i}`,
                                                position: isHorizontal ? { x: startPos, y: i * BOSS_2_STATS.dataWallGap } : { x: i * BOSS_2_STATS.dataWallGap, y: startPos },
                                                velocity: isHorizontal ? { x: BOSS_2_STATS.dataWallSpeed, y: 0 } : { x: 0, y: -BOSS_2_STATS.dataWallSpeed },
                                                width: isHorizontal ? BOSS_2_STATS.dataWallWidth : BOSS_2_STATS.dataWallGap - 65,
                                                height: isHorizontal ? BOSS_2_STATS.dataWallGap - 65 : BOSS_2_STATS.dataWallWidth,
                                                damage: BOSS_2_STATS.dataWallDamage * projectileDamageMultiplier,
                                            };
                                            draft.dataWalls.push(wall);
                                        }
                                        boss.lastDataWallTime = now;
                                    }
                                    if (boss.phase === 3 && now - boss.lastMinionSpawnTime > BOSS_2_STATS.phase3MinionSpawnInterval) {
                                        SoundManager.play('minionSpawn');
                                        for (let i = 0; i < BOSS_2_STATS.phase3MinionSpawnCount; i++) { draft.enemies.push({ id: `glitch-b2-${now}-${i}`, type: EnemyType.GLITCH_MINION, position: { ...getRandomCanvasPosition() }, size: GLITCH_MINION_STATS.size, baseSpeed: GLITCH_MINION_STATS.baseSpeed*1.2, speed: GLITCH_MINION_STATS.baseSpeed*1.2, health: GLITCH_MINION_STATS.health*1.5, damage: GLITCH_MINION_STATS.damage*1.2 * projectileDamageMultiplier, expValue: 0, color: GAME_COLORS.ENEMY_GLITCH_MINION, isVisible: true, dotEffects: [], statusEffects: [] }); }
                                        boss.lastMinionSpawnTime = now;
                                    }
                                }
                            }
                            else if (boss.bossType === 'arbiter') {
                                if (!boss.hasStarted) {
                                    draft.ramSockets.forEach(s => s.isCorrupted = true);
                                    boss.hasStarted = true;
                                }

                                const nightmareDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;

                                if(boss.phase < 3) {
                                    if (isInvulnerableThisTick) {
                                        if (now > (boss.lastAttackTime.dataSmasher || 0) + BOSS_3_STATS.dataSmasherRate) {
                                            draft.bossAttacks.push({ type: BossAttackType.DATA_SMASHER, id: `smash-${now}`, targetPosition: { ...draft.player.position }, creationTime: now, warningDuration: BOSS_3_STATS.dataSmasherWarnTime, radius: BOSS_3_STATS.dataSmasherRadius, damage: BOSS_3_STATS.dataSmasherDamage * nightmareDamageMultiplier });
                                            boss.lastAttackTime.dataSmasher = now;
                                        }
                                        if (now > (boss.lastAttackTime.corruptionWave || 0) + BOSS_3_STATS.corruptionWaveRate) {
                                            const dirToPlayer = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y });
                                            draft.projectiles.push({ id: `bwave-${now}`, position: { ...boss.position }, velocity: { x: dirToPlayer.x * BOSS_3_STATS.corruptionWaveSpeed, y: dirToPlayer.y * BOSS_3_STATS.corruptionWaveSpeed }, size: BOSS_3_STATS.corruptionWaveWidth, color: GAME_COLORS.BOSS_3_CORE, damage: BOSS_3_STATS.corruptionWaveDamage * nightmareDamageMultiplier, ownerId: boss.id, lifetime: 8000, type: 'corruption_wave'});
                                            boss.lastAttackTime.corruptionWave = now;
                                        }
                                        
                                        if(boss.phase === 2) {
                                            if (now > (boss.lastAttackTime.hostileTakeover || 0) + BOSS_3_STATS.hostileTakeoverRate) {
                                                const isHorizontal = Math.random() > 0.5;
                                                const lineCount = isHorizontal ? 9 : 12;
                                                const lineIndex = Math.floor(Math.random() * lineCount);
                                                const linePosition = lineIndex * 150 + 75;
                                                draft.bossAttacks.push({ type: BossAttackType.HOSTILE_TAKEOVER, id: `bus-${now}`, line: linePosition, isHorizontal, creationTime: now, warningDuration: BOSS_3_STATS.busWarnTime, fireDuration: BOSS_3_STATS.busFireDuration, damage: BOSS_3_STATS.busDamage * nightmareDamageMultiplier });
                                                boss.lastAttackTime.hostileTakeover = now;
                                            }
                                            if (now > (boss.lastAttackTime.corruptedPuddle || 0) + BOSS_3_STATS.phase2CorruptedPuddleRate) {
                                                SoundManager.play('corruptedZoneAppear');
                                                const zoneCount = 7;
                                                for (let i = 0; i < zoneCount; i++) {
                                                    draft.corruptedZones.push({
                                                        id: `czone-b3-${now}-${i}`,
                                                        position: getRandomCanvasPosition(),
                                                        radius: BOSS_3_STATS.phase2CorruptedPuddleRadius,
                                                        creationTime: now,
                                                        duration: BOSS_3_STATS.phase2CorruptedPuddleDuration,
                                                        damage: BOSS_3_STATS.phase2CorruptedPuddleDamage * nightmareDamageMultiplier,
                                                        damageInterval: BOSS_3_STATS.phase2CorruptedPuddleDamageInterval,
                                                        lastDamageTime: 0
                                                    });
                                                }
                                                boss.lastAttackTime.corruptedPuddle = now;
                                            }
                                            if (now > (boss.lastAttackTime.staticZone || 0) + BOSS_3_STATS.staticZoneRate) {
                                                for (let i = 0; i < BOSS_3_STATS.staticZoneCount; i++) {
                                                    draft.bossAttacks.push({ type: BossAttackType.STATIC_ZONE, id: `static-${now}-${i}`, position: getRandomCanvasPosition(), creationTime: now, duration: BOSS_3_STATS.staticZoneDuration, radius: BOSS_3_STATS.staticZoneRadius });
                                                }
                                                boss.lastAttackTime.staticZone = now;
                                            }
                                        }
                                    } else { 
                                        if (now > boss.vulnerableEndTime) {
                                            draft.ramSockets.forEach(s => s.isCorrupted = true);
                                            SoundManager.play('bossPhaseChange');
                                            draft.bossAttacks = [];
                                        }
                                    }
                                } else { 
                                    boss.position = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                                    boss.phase3AuraRadius += BOSS_3_STATS.phase3AuraExpandRate * deltaTime;
                                    if (now > boss.lastPhase3AuraDamageTime + BOSS_3_STATS.phase3AuraDamageTick) {
                                        if(calculateDistance(boss.position, draft.player.position) < boss.phase3AuraRadius && !draft.player.isDashing && !draft.player.overdriveActive) { 
                                            draft.player.health -= BOSS_3_STATS.phase3AuraDamage * nightmareDamageMultiplier * (1 - finalPlayerDamageReduction);
                                            if(draft.player.health <=0) { draft.player.health = 0; handleGameOverWithStats(); }
                                        }
                                        boss.lastPhase3AuraDamageTime = now;
                                    }
                                    if (now > (boss.lastAttackTime.phase3Bus || 0) + BOSS_3_STATS.phase3BusOverloadRate) {
                                        const isHorizontal = Math.random() > 0.5;
                                        const lineCount = isHorizontal ? 9 : 12;
                                        const lineIndex1 = Math.floor(Math.random() * lineCount);
                                        let lineIndex2 = Math.floor(Math.random() * lineCount);
                                        while(lineIndex2 === lineIndex1) lineIndex2 = Math.floor(Math.random() * lineCount);
                                        
                                        draft.bossAttacks.push({ type: BossAttackType.HOSTILE_TAKEOVER, id: `bus-p3-${now}-1`, line: lineIndex1 * 150 + 75, isHorizontal, creationTime: now, warningDuration: 700, fireDuration: 500, damage: BOSS_3_STATS.busDamage * nightmareDamageMultiplier });
                                        draft.bossAttacks.push({ type: BossAttackType.HOSTILE_TAKEOVER, id: `bus-p3-${now}-2`, line: lineIndex2 * 150 + 75, isHorizontal, creationTime: now, warningDuration: 700, fireDuration: 500, damage: BOSS_3_STATS.busDamage * nightmareDamageMultiplier });
                                        boss.lastAttackTime.phase3Bus = now;
                                    }
                                    if (now > (boss.lastAttackTime.phase3Volatile || 0) + BOSS_3_STATS.phase3VolatileMemoryRate) {
                                        for (let i = 0; i < 2; i++) {
                                            draft.acidPuddles.push({
                                                id: `puddle-boss-${now}-${i}`, position: getRandomCanvasPosition(), radius: 110,
                                                damagePerTick: BOSS_3_STATS.phase3VolatilePuddleDamage * nightmareDamageMultiplier, tickRate: 250,
                                                lastTickTime: now, endTime: now + BOSS_3_STATS.phase3VolatilePuddleDuration,
                                                ownerId: boss.id, color: GAME_COLORS.BOSS_3_AURA,
                                            });
                                        }
                                        boss.lastAttackTime.phase3Volatile = now;
                                    }
                                    if (now > (boss.lastAttackTime.finalJudgement || 0) + BOSS_3_STATS.phase3FinalJudgementRate) {
                                        for(let i = 0; i < 36; i++) {
                                            const angle = (i * 10) * (Math.PI/180);
                                            const velocity = { x: Math.cos(angle) * 350, y: Math.sin(angle) * 350 };
                                            draft.projectiles.push({ id: `bproj3-judgement-${now}-${i}`, position: { ...boss.position }, velocity, size: 20, color: GAME_COLORS.BOSS_3_BUS_FIRE, damage: 30 * nightmareDamageMultiplier, ownerId: boss.id, lifetime: 6000 });
                                        }
                                        boss.lastAttackTime.finalJudgement = now;
                                    }
                                }

                                if (boss.phase === 1 && boss.health / boss.maxHealth < BOSS_3_STATS.phase2HealthThreshold) {
                                    boss.phase = 2;
                                    SoundManager.play('bossPhaseChange');
                                    if(!isInvulnerableThisTick) boss.vulnerableEndTime = 0; 
                                    draft.ramSockets.forEach(s => s.isCorrupted = true);
                                    draft.bossAttacks = [];
                                } else if(boss.phase === 2 && boss.health / boss.maxHealth < BOSS_3_STATS.phase3HealthThreshold) {
                                    boss.phase = 3;
                                    boss.isInvulnerable = false;
                                    SoundManager.play('bossPhaseChange');
                                    draft.ramSockets = [];
                                    draft.bossAttacks = [];
                                }
                            }
                            else if(boss.bossType === 'hivemind_nexus') {
                                const nightmareDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                
                                if (boss.phase === 1 && activeShieldNodesCount === 0) {
                                    boss.phase = 2; SoundManager.play('bossPhaseChange'); boss.isInvulnerable = false;
                                    boss.lastAttackTime = {};
                                } else if (boss.phase === 2 && boss.health / boss.maxHealth < BOSS_4_STATS.phase3HealthThreshold) {
                                    boss.phase = 3; SoundManager.play('bossPhaseChange');
                                    boss.position = { x: CANVAS_WIDTH/2, y: CANVAS_HEIGHT/2 };
                                    boss.lastAttackTime = {};
                                }

                                if (boss.phase === 1) {
                                    if (now > (boss.lastAttackTime.dosWave || 0) + BOSS_4_STATS.dosWaveRate) {
                                        draft.particles.push({ id: `b4-wave-${now}`, type: 'boss_pulse', position: {...boss.position}, radius: 0, targetRadius: CANVAS_WIDTH, color: GAME_COLORS.BOSS_4_DOS_WAVE, life: 1500, initialLife: 1500, size: 0, damage: BOSS_4_STATS.dosWaveDamage * nightmareDamageMultiplier, ownerId: boss.id });
                                        boss.lastAttackTime.dosWave = now;
                                    }
                                } else if (boss.phase === 2) {
                                    if (now > (boss.lastAttackTime.packetFlood || 0) + BOSS_4_STATS.packetFloodRate) {
                                        for (let i = 0; i < 32; i++) {
                                            const angle = (i/32) * Math.PI*2;
                                            draft.projectiles.push({ id: `b4-packet-${now}-${i}`, position: {...boss.position}, velocity: { x: Math.cos(angle)*250, y: Math.sin(angle)*250 }, size: 12, color: GAME_COLORS.BOSS_PROJECTILE_PHASE2, damage: 15 * nightmareDamageMultiplier, ownerId: boss.id, lifetime: 5000 });
                                        }
                                        boss.lastAttackTime.packetFlood = now;
                                    }
                                    if (now > (boss.lastAttackTime.quarantine || 0) + BOSS_4_STATS.quarantineRate) {
                                        draft.corruptedZones.push({ id: `b4-qzone-${now}`, position: {...draft.player.position}, radius: 120, creationTime: now, duration: 4000, damage: BOSS_4_STATS.quarantineDamage * nightmareDamageMultiplier, damageInterval: 250, lastDamageTime: 0, color: 'rgba(255, 71, 87, 0.4)' });
                                        boss.lastAttackTime.quarantine = now;
                                    }
                                } else if (boss.phase === 3) {
                                    boss.arenaShrinkAmount += BOSS_4_STATS.arenaShrinkRate * deltaTime;
                                    if (draft.player.position.x < boss.arenaShrinkAmount || draft.player.position.x > CANVAS_WIDTH - boss.arenaShrinkAmount || draft.player.position.y < boss.arenaShrinkAmount || draft.player.position.y > CANVAS_HEIGHT - boss.arenaShrinkAmount) {
                                        if (now - draft.player.lastHitTime > 250) {
                                            draft.player.health -= 5 * nightmareDamageMultiplier; draft.player.lastHitTime = now;
                                            if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                                        }
                                    }
                                    if (now > (boss.lastAttackTime.portScan || 0) + BOSS_4_STATS.portScanRate * 0.7) {
                                        for(let i = 0; i < BOSS_4_STATS.portScanLaserCount; i++) {
                                            draft.laserBeams.push({ id: `b4-laser-${now}-${i}`, chargeStartTime: now, fireStartTime: now + 800, endTime: now + 800 + 1200, angle: Math.random() * Math.PI * 2, lastHitTime: 0, damage: BOSS_4_STATS.portScanDamage * nightmareDamageMultiplier });
                                        }
                                        boss.lastAttackTime.portScan = now;
                                    }
                                }
                            }
                        }

                        (draft.bossShieldNodes || []).forEach(node => {
                                node.vulnerabilityFactor = 1; node.statusEffects = node.statusEffects.filter(effect => { if (now > effect.startTime + effect.duration) return false; if(effect.type === StatusEffectType.VULNERABILITY) node.vulnerabilityFactor = Math.max(node.vulnerabilityFactor, effect.magnitude || 1.2); return true; });
                                if (node.health > 0) {
                                    if(!bossIsFrozen){
                                        const orbitSpeed = boss.bossType === 'guardian' ? BOSS_SHIELD_NODE_STATS.orbitSpeed : BOSS_2_SUB_ROUTINE_STATS.orbitSpeed;
                                        node.angle += orbitSpeed * (60 * deltaTime);
                                    }
                                    const orbitRadius = boss.bossType === 'guardian' ? BOSS_SHIELD_NODE_STATS.orbitRadius : BOSS_2_SUB_ROUTINE_STATS.orbitRadius;
                                    node.position.x = boss.position.x + Math.cos(node.angle) * orbitRadius; node.position.y = boss.position.y + Math.sin(node.angle) * orbitRadius;
                                    if (boss.bossType === 'sincronizador' && now - (node.lastShotTime || 0) > BOSS_2_SUB_ROUTINE_STATS.projectileFireRate) {
                                        const projectileDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                        const dirToPlayer = normalizeVector({ x: draft.player.position.x - node.position.x, y: draft.player.position.y - node.position.y });
                                        draft.projectiles.push({ id: `subroutine-proj-${node.id}-${now}`, position: { ...node.position }, velocity: { x: dirToPlayer.x * BOSS_2_SUB_ROUTINE_STATS.projectileSpeed, y: dirToPlayer.y * BOSS_2_SUB_ROUTINE_STATS.projectileSpeed }, size: BOSS_2_SUB_ROUTINE_STATS.projectileSize, color: GAME_COLORS.BOSS_2_SUB_ROUTINE, damage: BOSS_2_SUB_ROUTINE_STATS.projectileDamage * projectileDamageMultiplier, ownerId: boss.id, lifetime: 4000, type: 'boss_subroutine_shot' });
                                        node.lastShotTime = now;
                                    }
                                }
                            });
                            
                        if (boss.bossType === 'guardian') {
                            if (boss.phase === 1 && activeShieldNodesCount === 0) { boss.phase = 2; SoundManager.play('bossPhaseChange'); boss.isInvulnerable = false; boss.lastCorruptedZoneTime = now; boss.lastGlitchMinionSpawnTime = now; boss.lastPhase2AttackTime = now; for(let i=0; i<70; ++i) draft.particles.push({ id: `p-bossphase2-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*300, y: (Math.random()-0.5)*300 }, size: Math.random()*4+3, color: GAME_COLORS.ENEMY_GLITCH_MINION, life: Math.random() * 120 + 90 }); draft.projectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id || p.type === 'firewall_shard'); } 
                            else if (boss.phase === 2 && boss.health / boss.maxHealth < BOSS_PHASE_HEALTH_THRESHOLDS.PHASE_3) { boss.phase = 3; SoundManager.play('bossPhaseChange'); boss.lastDataStreamAttackTime = now; boss.lastKernelPanicPulseTime = now; boss.kernelPanicChargeStartTime = 0; for(let i=0; i<100; ++i) draft.particles.push({ id: `p-bossphase3-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*400, y: (Math.random()-0.5)*400 }, size: Math.random()*5+4, color: GAME_COLORS.PROJECTILE_DATA_STREAM, life: Math.random() * 150 + 100 }); draft.projectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id || p.type === 'firewall_shard'); }
                        } else if (boss.bossType === 'sincronizador') {
                            if (boss.phase === 1 && activeShieldNodesCount === 0) { boss.phase = 2; SoundManager.play('bossPhaseChange'); boss.isInvulnerable = false; boss.lastLaserTime = now + 2000; boss.lastDataWallTime = now; for(let i=0; i<80; ++i) draft.particles.push({ id: `p-b2phase2-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*350, y: (Math.random()-0.5)*350 }, size: Math.random()*4+3, color: GAME_COLORS.BOSS_2_CORE, life: Math.random() * 130 + 90 }); }
                            else if (boss.phase === 2 && boss.health / boss.maxHealth < BOSS_2_STATS.phase3HealthThreshold) { boss.phase = 3; SoundManager.play('bossPhaseChange'); boss.lastMinionSpawnTime = now; }
                        }

                        draft.particles.forEach(particle => {
                            if (particle.ownerId === boss.id && !draft.player.isDashing && !draft.player.overdriveActive) {
                                if (particle.type === 'boss_pulse' && particle.radius && particle.life > 0) {
                                    const distToPlayer = calculateDistance(draft.player.position, particle.position);
                                    const waveWidth = 20;
                                    if (distToPlayer > particle.radius - waveWidth && distToPlayer < particle.radius + waveWidth) {
                                        if (now - draft.player.lastHitTime > 500) {
                                            let damageTaken = (particle.damage || 0) * (1 - finalPlayerDamageReduction);
                                            draft.player.health -= damageTaken;
                                            if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                            draft.player.lastHitTime = now;
                                            SoundManager.play('playerHit');
                                            if (draft.player.health <= 0) {
                                                draft.player.health = 0;
                                                handleGameOverWithStats();
                                            }
                                        }
                                    }
                                }
                            }
                        });

                        if (boss.health <= 0) {
                            sessionStatsRef.current.defeatedBosses.add(boss.bossType);
                            onStageClearCallback(draft.stage, draft.isNightmareMode);
                            draft.boss = null; 
                            draft.bossShieldNodes = []; 
                            draft.corruptedZones = []; 
                            draft.dataWalls = []; 
                            draft.laserBeams = []; 
                            draft.ramSockets = []; 
                            draft.bossAttacks = [];
                            draft.enemies = draft.enemies.filter(e => e.type !== EnemyType.GLITCH_MINION); 
                            SoundManager.play('enemyDie');  
                            const rewardPosition = { ...boss.position };
                            for (let i = 0; i < 2; ++i) {
                                draft.knowledgeOrbs.push({
                                    id: `k-orb-boss-${now}-${i}`,
                                    position: { x: rewardPosition.x + (Math.random() - 0.5) * 50, y: rewardPosition.y + (Math.random() - 0.5) * 50 },
                                    size: 25,
                                });
                            }
                            for(let i=0; i<150; ++i) draft.particles.push({ id: `p-bossdeath-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*350, y: (Math.random()-0.5)*350 }, size: Math.random()*5+3, color: boss.color, life: Math.random() * 180 + 120 });
                        }
                    }
                    
                    draft.laserBeams = draft.laserBeams.filter(laser => {
                        if (now >= laser.fireStartTime && now < laser.endTime) {
                            const laserRotationSpeed = BOSS_2_STATS.laserRotationSpeed * (draft.boss?.phase === 3 ? 1.5 : 1);
                            laser.angle += laserRotationSpeed * (60 * deltaTime);
                            const laserDir = { x: Math.cos(laser.angle), y: Math.sin(laser.angle) };
                            const playerToBoss = { x: draft.player.position.x - (draft.boss?.position?.x || 0), y: draft.player.position.y - (draft.boss?.position?.y || 0) };
                            const distToLaserLine = Math.abs(playerToBoss.x * laserDir.y - playerToBoss.y * laserDir.x);
                            if (distToLaserLine < (BOSS_2_STATS.laserWidth / 2 + draft.player.size / 2)) {
                                    if (now - (laser.lastHitTime || 0) > 250 && !draft.player.overdriveActive && !draft.player.isDashing) {
                                    let damageTaken = (laser.damage || 0) * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                                    draft.player.health -= damageTaken;
                                    if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                    sessionStatsRef.current.damageTaken += damageTaken;
                                    if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                    laser.lastHitTime = now; SoundManager.play('playerHit');
                                    if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                                    }
                            }
                        }
                        return now < laser.endTime;
                    });
                    draft.dataWalls.forEach(wall => {
                        wall.position.x += wall.velocity.x * deltaTime; wall.position.y += wall.velocity.y * deltaTime;
                        const playerRect = { x: draft.player.position.x - draft.player.size / 2, y: draft.player.position.y - draft.player.size / 2, width: draft.player.size, height: draft.player.size };
                        const wallRect = { x: wall.position.x, y: wall.position.y, width: wall.width, height: wall.height };
                        if (playerRect.x < wallRect.x + wallRect.width && playerRect.x + playerRect.width > wallRect.x && playerRect.y < wallRect.y + wallRect.height && playerRect.y + playerRect.height > wallRect.y) {
                            if (now - draft.player.lastHitTime > 500 && !draft.player.overdriveActive && !draft.player.isDashing) {
                                const damageTaken = (wall.damage || 0) * (1 - finalPlayerDamageReduction);
                                draft.player.health -= damageTaken; 
                                if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                sessionStatsRef.current.damageTaken += damageTaken;
                                if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                            }
                        }
                    });
                    draft.dataWalls = draft.dataWalls.filter(wall => wall.position.x > -wall.width && wall.position.x < CANVAS_WIDTH && wall.position.y > -wall.height && wall.position.y < CANVAS_HEIGHT);
                    draft.corruptedZones = draft.corruptedZones.filter(zone => { if (now > zone.creationTime + zone.duration) return false; if (calculateDistance(draft.player.position, zone.position) < zone.radius + draft.player.size / 2) { if (now - (zone.lastDamageTime || 0) > zone.damageInterval) { if (!draft.player.overdriveActive && !draft.player.isDashing) { 
                        const damageTaken = zone.damage * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                        draft.player.health -= damageTaken; 
                        if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                        sessionStatsRef.current.damageTaken += damageTaken;
                        if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                        SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } zone.lastDamageTime = now; } } return true; });
                    
                    const finalCooldownModifier = draft.player.cooldownModifier * playerCooldownMultiplier;
                    const finalDamageMultiplier = draft.player.globalDamageFactor * draft.player.overdriveDamageBonusFactor * playerDamageMultiplier;
                    
                    const applyCritDamage = (baseDamage, target) => {
                        let finalDamage = baseDamage;
                        const isCrit = Math.random() < draft.player.critChance;
                        
                        if (isCrit) {
                            finalDamage *= draft.player.critDamage;
                            draft.particles.push({ id: `crit-${target.id}-${now}`, type: 'crit_text', position: { ...target.position }, velocity: {x: 0, y: -80}, life: 500, text: 'CRÍTICO!', color: GAME_COLORS.CRITICAL_HIT_TEXT, size: 20 });

                            const aniquilacaoLevel = permanentBuffs.shop?.capstone_offense || 0;
                            if (aniquilacaoLevel > 0) {
                                const explosionRadius = 60;
                                const explosionDamage = finalDamage * 0.30;
                                
                                draft.particles.push({ id: `crit-explosion-${target.id}-${now}`, type: 'aegis_pulse', position: { ...target.position }, radius: 0, targetRadius: explosionRadius, color: 'rgba(255, 193, 7, 0.7)', life: 200, size: 0 });

                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss ? [draft.boss] : [])].forEach(nearbyEnemy => {
                                    if (nearbyEnemy.id !== target.id && nearbyEnemy.health > 0) {
                                        if (calculateDistance(target.position, nearbyEnemy.position) < explosionRadius) {
                                            let finalExplosionDamage = explosionDamage * (nearbyEnemy.vulnerabilityFactor || 1);
                                            if (nearbyEnemy.type === EnemyType.SEGMENTO_FALHA && nearbyEnemy.isShielded) { finalExplosionDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                            nearbyEnemy.health -= finalExplosionDamage;
                                            sessionStatsRef.current.damageDealtByWeapon['capstone_offense'] = (sessionStatsRef.current.damageDealtByWeapon['capstone_offense'] || 0) + finalExplosionDamage;
                                        }
                                    }
                                });
                            }
                        }
                        return finalDamage;
                    };

                    draft.player.weapons.forEach(w => {
                        const weaponBaseId = w.originalBaseWeaponId || w.id.split('_')[0];
                        const weaponMastery = weaponMasteryStats[weaponBaseId];
                        let masteryDamageMultiplier = 1.0;
                        let masterySpeedMultiplier = 1.0;
                        if (weaponMastery) {
                            masteryDamageMultiplier += weaponMastery.damage_multiplier || 0;
                            masterySpeedMultiplier += weaponMastery.projectile_speed || 0;
                        }
                        const weaponFinalDamageMultiplier = finalDamageMultiplier * masteryDamageMultiplier;

                        if (w.isEvolved && !sessionStatsRef.current.evolvedWeapons.has(w.id)){
                            sessionStatsRef.current.evolvedWeapons.add(w.id);
                            sessionStatsRef.current.evolvedWeaponIds.add(w.evolutionId);
                        }
                        if ((w.id === 'antivirus' || w.id === 'antivirus_system_purge' || w.id === 'antivirus_hunter_swarm' || w.id === 'antivirus_tesla_coil') && w.lastShotTime !== undefined) {
                            let fireRate = ANTIVIRUS_SCAN_STATS.fireRate * Math.pow(0.85, ownedUpgradesRef.current.get('antivirus_rate') || 0);
                            if (w.id === 'antivirus_system_purge') fireRate *= 1.1; if (w.id === 'antivirus_hunter_swarm') fireRate *= 1.2; if (w.id === 'antivirus_tesla_coil') fireRate *= 0.95;
                            if (now - w.lastShotTime > fireRate * finalCooldownModifier && (draft.enemies.length > 0 || (draft.boss && draft.bossShieldNodes.some(n => n.health > 0)) || (draft.boss && !draft.boss.isInvulnerable) )) {
                                let closestTarget = null; let minDistance = Infinity; const potentialTargets = []; if (draft.boss && draft.boss.isInvulnerable) potentialTargets.push(...draft.bossShieldNodes.filter(n => n.health > 0)); else if (draft.boss) potentialTargets.push(draft.boss); potentialTargets.push(...draft.enemies.filter(e => e.isCurrentlyVisible !== false && e.health > 0)); potentialTargets.forEach(target => { const distance = calculateDistance(target.position, draft.player.position); if (distance < minDistance) { minDistance = distance; closestTarget = target; } });
                                if (closestTarget) {
                                    SoundManager.play('shoot');
                                    const baseDirection = normalizeVector({ x: closestTarget.position.x - draft.player.position.x, y: closestTarget.position.y - draft.player.position.y });
                                    let projectileDamage = (ANTIVIRUS_SCAN_STATS.damage + 8 * (ownedUpgradesRef.current.get('antivirus_damage') || 0)) * weaponFinalDamageMultiplier;
                                    if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && closestTarget.health === closestTarget.maxHealth) { projectileDamage *= 1.25; }
                                    const pierceCount = ownedUpgradesRef.current.get('antivirus_pierce') || 0;
                                    let projectileSize = ANTIVIRUS_SCAN_STATS.projectileSize;
                                    let currentProjectileBaseSpeed = ANTIVIRUS_SCAN_STATS.projectileSpeed * (draft.player.projectileSpeedModifier || 1.0) * masterySpeedMultiplier;
                                    let projectileAppliesStatus = null; 
                                    const cryoLevel = ownedUpgradesRef.current.get('antivirus_cryo_rounds') || 0; 
                                    if (cryoLevel > 0) {
                                        if (cryoLevel >= 4) {
                                            projectileAppliesStatus = { type: StatusEffectType.FREEZE, chance: 0.15, duration: STATUS_EFFECT_PARAMS[StatusEffectType.FREEZE].baseDuration, sourceId: 'antivirus_cryo_rounds_freeze' };
                                        } else {
                                            projectileAppliesStatus = { type: StatusEffectType.SLOW, chance: 0.20 + cryoLevel * 0.05, duration: STATUS_EFFECT_PARAMS[StatusEffectType.SLOW].baseDuration, magnitude: STATUS_EFFECT_PARAMS[StatusEffectType.SLOW].baseMagnitude - (cryoLevel-1) * 0.05, sourceId: 'antivirus_cryo_rounds' };
                                        }
                                    }
                                    let projectileChainLightning = null; if (w.id === 'antivirus_tesla_coil') { projectileChainLightning = { maxChains: STATUS_EFFECT_PARAMS.CHAIN_LIGHTNING.baseMaxChains + 1, range: STATUS_EFFECT_PARAMS.CHAIN_LIGHTNING.baseRange + 25, damageMultiplierPerChain: STATUS_EFFECT_PARAMS.CHAIN_LIGHTNING.baseDamageMultiplier, color: GAME_COLORS.PROJECTILE_CHAIN_LIGHTNING, currentChainHits: 0 }; }
                                    
                                    const firstShotCritMastery = weaponMastery?.first_shot_crit;
                                    
                                    const createProjectile = (extraProps = {}) => {
                                        const proj = { id: `proj-${w.id}-${now}-${Math.random()}`, position: { ...draft.player.position }, baseSpeed: currentProjectileBaseSpeed, velocity: { x: baseDirection.x * currentProjectileBaseSpeed, y: baseDirection.y * currentProjectileBaseSpeed }, size: projectileSize, color: GAME_COLORS.PROJECTILE, damage: projectileDamage, ownerId: draft.player.id, pierceCount, hitEnemyIds: [], lifetime: 3000, type: 'antivirus_shot', appliesStatus: projectileAppliesStatus, chainLightning: projectileChainLightning, hitEnemyIdsChain: [], weaponBaseId, ...extraProps };
                                        if (firstShotCritMastery) {
                                            proj.isFirstShotCrit = true;
                                        }
                                        return proj;
                                    };
                                    
                                    if (w.id === 'antivirus_system_purge') {
                                        projectileDamage += ANTIVIRUS_SCAN_STATS.systemPurgeDamageBonus;
                                        projectileSize *= ANTIVIRUS_SCAN_STATS.systemPurgeSizeMultiplier;
                                        const totalSpread = ANTIVIRUS_SCAN_STATS.systemPurgeSpreadAngle;
                                        const angleBetweenShots = ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot > 1 ? totalSpread / (ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot -1) : 0;
                                        const startAngle = Math.atan2(baseDirection.y, baseDirection.x) - (ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot > 1 ? totalSpread / 2 : 0);
                                        for (let i = 0; i < ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot; i++) {
                                            const currentAngle = startAngle + (i * angleBetweenShots);
                                            const direction = { x: Math.cos(currentAngle), y: Math.sin(currentAngle) };
                                            draft.projectiles.push(createProjectile({ id: `proj-${w.id}-${now}-${i}`, velocity: { x: direction.x * currentProjectileBaseSpeed, y: direction.y * currentProjectileBaseSpeed }, color: GAME_COLORS.PROJECTILE_SYSTEM_PURGE, type: 'antivirus_system_purge_shot'}));
                                        }
                                    } else if (w.id === 'antivirus_hunter_swarm') {
                                        currentProjectileBaseSpeed = ANTIVIRUS_SCAN_STATS.hunterSwarmProjectileSpeed * (draft.player.projectileSpeedModifier || 1.0);
                                        projectileDamage = (ANTIVIRUS_SCAN_STATS.hunterSwarmDamage + 8 * (ownedUpgradesRef.current.get('antivirus_damage') || 0)) * weaponFinalDamageMultiplier;
                                        projectileSize *= ANTIVIRUS_SCAN_STATS.hunterSwarmSizeMultiplier;
                                        draft.projectiles.push(createProjectile({ baseSpeed: currentProjectileBaseSpeed, damage: projectileDamage, size: projectileSize, color: GAME_COLORS.PROJECTILE_HUNTER_SWARM, lifetime: 4000, type: 'antivirus_hunter_swarm_shot', isSeeking: true, targetEnemyId: closestTarget.id, appliesDot: { sourceEvolutionId: "antivirus_hunter_swarm", damagePerTick: ANTIVIRUS_SCAN_STATS.hunterSwarmDotDamagePerTick * weaponFinalDamageMultiplier, duration: ANTIVIRUS_SCAN_STATS.hunterSwarmDotDuration, tickInterval: ANTIVIRUS_SCAN_STATS.hunterSwarmDotTickInterval } }));
                                    } else {
                                        draft.projectiles.push(createProjectile({type: w.id === 'antivirus_tesla_coil' ? 'antivirus_tesla_shot' : 'antivirus_shot' }));
                                    }
                                    w.lastShotTime = now;
                                }
                            }
                        }
                        else if (w.id === 'firewall' || w.id === 'firewall_aegis_shield') {
                            const masteryRadiusMultiplier = weaponMastery?.radius_multiplier ? 1 + weaponMastery.radius_multiplier : 1;
                            const firewallRadius = FIREWALL_STATS.radius * masteryRadiusMultiplier;
                            if (w.orbs === undefined || w.currentAngle === undefined) return;
                            w.currentAngle += FIREWALL_STATS.angleSpeed * (60 * deltaTime);
                            const isAegis = w.id === 'firewall_aegis_shield';
                            if (isAegis) {
                                if (!w.lastPulseTime) w.lastPulseTime = now;
                                if (now - w.lastPulseTime >= FIREWALL_STATS.aegisPulseFrequency * finalCooldownModifier) {
                                    for (let i = 0; i < w.orbs; i++) {
                                        const angle = w.currentAngle + (i * (2 * Math.PI / w.orbs));
                                        const orbPosition = { x: draft.player.position.x + Math.cos(angle) * firewallRadius, y: draft.player.position.y + Math.sin(angle) * firewallRadius };
                                        draft.particles.push({ id: `aegis-pulse-${now}-${i}`, type: 'aegis_pulse', position: orbPosition, radius: 0, targetRadius: FIREWALL_STATS.aegisPulseRadius + (FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier / 2), color: GAME_COLORS.FIREWALL_AEGIS_PULSE, life: 300, initialLife: 300, size: 0 });
                                        [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                            if(target.health <= 0) return;
                                            const targetSize = target.bossType ? (target.bossType === 'guardian' ? target.coreSize/2 : target.size/2) : target.size/2;
                                            if (calculateDistance(target.position, orbPosition) < FIREWALL_STATS.aegisPulseRadius + (FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier / 2) + targetSize) {
                                                let pulseBaseDamage = FIREWALL_STATS.aegisPulseDamage * weaponFinalDamageMultiplier * (decompilerBonuses[target.type] || 1.0) * (target.vulnerabilityFactor || 1);
                                                let damageDealt = applyCritDamage(pulseBaseDamage, target);
                                                if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { damageDealt *= 1.25; }
                                                if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { damageDealt *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                                target.health -= damageDealt;
                                                sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + damageDealt;
                                            }
                                        });
                                    }
                                    w.lastPulseTime = now;
                                }
                            }
                            const shardLevel = ownedUpgradesRef.current.get('firewall_shards') || 0;
                            if (shardLevel > 0) {
                                let shardFrequency = FIREWALL_STATS.shardBaseFrequency / shardLevel;
                                let shardDamage = FIREWALL_STATS.shardBaseDamage * shardLevel;
                                if (isAegis) shardDamage += FIREWALL_STATS.aegisShardDamageBonus;
                                shardDamage *= weaponFinalDamageMultiplier;
                                for (let i = 0; i < w.orbs; i++) {
                                    if (!w.lastShardTimes) w.lastShardTimes = {};
                                    if (now - (w.lastShardTimes[i] || 0) > shardFrequency * finalCooldownModifier) {
                                        const angle = w.currentAngle + (i * (2 * Math.PI / w.orbs));
                                        const orbPosition = { x: draft.player.position.x + Math.cos(angle) * firewallRadius, y: draft.player.position.y + Math.sin(angle) * firewallRadius };
                                        let closestEnemy = null; let minDistance = Infinity;
                                        const potentialTargets = []; if (draft.boss && draft.boss.isInvulnerable) potentialTargets.push(...draft.bossShieldNodes.filter(n => n.health > 0)); else if (draft.boss) potentialTargets.push(draft.boss); potentialTargets.push(...draft.enemies.filter(e => e.isCurrentlyVisible !== false && e.health > 0));
                                        potentialTargets.forEach(target => {
                                            const dist = calculateDistance(target.position, orbPosition);
                                            if (dist < 150 && dist < minDistance) { minDistance = dist; closestEnemy = target; }
                                        });
                                        if (closestEnemy) {
                                            const direction = normalizeVector({ x: closestEnemy.position.x - orbPosition.x, y: closestEnemy.position.y - orbPosition.y });
                                            draft.projectiles.push({ id: `shard-${w.id}-${now}-${i}`, position: { ...orbPosition }, baseSpeed: FIREWALL_STATS.shardSpeed * (draft.player.projectileSpeedModifier || 1.0), velocity: { x: direction.x * FIREWALL_STATS.shardSpeed, y: direction.y * FIREWALL_STATS.shardSpeed }, size: FIREWALL_STATS.shardSize * (isAegis ? 1.2 : 1), color: GAME_COLORS.PROJECTILE_SHARD, damage: shardDamage, ownerId: draft.player.id, pierceCount: 0, hitEnemyIds: [], lifetime: FIREWALL_STATS.shardLifetime, type: 'firewall_shard', weaponBaseId });
                                            w.lastShardTimes[i] = now;
                                        }
                                    }
                                }
                            }
                        }
                        else if ((w.id === 'acid_virus' || w.id === 'acid_virus_pandemic') && w.lastShotTime !== undefined) {
                            const masteryDurationMultiplier = weaponMastery?.duration_multiplier ? 1 + weaponMastery.duration_multiplier : 1;
                            let cooldown = ACID_VIRUS_STATS.cooldown;
                            if (now - w.lastShotTime > cooldown * finalCooldownModifier && (draft.enemies.length > 0 || (draft.boss && draft.bossShieldNodes.some(n => n.health > 0)) || (draft.boss && !draft.boss.isInvulnerable) )) {
                                let closestTarget = null; let minDistance = Infinity;
                                const potentialTargets = []; if (draft.boss && draft.boss.isInvulnerable) potentialTargets.push(...draft.bossShieldNodes.filter(n => n.health > 0)); else if (draft.boss) potentialTargets.push(draft.boss); potentialTargets.push(...draft.enemies.filter(e => e.isCurrentlyVisible !== false && e.health > 0));
                                potentialTargets.forEach(target => { const distance = calculateDistance(target.position, draft.player.position); if (distance < minDistance) { minDistance = distance; closestTarget = target; } });
                                if(closestTarget) {
                                    SoundManager.play('acidVirusShot');
                                    const direction = normalizeVector({ x: closestTarget.position.x - draft.player.position.x, y: closestTarget.position.y - draft.player.position.y });
                                    const isEvolved = w.id === 'acid_virus_pandemic';
                                    draft.projectiles.push({
                                        id: `acid-${w.id}-${now}`,
                                        position: { ...draft.player.position },
                                        velocity: { x: direction.x * ACID_VIRUS_STATS.projectileSpeed, y: direction.y * ACID_VIRUS_STATS.projectileSpeed },
                                        size: ACID_VIRUS_STATS.projectileSize,
                                        color: GAME_COLORS.PROJECTILE_ACID_VIRUS,
                                        ownerId: draft.player.id,
                                        type: 'acid_virus_shot',
                                        isEvolved,
                                        pierceCount: isEvolved ? 2 : 0, 
                                        hitEnemyIds: [],
                                        lifetime: 3000,
                                        weaponBaseId,
                                        masteryDurationMultiplier
                                    });
                                    w.lastShotTime = now;
                                }
                            }
                        }
                        else if (w.id === 'defrag' || w.id === 'defrag_quantum_optimizer') {
                            w.comboCounter = w.comboCounter || 0;
                            let cooldown = DEFRAG_STATS.cooldown * Math.pow(0.88, ownedUpgradesRef.current.get('defrag_cooldown') || 0);
                            if (weaponMastery?.cooldown_multiplier) {
                                cooldown *= (1 + weaponMastery.cooldown_multiplier);
                            }
                            if (w.id === 'defrag_quantum_optimizer') cooldown *= 0.6;
                            
                            if (now - w.lastShotTime > cooldown * finalCooldownModifier) {
                                SoundManager.play('defragSwing');
                                
                                const isSpinAttack = w.id === 'defrag_quantum_optimizer' || (w.comboCounter >= DEFRAG_STATS.comboHitsForSpin);

                                if (isSpinAttack && w.id !== 'defrag_quantum_optimizer') {
                                    w.comboCounter = 0;
                                } else {
                                    w.comboCounter++;
                                }

                                let baseDamage = (DEFRAG_STATS.damage + 12 * (ownedUpgradesRef.current.get('defrag_damage') || 0)) * weaponFinalDamageMultiplier;
                                let arcRange = DEFRAG_STATS.range * Math.pow(1.15, ownedUpgradesRef.current.get('defrag_range') || 0) * (draft.player.projectileRangeModifier || 1);
                                let arcAngle = DEFRAG_STATS.arc;
                                let playerAngle = Math.atan2(draft.player.lastMoveDirection.y, draft.player.lastMoveDirection.x);
                                
                                if(isSpinAttack) {
                                    baseDamage *= DEFRAG_STATS.spinDamageMultiplier;
                                    arcRange *= DEFRAG_STATS.spinRangeMultiplier;
                                    arcAngle = 2 * Math.PI;
                                }

                                draft.particles.push({id: `defrag-arc-${now}`, type: 'defrag_arc', position: {...draft.player.position}, startAngle: isSpinAttack ? 0 : playerAngle - arcAngle/2, endAngle: isSpinAttack ? 2*Math.PI : playerAngle + arcAngle/2, radius: arcRange, color: GAME_COLORS.EFFECT_DEFRAG, life: 100});
                                let hitCountThisSwing = 0;
                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                    if (target.health <= 0) return;
                                    const dist = calculateDistance(draft.player.position, target.position);
                                    const targetSize = target.bossType ? target.coreSize / 2 : target.size / 2;
                                    if (dist < arcRange + targetSize) {
                                        const angleToTarget = Math.atan2(target.position.y - draft.player.position.y, target.position.x - draft.player.position.x);
                                        let angleDiff = Math.abs(playerAngle - angleToTarget);
                                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                                        
                                        if (isSpinAttack || angleDiff < arcAngle / 2) {
                                            const decompilerBonus = decompilerBonuses[target.type] || 1.0;
                                            let damageToTarget = baseDamage * decompilerBonus * (target.vulnerabilityFactor || 1);
                                            let finalDamage = applyCritDamage(damageToTarget, target);
                                            if(draft.boss && draft.boss.bossType === 'arbiter' && draft.boss.phase === 3) finalDamage *= 2;
                                            if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { finalDamage *= 1.25; }
                                            if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                            target.health -= finalDamage;
                                            sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + finalDamage;
                                            hitCountThisSwing++;
                                        }
                                    }
                                });

                                if (weaponMastery?.speed_on_cleave && hitCountThisSwing >= 3) {
                                    draft.player.temporaryBuffs.push({id: `defrag-mastery-${now}`, type: TemporaryBuffType.MOVE_SPEED, magnitude: 1.2, endTime: now + 2000, sourceId: "defrag_mastery", icon: '🏃'});
                                }
                                
                                const fragmentLevel = ownedUpgradesRef.current.get('defrag_fragments') || 0;
                                if (isSpinAttack && (fragmentLevel > 0 || w.id === 'defrag_quantum_optimizer')) {
                                    const fragmentCount = 6;
                                    const fragmentDamage = baseDamage * (0.2 + fragmentLevel * 0.05);
                                    for (let i = 0; i < fragmentCount; i++) {
                                        const angle = (i / fragmentCount) * Math.PI * 2;
                                        const direction = { x: Math.cos(angle), y: Math.sin(angle) };
                                        draft.projectiles.push({
                                            id: `defrag-frag-${now}-${i}`,
                                            position: { ...draft.player.position },
                                            velocity: { x: direction.x * 300, y: direction.y * 300 },
                                            size: 10,
                                            color: GAME_COLORS.EFFECT_DEFRAG,
                                            damage: fragmentDamage,
                                            ownerId: draft.player.id,
                                            pierceCount: fragmentLevel,
                                            hitEnemyIds: [],
                                            lifetime: 1000,
                                            type: 'defrag_fragment',
                                            weaponBaseId
                                        });
                                    }
                                }
                                w.lastShotTime = now;
                            }
                        }
                        else if (w.id === 'data_leech' || w.id === 'leech_siphon_chain') {
                            w.lastPlayerPos = w.lastPlayerPos || {...draft.player.position};
                            w.chainTargetIds = [];

                            if (now > (w.critSurgeEndTime || 0)) { w.isCriticallySurging = false; }
                            if (!w.isCriticallySurging && now - (w.lastCritCheckTime || 0) > 1000) {
                                w.lastCritCheckTime = now;
                                if (Math.random() < draft.player.critChance) {
                                    w.isCriticallySurging = true;
                                    w.critSurgeEndTime = now + 500;
                                }
                            }

                            let stillRampUpSpeed = DATA_LEECH_STATS.stillDamageRampUpTime;
                            if (weaponMastery?.still_bonus_speed) {
                                stillRampUpSpeed /= weaponMastery.still_bonus_speed;
                            }

                            const playerIsStill = calculateDistance(w.lastPlayerPos, draft.player.position) < 1;
                            if(playerIsStill) {
                                w.stillTime = Math.min(stillRampUpSpeed, (w.stillTime || 0) + deltaTime * 1000);
                            } else {
                                w.stillTime = 0;
                                w.lastPlayerPos = {...draft.player.position};
                            }
                            const stillMultiplier = 1 + ((DATA_LEECH_STATS.stillDamageMultiplierMax - 1) * (w.stillTime / stillRampUpSpeed));

                            const masteryRangeMultiplier = weaponMastery?.range_multiplier ? 1 + weaponMastery.range_multiplier : 1;
                            const range = DATA_LEECH_STATS.range * Math.pow(1.2, ownedUpgradesRef.current.get('leech_range') || 0) * masteryRangeMultiplier * (draft.player.projectileRangeModifier || 1);
                            const currentTarget = [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss ? [draft.boss] : [])].find(e => e.id === w.targetId && e.health > 0);
                            
                            if (!currentTarget || calculateDistance(draft.player.position, currentTarget.position) > range) {
                                w.targetId = null;
                                let closestTarget = null, minDistance = range;
                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(e => {
                                    if (e.isCurrentlyVisible !== false && e.health > 0) {
                                        const dist = calculateDistance(draft.player.position, e.position);
                                        if(dist < minDistance) { minDistance = dist; closestTarget = e; }
                                    }
                                });
                                if(closestTarget) {
                                    w.targetId = closestTarget.id;
                                    SoundManager.play('dataLeechConnect');
                                }
                            }

                            if(w.targetId && now - (w.lastTickTime || 0) > DATA_LEECH_STATS.tickRate) {
                                const baseDamagePerTick = (DATA_LEECH_STATS.damagePerTick + (ownedUpgradesRef.current.get('leech_damage') || 0) * 0.75);
                                let damage = baseDamagePerTick * weaponFinalDamageMultiplier * stillMultiplier;
                                
                                if(w.isCriticallySurging) {
                                    damage *= draft.player.critDamage;
                                }

                                const primaryTarget = [...draft.enemies, ...draft.bossShieldNodes, draft.boss].find(e => e && e.id === w.targetId);
                                
                                if(primaryTarget) {
                                    const decompilerBonus = decompilerBonuses[primaryTarget.type] || 1.0;
                                    let finalDamage = damage * decompilerBonus * (primaryTarget.vulnerabilityFactor || 1) * (primaryTarget.type === EnemyType.SEGMENTO_FALHA && primaryTarget.isShielded ? (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction) : 1);
                                    if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && primaryTarget.health === primaryTarget.maxHealth) { finalDamage *= 1.25; }
                                    primaryTarget.health -= finalDamage;
                                    sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + finalDamage;
                                    if((ownedUpgradesRef.current.get('leech_slow') || 0) > 0) {
                                        _applyStatusEffectToEntity(primaryTarget, {type: StatusEffectType.SLOW, duration: 200, magnitude: 0.7, sourceId: 'data_leech_slow'}, now);
                                    }

                                    let chainCount = ownedUpgradesRef.current.get('leech_chain') || 0;
                                    if (w.id === 'leech_siphon_chain') { chainCount += 4; } 

                                    if (chainCount > 0) {
                                        let potentialTargets = [...draft.enemies, ...draft.bossShieldNodes];
                                        let validChainTargets = potentialTargets
                                            .filter(e => e.id !== primaryTarget.id && e.health > 0 && e.isCurrentlyVisible !== false && calculateDistance(primaryTarget.position, e.position) < range * 0.75)
                                            .sort((a, b) => calculateDistance(primaryTarget.position, a.position) - calculateDistance(primaryTarget.position, b.position))
                                            .slice(0, chainCount);

                                        validChainTargets.forEach(chainTarget => {
                                            w.chainTargetIds.push(chainTarget.id);
                                            const chainDecompilerBonus = decompilerBonuses[chainTarget.type] || 1.0;
                                            let chainFinalDamage = damage * DATA_LEECH_STATS.chainDamageMultiplier * chainDecompilerBonus * (chainTarget.vulnerabilityFactor || 1);
                                            if (chainTarget.type === EnemyType.SEGMENTO_FALHA && chainTarget.isShielded) { chainFinalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                            chainTarget.health -= chainFinalDamage;
                                            sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + chainFinalDamage;
                                        });
                                    }
                                }
                                w.lastTickTime = now;
                            }
                        }
                    });

                    draft.alliedMinions.forEach(minion => {
                        if (now - (minion.lastAttackTime || 0) > SUB_PROCESS_MINION_STATS.attackCooldown) {
                            for (const enemy of [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])]) {
                                if (enemy.health > 0) {
                                    const targetSize = enemy.bossType ? enemy.coreSize / 2 : enemy.size / 2;
                                    if (calculateDistance(minion.position, enemy.position) < minion.size / 2 + targetSize) {
                                        const decompilerBonus = decompilerBonuses[enemy.type] || 1.0;
                                        const baseMinionDamage = minion.damage * finalDamageMultiplier * decompilerBonus * (enemy.vulnerabilityFactor || 1);
                                        const finalDamage = applyCritDamage(baseMinionDamage, enemy);
                                        if (enemy.type === EnemyType.SEGMENTO_FALHA && enemy.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                        enemy.health -= finalDamage;
                                        sessionStatsRef.current.damageDealtByWeapon['class_technomancer'] = (sessionStatsRef.current.damageDealtByWeapon['class_technomancer'] || 0) + finalDamage;
                                        minion.lastAttackTime = now;
                                        SoundManager.play('enemyHit');
                                        break; 
                                    }
                                }
                            }
                        }

                        if (now - (minion.lastDamageTakenTime || 0) > SUB_PROCESS_MINION_STATS.damageTakenCooldown) {
                            for (const enemy of draft.enemies) {
                                if (enemy.health > 0) {
                                    if (calculateDistance(minion.position, enemy.position) < minion.size / 2 + enemy.size / 2) {
                                        minion.health -= enemy.damage;
                                        minion.lastDamageTakenTime = now;
                                        for(let k=0; k<3; ++k) draft.particles.push({ id: `p-minionhit-${minion.id}-${k}`, position: { ...minion.position }, velocity: { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }, size: Math.random()*2+1, color: minion.color, life: 30 });
                                        break; 
                                    }
                                }
                            }
                        }
                    });
                
                    const isAcidVirusEvolved = draft.player.weapons.some(w => w.id === 'acid_virus_pandemic');
                    const acidVirusWeapon = draft.player.weapons.find(w => w.id.includes('acid_virus'));
                    const acidWeaponBaseId = acidVirusWeapon ? (acidVirusWeapon.originalBaseWeaponId || 'acid_virus') : null;
                    
                    draft.acidPuddles.forEach(puddle => {
                        if (now > puddle.endTime) return;
                        if(now - puddle.lastTickTime > puddle.tickRate) {
                            [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                if(target.health <= 0) return;
                                const dist = calculateDistance(puddle.position, target.position);
                                if(dist < puddle.radius + target.size / 2) {
                                    const decompilerBonus = decompilerBonuses[target.type] || 1.0;
                                    let finalDamage = puddle.damagePerTick * decompilerBonus * (target.vulnerabilityFactor || 1);
                                    if (puddle.isCritical) {
                                        finalDamage *= draft.player.critDamage;
                                    }
                                    if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                    if (draft.boss && draft.boss.bossType === 'arbiter' && draft.boss.phase === 3) { finalDamage *= 2; }
                                    if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { finalDamage *= 1.25; }
                                    target.health -= finalDamage;
                                    if(acidWeaponBaseId) sessionStatsRef.current.damageDealtByWeapon[acidWeaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[acidWeaponBaseId] || 0) + finalDamage;

                                    if(isAcidVirusEvolved) {
                                        _applyStatusEffectToEntity(target, { type: StatusEffectType.VULNERABILITY, duration: 500, magnitude: 1.25, sourceId: 'acid_virus_pandemic' }, now);
                                    } else if (puddle.appliesSlow) {
                                        _applyStatusEffectToEntity(target, { type: StatusEffectType.SLOW, duration: 500, magnitude: 0.7, sourceId: 'acid_virus_viscosity' }, now);
                                    }
                                }
                            });
                            puddle.lastTickTime = now;
                        }
                    });
                    draft.acidPuddles = draft.acidPuddles.filter(p => now < p.endTime);
                    
                    draft.bossAttacks = draft.bossAttacks.filter(attack => now < (attack.creationTime + (attack.warningDuration || 0) + (attack.fireDuration || 0) + (attack.armDuration || 0) + (attack.duration || 0 + 300)));
                    
                    draft.bossAttacks.forEach(attack => {
                        if (attack.type === BossAttackType.LOGIC_BOMB && !attack.triggered && now > attack.creationTime + attack.armDuration) {
                            if(calculateDistance(draft.player.position, attack.position) < 40) {
                                attack.triggered = true;
                                attack.detonationTime = now;
                            }
                        }
                    });

                    draft.projectiles.forEach(p => { 
                        if (p.isSeeking && p.targetEnemyId) { 
                            const target = draft.enemies.find(e => e.id === p.targetEnemyId && e.health > 0 && e.isCurrentlyVisible !== false) || (draft.boss && draft.boss.id === p.targetEnemyId && draft.boss.health > 0 && !draft.boss.isInvulnerable ? draft.boss : null) || draft.bossShieldNodes.find(n => n.id === p.targetEnemyId && n.health > 0); 
                            if (target) { 
                                const dirToTarget = normalizeVector({ x: target.position.x - p.position.x, y: target.position.y - p.position.y }); 
                                const seekSpeed = p.baseSpeed || ACID_VIRUS_STATS.pandemicSporeSpeed; 
                                p.velocity.x = (p.velocity.x * (1 - ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce)) + (dirToTarget.x * seekSpeed * ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce); 
                                p.velocity.y = (p.velocity.y * (1 - ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce)) + (dirToTarget.y * seekSpeed * ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce); 
                                const currentSpeed = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.y * p.velocity.y); 
                                if (currentSpeed > 0) { 
                                    p.velocity.x = (p.velocity.x / currentSpeed) * seekSpeed; 
                                    p.velocity.y = (p.velocity.y / currentSpeed) * seekSpeed; 
                                } 
                            } else { 
                                p.isSeeking = false; 
                            } 
                        } 
                        p.position.x += p.velocity.x * deltaTime; 
                        p.position.y += p.velocity.y * deltaTime; 
                        p.lifetime -= deltaTime * 1000; 
                    });
                    draft.projectiles = draft.projectiles.filter(p => p.position.x > -p.size && p.position.x < CANVAS_WIDTH + p.size && p.position.y > -p.size && p.position.y < CANVAS_HEIGHT + p.size && p.lifetime > 0);
                    
                    draft.particles.forEach(p => { 
                        if (p.velocity) { p.position.x += p.velocity.x * deltaTime; p.position.y += p.velocity.y * deltaTime; } 
                        p.life -= deltaTime * 1000;
                    });
                    draft.particles = draft.particles.filter(p => p.life > 0);
                    
                    [...draft.expOrbs, ...draft.healthPickups, ...draft.knowledgeOrbs].forEach(orb => {
                        if (draft.player.xpMagnetRadius > 0) { 
                            const distSqToPlayer = calculateDistanceSq(orb.position, draft.player.position); 
                            if (distSqToPlayer < draft.player.xpMagnetRadius * draft.player.xpMagnetRadius) { 
                                const dirToPlayer = normalizeVector({ x: draft.player.position.x - orb.position.x, y: draft.player.position.y - orb.position.y }); 
                                const distToPlayer = Math.sqrt(distSqToPlayer);
                                const magnetSpeedFactor = Math.max(1, (draft.player.xpMagnetRadius - distToPlayer) / draft.player.xpMagnetRadius * 3); 
                                orb.position.x += dirToPlayer.x * (draft.player.speed + 50) * magnetSpeedFactor * deltaTime; 
                                orb.position.y += dirToPlayer.y * (draft.player.speed + 50) * magnetSpeedFactor * deltaTime; 
                            } 
                        } 
                    });
                    
                    const projectilesToRemove = new Set();
                    draft.projectiles.forEach(p => {
                        if (projectilesToRemove.has(p.id)) return;
                        const weaponBaseId = p.weaponBaseId || null;
                        const firewallMastery = weaponMasteryStats['firewall'];
                        const canBlockProjectiles = firewallMastery?.projectile_block && firewallMastery?.unlocked;

                        for (const particle of draft.particles) {
                            if (p.ownerId === draft.player.id && particle.destroysProjectiles && calculateDistance(p.position, particle.position) < particle.radius) {
                                    projectilesToRemove.add(p.id);
                                    break;
                            }
                        }
                        if (projectilesToRemove.has(p.id)) return;
                            if(p.ownerId !== draft.player.id && canBlockProjectiles) {
                            const firewallWeapon = draft.player.weapons.find(w => w.id === 'firewall' || w.id === 'firewall_aegis_shield');
                            if (firewallWeapon) {
                                const orbSize = firewallWeapon.id === 'firewall_aegis_shield' ? FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier : FIREWALL_STATS.orbSize;
                                for(let i = 0; i < firewallWeapon.orbs; i++) {
                                    const angle = firewallWeapon.currentAngle + (i * (2 * Math.PI / firewallWeapon.orbs));
                                    const orbPosition = { x: draft.player.position.x + Math.cos(angle) * (FIREWALL_STATS.radius * (weaponMasteryStats['firewall']?.radius_multiplier ? 1 + weaponMasteryStats['firewall'].radius_multiplier : 1)), y: draft.player.position.y + Math.sin(angle) * (FIREWALL_STATS.radius * (weaponMasteryStats['firewall']?.radius_multiplier ? 1 + weaponMasteryStats['firewall'].radius_multiplier : 1))};
                                    if(calculateDistance(p.position, orbPosition) < p.size/2 + orbSize/2) {
                                        projectilesToRemove.add(p.id);
                                        SoundManager.play('shieldBreak');
                                        break;
                                    }
                                }
                                if(projectilesToRemove.has(p.id)) return;
                            }
                        }
                        if (p.ownerId === draft.player.id) {
                            for (const e of [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])]) {
                                if (e.health <= 0 || p.hitEnemyIds?.includes(e.id) || (e.isCurrentlyVisible === false)) continue;
                                const targetSize = e.bossType ? (e.bossType === 'guardian' ? e.coreSize : (e.bossType === 'arbiter' ? e.size / 2 : e.size)) : (e.size || 0);
                                const projectileCollisionRadiusSq = (p.size / 2 + targetSize / 2) ** 2;
                                if (calculateDistanceSq(p.position, e.position) < projectileCollisionRadiusSq) {
                                    if (p.type === 'acid_virus_shot') {
                                        SoundManager.play('acidVirusImpact');
                                        const puddleRadius = ACID_VIRUS_STATS.puddleRadius * Math.pow(1.15, ownedUpgradesRef.current.get('acid_virus_spread') || 0);
                                        const puddleDuration = (ACID_VIRUS_STATS.puddleDuration + 1000 * (ownedUpgradesRef.current.get('acid_virus_duration') || 0)) * (p.masteryDurationMultiplier || 1);
                                        const acidVirusWeapon = draft.player.weapons.find(w => w.id.includes('acid_virus'));
                                        const acidWeaponBaseId = acidVirusWeapon ? (acidVirusWeapon.originalBaseWeaponId || 'acid_virus') : null;
                                        const acidMastery = weaponMasteryStats[acidWeaponBaseId];
                                        let masteryDotMultiplier = 1.0;
                                        if (acidMastery) {
                                            masteryDotMultiplier += acidMastery.dot_damage_multiplier || 0;
                                        }
                                        const damagePerTick = (ACID_VIRUS_STATS.puddleDamagePerTick + 3 * (ownedUpgradesRef.current.get('acid_virus_potency') || 0)) * finalDamageMultiplier * masteryDotMultiplier;
                                        const appliesSlow = (ownedUpgradesRef.current.get('acid_virus_viscosity') || 0) > 0;
                                        const isCriticalPuddle = Math.random() < draft.player.critChance;
                                        
                                        draft.acidPuddles.push({
                                            id: `puddle-${p.id}-${e.id}`, position: { ...e.position }, radius: puddleRadius,
                                            damagePerTick: damagePerTick, tickRate: ACID_VIRUS_STATS.puddleTickRate,
                                            lastTickTime: now, endTime: now + puddleDuration, ownerId: p.ownerId,
                                            isEvolved: p.isEvolved, appliesSlow: appliesSlow && !p.isEvolved,
                                            isCritical: isCriticalPuddle,
                                        });
                                        if (acidMastery?.armor_shred && e.statusEffects) {
                                                _applyStatusEffectToEntity(e, { type: StatusEffectType.VULNERABILITY, duration: 4000, magnitude: 1 + acidMastery.armor_shred, sourceId: 'acid_virus_mastery' }, now);
                                        }

                                        p.hitEnemyIds.push(e.id);
                                        if ((p.pierceCount || 0) <= 0) { projectilesToRemove.add(p.id); } else { p.pierceCount--; }
                                    } else if (p.type === 'acid_spore') {
                                        SoundManager.play('acidVirusImpact');
                                        const puddleRadius = ACID_VIRUS_STATS.puddleRadius * Math.pow(1.15, ownedUpgradesRef.current.get('acid_virus_spread') || 0);
                                        const puddleDuration = ACID_VIRUS_STATS.puddleDuration + 1000 * (ownedUpgradesRef.current.get('acid_virus_duration') || 0);
                                        const damagePerTick = (ACID_VIRUS_STATS.puddleDamagePerTick + 3 * (ownedUpgradesRef.current.get('acid_virus_potency') || 0)) * finalDamageMultiplier;
                                        const isCriticalPuddle = Math.random() < draft.player.critChance;

                                        draft.acidPuddles.push({
                                            id: `puddle-spore-${p.id}-${e.id}`, position: { ...e.position }, radius: puddleRadius,
                                            damagePerTick: damagePerTick, tickRate: ACID_VIRUS_STATS.puddleTickRate,
                                            lastTickTime: now, endTime: now + puddleDuration, ownerId: p.ownerId,
                                            isEvolved: true, appliesSlow: false, isCritical: isCriticalPuddle,
                                        });
                                        projectilesToRemove.add(p.id);
                                    } else { 
                                        const decompilerBonus = decompilerBonuses[e.type] || 1.0;
                                        let damageDealt = p.damage * decompilerBonus * (e.vulnerabilityFactor || 1);
                                        
                                        if (p.isFirstShotCrit && !draft.player.weapons.find(w => w.id === 'antivirus')?.hitTargetsThisShot?.has(e.id)) {
                                            damageDealt *= draft.player.critDamage;
                                            const avWeapon = draft.player.weapons.find(w => w.id === 'antivirus');
                                            if (avWeapon) {
                                                if (!avWeapon.hitTargetsThisShot) avWeapon.hitTargetsThisShot = new Set();
                                                avWeapon.hitTargetsThisShot.add(e.id);
                                            }
                                        } else {
                                            damageDealt = applyCritDamage(damageDealt, e);
                                        }
                                        
                                        if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && e.health === e.maxHealth) { damageDealt *= 1.25; }
                                        if (e.type === EnemyType.SEGMENTO_FALHA && e.isShielded) { damageDealt *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                        if (draft.boss && draft.boss.bossType === 'arbiter' && draft.boss.phase === 3) { damageDealt *= 2; }
                                        e.health -= damageDealt;
                                        if (weaponBaseId) sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + damageDealt;
                                        SoundManager.play('enemyHit');
                                        if(p.appliesStatus && Math.random() < (p.appliesStatus.chance || 1)) { _applyStatusEffectToEntity(e, p.appliesStatus, now); if (p.appliesStatus.type === StatusEffectType.FREEZE) SoundManager.play('freezeSound'); }
                                        if(p.appliesDot && e.dotEffects) { e.dotEffects.push({ id: `dot-${p.appliesDot.sourceEvolutionId}-${e.id}-${now}`, sourceEvolutionId: p.appliesDot.sourceEvolutionId, damagePerTick: p.appliesDot.damagePerTick, ticksRemaining: Math.floor(p.appliesDot.duration / p.appliesDot.tickInterval), tickInterval: p.appliesDot.tickInterval, lastTickTime: now, }); }
                                        p.hitEnemyIds.push(e.id);
                                        let shouldProjectileBeRemoved = false;
                                        if (p.chainLightning && (!p.chainLightning.currentChainHits || p.chainLightning.currentChainHits < p.chainLightning.maxChains)) {
                                            const currentChainHits = p.chainLightning.currentChainHits || 0;
                                            const potentialChainTargets = draft.enemies.filter(nextE => nextE.health > 0 && nextE.id !== e.id && !(p.hitEnemyIdsChain || []).includes(nextE.id) && calculateDistance(e.position, nextE.position) < p.chainLightning.range).sort((a,b) => calculateDistance(e.position, a.position) - calculateDistance(e.position, b.position));
                                            
                                            if (potentialChainTargets.length > 0) {
                                                SoundManager.play('chainLightningSound');
                                                const nextTarget = potentialChainTargets[0];
                                                const dirToNextTarget = normalizeVector({ x: nextTarget.position.x - e.position.x, y: nextTarget.position.y - e.position.y });
                                                
                                                const nextChainHits = currentChainHits + 1;

                                                const newChainProjectile = {
                                                    ...p,
                                                    id: `proj-chain-${p.id}-${nextChainHits}-${now}-${Math.random()}`,
                                                    position: { ...e.position },
                                                    previousChainPosition: { ...e.position },
                                                    velocity: { x: dirToNextTarget.x * (p.baseSpeed || ANTIVIRUS_SCAN_STATS.projectileSpeed), y: dirToNextTarget.y * (p.baseSpeed || ANTIVIRUS_SCAN_STATS.projectileSpeed) },
                                                    damage: p.damage * Math.pow(p.chainLightning.damageMultiplierPerChain || 0.7, nextChainHits),
                                                    hitEnemyIds: [],
                                                    hitEnemyIdsChain: [...(p.hitEnemyIdsChain || []), e.id],
                                                    pierceCount: 0,
                                                    chainLightning: { ...p.chainLightning, currentChainHits: nextChainHits },
                                                    color: p.chainLightning.color || GAME_COLORS.PROJECTILE_CHAIN_LIGHTNING,
                                                    isSeeking: false,
                                                    appliesDot: null,
                                                };
                                                draft.projectiles.push(newChainProjectile);
                                            }
                                            shouldProjectileBeRemoved = true;
                                        } else {
                                            if ((p.pierceCount || 0) <= 0) shouldProjectileBeRemoved = true;
                                            else p.pierceCount--;
                                        }
                                        if (shouldProjectileBeRemoved) projectilesToRemove.add(p.id);
                                        for(let k=0; k<3; ++k) draft.particles.push({ id: `p-hit-${e.id}-${k}`, position: { ...p.position }, velocity: { x: (Math.random()-0.5)*50, y: (Math.random()-0.5)*50 }, size: Math.random()*2+1, color: e.color, life: 50 });
                                    }
                                    if (projectilesToRemove.has(p.id)) break; 
                                }
                            }
                        } else if (p.ownerId !== draft.player.id) {
                            if (p.type === 'latency_spike_shot') {
                                if (calculateDistance(p.position, draft.player.position) < p.size / 2 + draft.player.size / 2) {
                                    draft.particles.push({
                                        id: `slow-puddle-${now}`,
                                        type: 'slow_puddle',
                                        position: { ...draft.player.position },
                                        radius: 100,
                                        targetRadius: 100,
                                        life: 5000,
                                        initialLife: 5000,
                                        color: 'rgba(96, 165, 250, 0.4)'
                                    });
                                    projectilesToRemove.add(p.id);
                                }
                            } else if (!draft.player.overdriveActive && !draft.player.isDashing && calculateDistance(p.position, draft.player.position) < p.size / 2 + draft.player.size / 2) {
                                if (now - draft.player.lastHitTime > 500) {
                                    const damageTaken = (p.damage || 0) * (1 - finalPlayerDamageReduction);
                                    draft.player.health -= damageTaken;
                                    if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                    sessionStatsRef.current.damageTaken += damageTaken;
                                    if (isBossFightActive && draft.boss?.bossType && sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] !== undefined) {
                                        sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                    }
                                    draft.player.lastHitTime = now;
                                    SoundManager.play('playerHit');
                                    if (draft.player.health <= 0) {
                                        draft.player.health = 0;
                                        handleGameOverWithStats();
                                    }
                                }
                                projectilesToRemove.add(p.id);
                            }
                            if (draft.player.classId === 'class_technomancer' && draft.player.uniquePassiveData.commandMode === 'AEGIS') {
                                for(const minion of draft.alliedMinions) {
                                    if (calculateDistance(p.position, minion.position) < p.size / 2 + minion.size / 2) {
                                        minion.health -= p.damage;
                                        projectilesToRemove.add(p.id);
                                        break;
                                    }
                                }
                            }
                        }
                    });
                    if (projectilesToRemove.size > 0) {
                        draft.projectiles = draft.projectiles.filter(p => !projectilesToRemove.has(p.id));
                    }

                    if (!draft.player.overdriveActive && !draft.player.isDashing) {
                            if(draft.player.health <= 0 && draft.player.lastStandCharges > 0 && !draft.player.lastStandUsed) {
                            draft.player.lastStandUsed = true;
                            draft.player.health = draft.player.maxHealth * draft.player.lastStandHealthPercent;
                            draft.player.overdriveActive = true; 
                            let invulnDuration = 1000 + draft.player.lastStandCharges * 600;
                            if(draft.player.lastStandSpeedBoost) {
                                draft.player.temporaryBuffs.push({id: `laststand-speed-${now}`, type: TemporaryBuffType.MOVE_SPEED, magnitude: 2.0, endTime: now + invulnDuration, sourceId: "last_stand_speed"});
                            }
                            draft.player.overdriveEndTime = now + invulnDuration;
                            SoundManager.play('shieldActivate');
                        }
                        
                        draft.bossAttacks.forEach(attack => {
                            if (now - draft.player.lastHitTime < 250) return;

                            let damageDealt = false;
                            if (attack.type === BossAttackType.DATA_SMASHER && now > attack.creationTime + attack.warningDuration && !attack.hasDamaged) {
                                if(calculateDistance(draft.player.position, attack.targetPosition) < attack.radius) {
                                    draft.player.health -= attack.damage * (1 - finalPlayerDamageReduction);
                                    damageDealt = true;
                                    attack.hasDamaged = true;
                                }
                            }
                            else if (attack.type === BossAttackType.HOSTILE_TAKEOVER && now > attack.creationTime + attack.warningDuration) {
                                if(attack.isHorizontal) {
                                    if (Math.abs(draft.player.position.y - attack.line) < 15) damageDealt = true;
                                } else {
                                    if (Math.abs(draft.player.position.x - attack.line) < 15) damageDealt = true;
                                }
                                if(damageDealt) draft.player.health -= attack.damage * (1 - finalPlayerDamageReduction);
                            }
                            if(damageDealt) {
                                draft.player.lastHitTime = now; SoundManager.play('playerHit');
                                if(draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                            }
                        });

                        draft.unstableSectors.forEach(sector => { if (now > sector.endTime - 500 && now < sector.endTime) { const playerRect = { x: draft.player.position.x - draft.player.size / 2, y: draft.player.position.y - draft.player.size / 2, width: draft.player.size, height: draft.player.size }; const sectorRect = { x: sector.x, y: sector.y, width: 40, height: 40 }; if (playerRect.x < sectorRect.x + sectorRect.width && playerRect.x + playerRect.width > sectorRect.x && playerRect.y < sectorRect.y + sectorRect.height && playerRect.y + playerRect.height > sectorRect.y) { if (now - draft.player.lastHitTime > 500) { const damageTaken = 5 * (1 - finalPlayerDamageReduction); draft.player.health -= damageTaken; if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken; sessionStatsRef.current.damageTaken += damageTaken; draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } } });
                        draft.enemies.forEach(e => { if(e.health <= 0) return; const isSpywareVisible = e.type === EnemyType.SPYWARE ? e.isCurrentlyVisible : true; const collisionRadius = e.size/2 + draft.player.size/2;
                            if (isSpywareVisible && calculateDistanceSq(e.position, draft.player.position) < collisionRadius * collisionRadius) { if (now - draft.player.lastHitTime > 500) {
                            let damageTaken = e.damage * (1 - finalPlayerDamageReduction);
                            draft.player.health -= damageTaken;
                            if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                            sessionStatsRef.current.damageTaken += damageTaken;
                            if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                            draft.player.lastHitTime = now; 
                            SoundManager.play('playerHit');
                            if (draft.player.activeUniquePassiveIds.includes("passive_sentinel_retaliation")) {
                                const hasRetaliationBuff = draft.player.temporaryBuffs.some(b => b.type === TemporaryBuffType.DAMAGE_REDUCTION && b.sourceId === "passive_sentinel_retaliation");
                                if(!hasRetaliationBuff) {
                                    draft.player.temporaryBuffs.push({id: `retaliation-${now}`, type: TemporaryBuffType.DAMAGE_REDUCTION, magnitude: 0.85, endTime: now + 3000, sourceId: "passive_sentinel_retaliation"});
                                }
                            }
                            if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } const fearProtocolLevel = ownedUpgradesRef.current.get('passive_fear_protocol') || 0; if (fearProtocolLevel > 0 && Math.random() < (0.15 + fearProtocolLevel * 0.05)) { const fearEffect = { type: StatusEffectType.FEAR, duration: STATUS_EFFECT_PARAMS[StatusEffectType.FEAR].baseDuration + (fearProtocolLevel-1)*250, sourceId: 'passive_fear_protocol' }; _applyStatusEffectToEntity(e, fearEffect, now); draft.enemies.forEach(otherE => { if(otherE.id !== e.id && calculateDistance(draft.player.position, otherE.position) < 100) { _applyStatusEffectToEntity(otherE, fearEffect, now); } }); draft.particles.push({ id: `fear-burst-${now}`, position: {...draft.player.position}, radius:0, targetRadius: 100, color: GAME_COLORS.STATUS_FEAR_AURA, life: 300, initialLife: 300, type: 'fear_aura_burst' }); } } } if (e.type === EnemyType.MEMORY_LEAK && e.trail) { e.trail.forEach(segment => { if (calculateDistance(segment, draft.player.position) < ENEMY_MEMORY_LEAK_STATS.trailSize / 2 + draft.player.size / 2) { if (now - draft.player.lastHitTime > 500) {
                            let damageTaken = ENEMY_MEMORY_LEAK_STATS.trailDamage * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                            draft.player.health -= damageTaken; 
                            if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                            sessionStatsRef.current.damageTaken += damageTaken;
                            if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                            draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } }); } });
                        if (draft.boss) {
                            if (calculateDistance(draft.boss.position, draft.player.position) < (draft.boss.bossType === 'guardian' ? draft.boss.size : (draft.boss.bossType === 'arbiter' ? draft.boss.size/2 : draft.boss.size)) / 2 + draft.player.size / 2) { if (now - draft.player.lastHitTime > 500) {
                                let damageTaken = (draft.boss.damage) * (1 - finalPlayerDamageReduction);
                                draft.player.health -= damageTaken; 
                                if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                sessionStatsRef.current.damageTaken += damageTaken;
                                if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } }
                            draft.particles.forEach(particle => { if (particle.type === 'boss_pulse' && particle.radius && particle.life > 200 ) { if(calculateDistance(draft.player.position, particle.position) < particle.radius + draft.player.size/2) { if (now - draft.player.lastHitTime > 500) {
                                let damageTaken = (particle.damage || BOSS_STATS.projectilePhase1Damage) * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                                draft.player.health -= damageTaken; 
                                if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                sessionStatsRef.current.damageTaken += damageTaken;
                                if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } } else if (particle.type === 'volatile_explosion' && particle.radius) { if(calculateDistance(draft.player.position, particle.position) < particle.radius + draft.player.size/2) { if (now - (particle.lastHitTime || 0) > 500) { let damageTaken = (particle.damage || 0) * (1-finalPlayerDamageReduction); draft.player.health -= damageTaken; SoundManager.play('playerHit'); particle.lastHitTime = now; if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } } });
                        }
                    }
                    
                    const firewallWeapon = draft.player.weapons.find(w => w.id === 'firewall' || w.id === 'firewall_aegis_shield'); if (firewallWeapon && firewallWeapon.orbs && firewallWeapon.currentAngle !== undefined) { if (!firewallWeapon.orbHitCooldowns) firewallWeapon.orbHitCooldowns = {}; let baseFirewallDamage = FIREWALL_STATS.damage + 8 * (ownedUpgradesRef.current.get('firewall_damage') || 0); if (firewallWeapon.id === 'firewall_aegis_shield') baseFirewallDamage += FIREWALL_STATS.aegisContactDamageBonus; baseFirewallDamage *= finalDamageMultiplier; let firewallAppliesStatus = null; const vulnerabilityMatrixLevel = ownedUpgradesRef.current.get('firewall_vulnerability_matrix') || 0; if (vulnerabilityMatrixLevel > 0) { firewallAppliesStatus = { type: StatusEffectType.VULNERABILITY, duration: STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseDuration, magnitude: STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseMagnitude + (vulnerabilityMatrixLevel -1) * 0.05, sourceId: 'firewall_vulnerability_matrix' }; } for (let i = 0; i < firewallWeapon.orbs; i++) { const angle = firewallWeapon.currentAngle + (i * (2 * Math.PI / firewallWeapon.orbs)); const orbPosition = { x: draft.player.position.x + Math.cos(angle) * FIREWALL_STATS.radius, y: draft.player.position.y + Math.sin(angle) * FIREWALL_STATS.radius }; const orbSize = firewallWeapon.id === 'firewall_aegis_shield' ? FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier : FIREWALL_STATS.orbSize; [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => { if (target.health <= 0 || target.isCurrentlyVisible === false) return; const targetSize = target.bossType ? (target.bossType === 'guardian' ? target.coreSize/2 : target.size/2) : target.size/2; if (calculateDistance(orbPosition, target.position) < orbSize/2 + targetSize) { if (now - (firewallWeapon.orbHitCooldowns[`enemy-${target.id}-orb-${i}`] || 0) > FIREWALL_STATS.hitCooldown) { const decompilerBonus = decompilerBonuses[target.type] || 1.0; let damageToTarget = baseFirewallDamage * decompilerBonus * (target.vulnerabilityFactor || 1); let finalDamage = applyCritDamage(damageToTarget, target); if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { finalDamage *= 1.25; } if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); } target.health -= finalDamage; firewallWeapon.orbHitCooldowns[`enemy-${target.id}-orb-${i}`] = now; SoundManager.play('enemyHit'); sessionStatsRef.current.damageDealtByWeapon['firewall'] = (sessionStatsRef.current.damageDealtByWeapon['firewall'] || 0) + finalDamage; if (firewallAppliesStatus) _applyStatusEffectToEntity(target, firewallAppliesStatus, now); for(let k=0; k<2; ++k) draft.particles.push({ id: `p-fwhit-${target.id}-${k}`, position: { ...orbPosition }, velocity: { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }, size: Math.random()*1.5+1, color: GAME_COLORS.FIREWALL_ORB, life: 30 }); } } }); } }

                    draft.ramSockets.forEach(socket => { 
                        if(socket.isCorrupted) {
                            const dist = calculateDistance(draft.player.position, socket.position);
                            if (dist < RAM_SOCKET_STATS.size/2 + draft.player.size/2) { 
                                socket.cleanseProgress += (1 / RAM_SOCKET_STATS.cleanseTime) * (deltaTime * 1000);
                                if (socket.cleanseProgress >= 1) { 
                                    socket.isCorrupted = false; socket.cleanseProgress = 0; SoundManager.play('cleanseComplete');
                                    if(draft.boss && !draft.ramSockets.some(s => s.isCorrupted)) {
                                        draft.boss.vulnerableEndTime = now + BOSS_3_STATS.vulnerabilityDuration; 
                                        draft.enemies = []; SoundManager.play('bossPhaseChange');
                                    }
                                }
                            } else {
                                    socket.cleanseProgress = Math.max(0, socket.cleanseProgress - 0.5 * (deltaTime * 1000) / RAM_SOCKET_STATS.cleanseTime);
                            }
                        }
                    });

                    const expOrbsToRemove = new Set();
                    draft.expOrbs.forEach(orb => { const collectionRadius = orb.size/2 + draft.player.size/2;
                        if (calculateDistanceSq(orb.position, draft.player.position) < collectionRadius * collectionRadius) {
                            const healAmount = (draft.player.regenAmount > 0) ? draft.player.maxHealth * (0.001 * (permanentBuffs.shop?.corr_hp_multiplier || 1)) : 0;
                            if(healAmount > 0) draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + healAmount);
                            draft.experience += Math.floor(orb.value * draft.player.expModifier);
                            sessionStatsRef.current.totalXpOrbsCollected++;
                            expOrbsToRemove.add(orb.id);
                            SoundManager.play('pickupXP');
                        } 
                    });
                    if (expOrbsToRemove.size > 0) {
                        draft.expOrbs = draft.expOrbs.filter(orb => !expOrbsToRemove.has(orb.id));
                    }
                    
                    const healthPickupsToRemove = new Set();
                    draft.healthPickups.forEach(pickup => { 
                        if (calculateDistance(pickup.position, draft.player.position) < pickup.size/2 + draft.player.size/2) { 
                            draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + pickup.healAmount); 
                            healthPickupsToRemove.add(pickup.id); 
                            sessionStatsRef.current.healthPickupsCollected++;
                            SoundManager.play('pickupHealth');
                        } 
                    });
                    if(healthPickupsToRemove.size > 0) {
                        draft.healthPickups = draft.healthPickups.filter(p => !healthPickupsToRemove.has(p.id));
                    }

                    const knowledgeOrbsToRemove = new Set();
                    draft.knowledgeOrbs.forEach(orb => {
                        if (calculateDistance(orb.position, draft.player.position) < orb.size/2 + draft.player.size/2) {
                            draft.level++;
                            draft.experience = 0;
                            draft.expToNextLevel = Math.floor(draft.expToNextLevel * EXP_LEVEL_MULTIPLIER);
                            onLevelUpCallback();
                            SoundManager.play('levelUp');
                            knowledgeOrbsToRemove.add(orb.id);
                        }
                    });
                    if(knowledgeOrbsToRemove.size > 0) {
                        draft.knowledgeOrbs = draft.knowledgeOrbs.filter(orb => !knowledgeOrbsToRemove.has(orb.id));
                    }

                    const deadEnemies = draft.enemies.filter(e => e.health <= 0);
                    const newEnemiesFromDeath = [];
                    if (deadEnemies.length > 0) {
                        deadEnemies.forEach(dead => {
                            sessionStatsRef.current.kills[dead.type]++;
                            sessionStatsRef.current.totalKills++;
                            if (draft.player.hasInfiniteFury) {
                                sessionStatsRef.current.furyKillCounter = (sessionStatsRef.current.furyKillCounter || 0) + 1;
                                if (sessionStatsRef.current.furyKillCounter >= 150) {
                                    draft.player.furyStacks = (draft.player.furyStacks || 0) + 1;
                                    sessionStatsRef.current.furyKillCounter = 0;
                                }
                            }

                            const isBuffedByDataCache = draft.player.temporaryBuffs.some(b => b.icon);
                            if (isBuffedByDataCache) {
                                sessionStatsRef.current.killsWhileBuffedInSession++;
                            }
                            
                            if (draft.eventActive === 'DATA_VAULT') {
                                draft.eventKillsSoFar++;
                            }

                            const decompilerStats = JSON.parse(localStorage.getItem(DECOMPILER_STATS_KEY) || '{}');
                            decompilerStats[dead.type] = (decompilerStats[dead.type] || 0) + 1;
                            localStorage.setItem(DECOMPILER_STATS_KEY, JSON.stringify(decompilerStats));
                            
                            let xpValue = dead.expValue;
                            if (draft.player.activeUniquePassiveIds.includes('passive_corruptor_data_extraction')) {
                                const puddleEnemyWasIn = draft.acidPuddles.find(puddle => calculateDistance(dead.position, puddle.position) < puddle.radius);
                                if(puddleEnemyWasIn) {
                                    xpValue *= 1.10;
                                }
                            }

                            let shouldDropLoot = true;
                            if (dead.type === EnemyType.PROCESSO_ZUMBI && !dead.hasRevived && Math.random() < ENEMY_PROCESSO_ZUMBI_STATS.reviveChance) {
                                draft.revivingProcesses.push({ position: { ...dead.position }, reviveAt: now + ENEMY_PROCESSO_ZUMBI_STATS.reviveTime, maxHealth: dead.maxHealth });
                                shouldDropLoot = false;
                            } else if (draft.player.classId === 'class_technomancer' && dead.isConvertible && draft.alliedMinions.length < SUB_PROCESS_MINION_STATS.maxMinions && Math.random() < SUB_PROCESS_MINION_STATS.conversionChance) {
                                SoundManager.play('minionConvert');
                                const minionHealth = SUB_PROCESS_MINION_STATS.baseHealth + (draft.level * SUB_PROCESS_MINION_STATS.healthPerLevel);
                                const minionDamage = SUB_PROCESS_MINION_STATS.baseDamage + (draft.level * SUB_PROCESS_MINION_STATS.damagePerLevel);
                                draft.alliedMinions.push({
                                    id: `ally-${dead.id}`, position: {...dead.position}, size: SUB_PROCESS_MINION_STATS.size, speed: SUB_PROCESS_MINION_STATS.speed,
                                    health: minionHealth, maxHealth: minionHealth, damage: minionDamage, color: GAME_COLORS.ALLIED_MINION,
                                    targetId: null, angle: 0
                                });
                                for (let i=0; i<10; i++) draft.particles.push({ id: `p-convert-${dead.id}-${i}`, position: { ...dead.position }, velocity: { x: (Math.random()-0.5)*80, y: (Math.random()-0.5)*80 }, size: Math.random()*2+1, color: GAME_COLORS.ALLIED_MINION, life: 60 });
                                shouldDropLoot = false;
                            } else { 
                                const dataLeechWeapon = draft.player.weapons.find(w => w.id === 'data_leech' || w.id === 'leech_siphon_chain');
                                let wasAffectedByLeech = false;
                                if (dataLeechWeapon && (dataLeechWeapon.targetId === dead.id || (dataLeechWeapon.chainTargetIds && dataLeechWeapon.chainTargetIds.includes(dead.id)))) {
                                    wasAffectedByLeech = true;
                                }

                                if (draft.player.activeUniquePassiveIds.includes('passive_reaper_process_siphon') && wasAffectedByLeech && Math.random() < 0.15) {
                                    draft.healthPickups.push({ id: `hp-reaper-${dead.id}`, position: {...dead.position}, size: HEALTH_PICKUP_STATS.size * 0.6, healAmount: 5, color: GAME_COLORS.HEALTH_PICKUP });
                                }
                                
                                if (dataLeechWeapon && dataLeechWeapon.id === 'leech_siphon_chain' && wasAffectedByLeech && Math.random() < 0.25) {
                                    draft.healthPickups.push({ id: `hp-siphon-${dead.id}`, position: {...dead.position}, size: HEALTH_PICKUP_STATS.size * 0.4, healAmount: 5, color: GAME_COLORS.HEALTH_PICKUP });
                                }
                            }
                            
                            if(isAcidVirusEvolved) {
                                const puddleEnemyWasIn = draft.acidPuddles.find(puddle => calculateDistance(dead.position, puddle.position) < puddle.radius);
                                if(puddleEnemyWasIn && Math.random() < ACID_VIRUS_STATS.pandemicSporeChance) {
                                    SoundManager.play('acidSporeLaunch');
                                    let closestTarget = null, minDistance = Infinity;
                                    draft.enemies.forEach(e => {
                                        if(e.id !== dead.id && e.health > 0) {
                                            const dist = calculateDistance(dead.position, e.position);
                                            if (dist < minDistance) { minDistance = dist; closestTarget = e; }
                                        }
                                    });
                                    if(closestTarget) {
                                        const direction = normalizeVector({ x: closestTarget.position.x - dead.position.x, y: closestTarget.position.y - dead.position.y });
                                        draft.projectiles.push({
                                            id: `spore-${dead.id}`, position: { ...dead.position },
                                            velocity: { x: direction.x * ACID_VIRUS_STATS.pandemicSporeSpeed, y: direction.y * ACID_VIRUS_STATS.pandemicSporeSpeed },
                                            baseSpeed: ACID_VIRUS_STATS.pandemicSporeSpeed,
                                            size: ACID_VIRUS_STATS.pandemicSporeSize,
                                            color: GAME_COLORS.PROJECTILE_ACID_SPORE, ownerId: draft.player.id,
                                            type: 'acid_spore', isSeeking: true, targetEnemyId: closestTarget.id, lifetime: 5000, hitEnemyIds:[], weaponBaseId: 'acid_virus'
                                        });
                                    }
                                }
                            }

                            if (shouldDropLoot) { 
                                SoundManager.play('enemyDie'); 
                                draft.score += 10; 
                                draft.expOrbs.push({ id: `xp-${dead.id}`, position: { ...dead.position }, size: 10, value: xpValue, color: GAME_COLORS.XP_ORB }); 
                                for (let i=0; i<10; i++) draft.particles.push({ id: `p-death-${dead.id}-${i}`, position: { ...dead.position }, velocity: { x: (Math.random()-0.5)*100, y: (Math.random()-0.5)*100 }, size: Math.random()*3+1, color: dead.color, life: Math.random() * 50 + 50 }); 
                            }
                            if (dead.type === EnemyType.TROJAN_HORSE) {
                                for (let i = 0; i < ENEMY_TROJAN_HORSE_STATS.fragmentsToSpawn; i++) {
                                    newEnemiesFromDeath.push({
                                        id: `enemy-frag-${dead.id}-${i}`,
                                        type: ENEMY_MALWARE_FRAGMENT_STATS.type,
                                        position: { x: dead.position.x + (Math.random() - 0.5) * 20, y: dead.position.y + (Math.random() - 0.5) * 20 },
                                        size: ENEMY_MALWARE_FRAGMENT_STATS.size,
                                        baseSpeed: ENEMY_MALWARE_FRAGMENT_STATS.baseSpeed,
                                        speed: ENEMY_MALWARE_FRAGMENT_STATS.baseSpeed * (1 + Math.floor(draft.gameTime / 60) * 0.12),
                                        color: ENEMY_MALWARE_FRAGMENT_STATS.color,
                                        health: ENEMY_MALWARE_FRAGMENT_STATS.health * (1 + Math.floor(draft.gameTime / 60) * 0.18),
                                        damage: ENEMY_MALWARE_FRAGMENT_STATS.damage * (1 + Math.floor(draft.gameTime / 60) * 0.12),
                                        expValue: ENEMY_MALWARE_FRAGMENT_STATS.expValue,
                                        isVisible: true,
                                        dotEffects: [],
                                        statusEffects: [],
                                        isConvertible: ENEMY_MALWARE_FRAGMENT_STATS.isConvertible
                                    });
                                }
                            }
                            if (dead.type === EnemyType.RECURSIVE_PROCESS) {
                                SoundManager.play('minionSpawn');
                                for (let i = 0; i < 2; i++) {
                                    newEnemiesFromDeath.push({ id: `enemy-child-${dead.id}-${i}`, type: ENEMY_CHILD_PROCESS_STATS.type, position: { x: dead.position.x + (Math.random() - 0.5) * 20, y: dead.position.y + (Math.random() - 0.5) * 20 }, size: ENEMY_CHILD_PROCESS_STATS.size, baseSpeed: ENEMY_CHILD_PROCESS_STATS.baseSpeed, speed: ENEMY_CHILD_PROCESS_STATS.baseSpeed, color: ENEMY_CHILD_PROCESS_STATS.color, health: ENEMY_CHILD_PROCESS_STATS.health, damage: ENEMY_CHILD_PROCESS_STATS.damage, expValue: ENEMY_CHILD_PROCESS_STATS.expValue, isVisible: true, dotEffects: [], statusEffects: [], isConvertible: false });
                                }
                                shouldDropLoot = false;
                            }
                                if(draft.player.activeUniquePassiveIds.includes('passive_assassin_execution_flow')) {
                                const existingBuffIndex = draft.player.temporaryBuffs.findIndex(b => b.sourceId === 'passive_assassin_execution_flow');
                                if(existingBuffIndex !== -1) {
                                    draft.player.temporaryBuffs[existingBuffIndex].endTime = now + 2000;
                                    const attackSpeedBuffIndex = draft.player.temporaryBuffs.findIndex(b => b.sourceId === 'passive_assassin_execution_flow' && b.type === TemporaryBuffType.ATTACK_SPEED);
                                    if(attackSpeedBuffIndex !== -1) draft.player.temporaryBuffs[attackSpeedBuffIndex].endTime = now + 2000;
                                } else {
                                    draft.player.temporaryBuffs.push({id: `assassin-flow-mv-${now}`, type: TemporaryBuffType.MOVE_SPEED, magnitude: 1.20, endTime: now + 2000, sourceId: 'passive_assassin_execution_flow', icon: '🏃' });
                                    draft.player.temporaryBuffs.push({id: `assassin-flow-as-${now}`, type: TemporaryBuffType.ATTACK_SPEED, magnitude: 0.85, endTime: now + 2000, sourceId: 'passive_assassin_execution_flow', icon: '⚡' });
                                }
                            }
                        });
                        draft.enemies = draft.enemies.filter(e => e.health > 0).concat(newEnemiesFromDeath);
                    }
                    draft.alliedMinions = draft.alliedMinions.filter(m => m.health > 0);

                    if (draft.eventActive === 'DATA_VAULT' && draft.eventKillsSoFar >= draft.eventKillCounter) {
                        draft.eventActive = null;
                        const vaultPos = { ...draft.dataVault.position };
                        draft.dataVault = null; 
                        
                        for (let i=0; i<3; ++i) {
                            draft.knowledgeOrbs.push({
                                id: `k-orb-${now}-${i}`,
                                position: { x: vaultPos.x + (Math.random() - 0.5) * 50, y: vaultPos.y + (Math.random() - 0.5) * 50 },
                                size: 25,
                            });
                        }
                        SoundManager.play('eventSuccess');
                    }

                    if (draft.experience >= draft.expToNextLevel) { 
                        draft.level++; 
                        draft.experience -= draft.expToNextLevel; 
                        draft.expToNextLevel = Math.floor(draft.expToNextLevel * EXP_LEVEL_MULTIPLIER * gameModifiers.expToNextLevelMultiplier); 
                        onLevelUpCallback(); 
                        SoundManager.play('levelUp'); 
                    }
                });
            } catch (e) {
                console.error("Erro crítico no gameTick:", e);
                if (engineRef && engineRef.current) {
                    engineRef.current.pauseGame();
                }
            }
        }, [isGameActive, onLevelUpCallback, onBossWarningStartCallback, onBossFightStartCallback, onStageClearCallback, _applyStatusEffectToEntity, handleGameOverWithStats, decompilerBonuses, weaponMasteryStats, setGameState ]);
        //fim gametick

    const handleKeyDown = useGameEngineCallback((key) => {
        if (gameState.isPaused && key.toLowerCase() !== 'p') return;
        setGameState(draft => { draft.keys[key.toLowerCase()] = true; });
    }, [gameState.isPaused, setGameState]);

    const handleKeyUp = useGameEngineCallback((key) => {
        setGameState(draft => { draft.keys[key.toLowerCase()] = false; });
    }, [setGameState]);
    
    const pauseGame = useAppCallback(() => {
        setGameState(draft => {
            draft.isPaused = true;
            draft.keys = { w: false, a: false, s: false, d: false, ' ': false };
        });
    }, [setGameState]);

    const resumeGame = useAppCallback(() => {
        setGameState(draft => {
            const now = Date.now();
            let updatedBoss = draft.boss;
            if(updatedBoss){
                if(updatedBoss.bossType === 'guardian'){
                    updatedBoss.lastPhase1AttackTime= Math.max(updatedBoss.lastPhase1AttackTime, now - BOSS_STATS.projectilePhase1FireRate + 1000); 
                    updatedBoss.lastPhase2AttackTime= Math.max(updatedBoss.lastPhase2AttackTime, now - BOSS_STATS.projectilePhase2FireRate + 1000); 
                    updatedBoss.lastPulseAttackTime= Math.max(updatedBoss.lastPulseAttackTime, now - BOSS_STATS.pulseAttackCooldown + 1000); 
                    updatedBoss.lastCorruptedZoneTime= Math.max(updatedBoss.lastCorruptedZoneTime, now - BOSS_STATS.corruptedZoneInterval + 1000); 
                    updatedBoss.lastGlitchMinionSpawnTime= Math.max(updatedBoss.lastGlitchMinionSpawnTime, now - BOSS_STATS.glitchMinionSpawnInterval + 1000); 
                    updatedBoss.lastDataStreamAttackTime= Math.max(updatedBoss.lastDataStreamAttackTime, now - BOSS_STATS.dataStreamBarrageInterval + 1000);
                    if (updatedBoss.kernelPanicChargeStartTime > 0) { 
                        updatedBoss.kernelPanicChargeStartTime = now - (BOSS_STATS.kernelPanicPulseChargeTime - (updatedBoss.lastKernelPanicPulseTime - updatedBoss.kernelPanicChargeStartTime)); 
                    } else { 
                        updatedBoss.lastKernelPanicPulseTime= Math.max(updatedBoss.lastKernelPanicPulseTime, now - BOSS_STATS.kernelPanicPulseCooldown + 1000); 
                    }
                } else if (updatedBoss.bossType === 'sincronizador') {
                    updatedBoss.lastEnergyWaveTime = Math.max(updatedBoss.lastEnergyWaveTime, now - BOSS_2_STATS.phase1EnergyWaveInterval + 1000);
                    updatedBoss.lastLaserTime = Math.max(updatedBoss.lastLaserTime, now - BOSS_2_STATS.laserCooldown + 1000);
                    updatedBoss.lastDataWallTime = Math.max(updatedBoss.lastDataWallTime, now - BOSS_2_STATS.dataWallSpawnInterval + 1000);
                }
            }
            draft.isPaused = false;
            draft.nextEnemySpawnTime = Math.max(draft.nextEnemySpawnTime, now + 500);
            draft.nextHealthPickupSpawnTime = Math.max(draft.nextHealthPickupSpawnTime, now + 2000);
        });
    }, [setGameState]);
    
    const applyUpgrade = useAppCallback((upgrade) => {
        setGameState(draft => {
            upgrade.apply(draft.player, draft.player.weapons);
            if (upgrade.type !== 'weapon_evolution') {
                ownedUpgradesRef.current.set(upgrade.id, (ownedUpgradesRef.current.get(upgrade.id) || 0) + 1);
            }
            if (upgrade.type === 'weapon_new') {
                sessionStatsRef.current.weaponsAcquiredCount++;
                const weaponId = upgrade.id.split('_')[1];
                const weapon = draft.player.weapons.find(w => w.id === weaponId);
                if (weapon && !weapon.level) weapon.level = 1;
                if (weapon && weapon.id === 'firewall' && !weapon.orbHitCooldowns) weapon.orbHitCooldowns = {};
            }
        });
    }, [setGameState]);

    const getUpgradeOptions = useAppCallback(() => {
        const currentOwnedUpgrades = ownedUpgradesRef.current;
        const currentPlayerWeapons = gameState.player.weapons;
        const selectedClassDef = CLASS_DEFINITIONS.find(c => c.id === (gameState.player).classId) || CLASS_DEFINITIONS[0];

        const evolutionOptions = [];
        WEAPON_EVOLUTIONS.forEach(evoRecipe => {
            if (currentPlayerWeapons.find(w => w.id === evoRecipe.evolvedWeaponProperties.newId)) return;
            const baseWeaponInstance = currentPlayerWeapons.find(w => w.id === evoRecipe.baseWeaponId || w.originalBaseWeaponId === evoRecipe.baseWeaponId);
            if (!baseWeaponInstance || baseWeaponInstance.isEvolved) return;
            const catalystOwned = (currentOwnedUpgrades.get(evoRecipe.catalystPassiveId) || 0) > 0;
            if (!catalystOwned) return;
            const requiredUpgradesMet = evoRecipe.requiredUpgradeIds.every(req => (currentOwnedUpgrades.get(req.id) || 0) >= req.level);
            if (!requiredUpgradesMet) return;

            evolutionOptions.push({
                id: evoRecipe.evolutionId,
                title: `Evoluir: ${evoRecipe.name}`,
                description: evoRecipe.description,
                level: 0,
                maxLevel: 1,
                type: 'weapon_evolution',
                evolvesWeaponId: baseWeaponInstance.id,
                apply: (player, weapons) => {
                    const weaponToEvolve = weapons.find(w => w.id === baseWeaponInstance.id && !w.isEvolved);
                    if (weaponToEvolve) {
                        weaponToEvolve.originalBaseWeaponId = weaponToEvolve.originalBaseWeaponId || evoRecipe.baseWeaponId;
                        weaponToEvolve.id = evoRecipe.evolvedWeaponProperties.newId;
                        weaponToEvolve.isEvolved = true;
                        weaponToEvolve.evolutionId = evoRecipe.evolutionId;
                    }
                }
            });
        });

        const standardUpgradePool = UPGRADE_POOL.filter(u => {
            const currentLevel = currentOwnedUpgrades.get(u.id) || 0;
            if (currentLevel >= u.maxLevel) return false;
            if (u.requires && (currentOwnedUpgrades.get(u.requires) || 0) === 0) return false;
            if (u.type === 'weapon_new') {
                const weaponBaseId = u.id.split('_')[1];
                if (currentPlayerWeapons.find(w => w.id === weaponBaseId || w.originalBaseWeaponId === weaponBaseId)) return false;
                if (selectedClassDef.startingWeaponId === weaponBaseId && gameState.level <= 1 && currentOwnedUpgrades.get(u.id) === 1) return false;
            }
            if (u.type === 'weapon_upgrade' && u.requires) {
                const requiredWeaponBaseId = u.requires.split('_')[1];
                const weaponInstance = currentPlayerWeapons.find(w => w.id === requiredWeaponBaseId || w.originalBaseWeaponId === requiredWeaponBaseId);
                if (weaponInstance && weaponInstance.isEvolved) return false;
            }
            return true;
        });
        
        const choices = [...evolutionOptions];
        const shuffledStandard = [...standardUpgradePool].sort(() => 0.5 - Math.random());
        let numOptions = 4 + (gameState.player.extraUpgradeChoices || 0);
        for (let i = 0; choices.length < numOptions && i < shuffledStandard.length; i++) {
            if (!choices.find(c => c.id === shuffledStandard[i].id)) {
                choices.push({...shuffledStandard[i], currentLevelDisplay: currentOwnedUpgrades.get(shuffledStandard[i].id) || 0});
            }
        }
        return choices.slice(0, numOptions);
    }, [ownedUpgradesRef, gameState.player, gameState.level]);
    
    useAppEffect(() => {
        let timerId;
        if (isGameActive && !gameState.isPaused && (gameState.boss === null || gameState.isInfiniteMode)) {
            timerId = window.setInterval(() => setGameState(draft => { draft.gameTime += 1 }), 1000);
        }
        return () => { if(timerId) clearInterval(timerId); };
    }, [isGameActive, gameState.isPaused, gameState.boss, gameState.isInfiniteMode, setGameState]);

    const enterInfiniteMode = useAppCallback(() => {
        setGameState(draft => {
            if (sessionStatsRef.current) {
                sessionStatsRef.current.reachedInfiniteMode = true;
            }
            draft.isInfiniteMode = true;
            draft.isPaused = false;
        });
    }, [setGameState]);

    return {
        gameState, gameTick, resetGame, handleKeyDown, handleKeyUp,
        pauseGame, resumeGame, getUpgradeOptions, applyUpgrade,
        spawnBoss, spawnBoss2, spawnBoss3, spawnBoss4, startNextStage, ownedUpgradesRef,
        sessionStatsRef,
        enterInfiniteMode
    };
};
// --- END OF hooks/useGameEngine.ts ---
        
        // --- START OF NEW/UPDATED UI COMPONENTS ---

        const LeftSidebar = ({ gameState }) => {
            if (!gameState || !gameState.player) return null;

            const { player, experience, expToNextLevel, alliedMinions } = gameState;
            const playerMaxHealth = Math.ceil(player.maxHealth);
            const healthPercent = player.maxHealth > 0 ? (player.health / playerMaxHealth) * 100 : 0;
            const expPercent = expToNextLevel > 0 ? (experience / expToNextLevel) * 100 : 0;

            const currentDashCooldown = DASH_STATS.COOLDOWN * (player.dashCooldownModifier || 1.0);
            const dashCooldownPercent = player.dashCooldownUntil > Date.now() ? ((player.dashCooldownUntil - Date.now()) / currentDashCooldown) * 100 : 0;
            const specialAbilityElement = React.createElement('div', { title: "Habilidade de Dash (Espaço)", className: `relative w-8 h-8 border-2 rounded-md flex items-center justify-center ${dashCooldownPercent === 0 ? `border-[${GAME_COLORS.DASH_COOLDOWN_FILL}]` : `border-[${GAME_COLORS.DASH_COOLDOWN_BG}]`}` },
                React.createElement('div', { className: 'absolute bottom-0 left-0 w-full bg-cyan-400 opacity-60', style: { height: `${100 - dashCooldownPercent}%`, transition: 'height 0.1s linear' } }),
                React.createElement('span', { className: 'relative z-10 text-lg' }, '↪')
            );

            const technomancerMinionCountDisplay = player.classId === 'class_technomancer' ? 
                React.createElement('div', { title: "Contagem de Minions", className: 'relative w-auto px-2 h-8 border-2 rounded-md flex items-center justify-center border-cyan-400' },
                    React.createElement('span', { className: 'relative z-10 text-lg mr-2' }, '🤖'),
                    React.createElement('span', { className: 'relative z-10 font-press-start text-xs text-white' }, `[${alliedMinions.length}/${SUB_PROCESS_MINION_STATS.maxMinions}]`)
                ) : null;


            return React.createElement('div', { className: `w-56 h-full flex-shrink-0 bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] p-4 flex flex-col space-y-4 border-r-2 border-[${GAME_COLORS.BORDER}]` },
                React.createElement('div', null,
                    React.createElement('div', { className: 'flex items-center space-x-2 mb-1' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.HEALTH_PICKUP}]` }, '❤️'),
                        React.createElement('span', { className: 'font-press-start text-sm' }, 'HP'),
                        React.createElement('span', { className: `font-VT323 text-lg ml-auto` }, `${Math.ceil(player.health)}/${playerMaxHealth}`)
                    ),
                    React.createElement('div', { className: `w-full h-5 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}] p-0.5` },
                        React.createElement('div', {
                            className: `h-full rounded-sm ${healthPercent < 30 ? 'health-bar-fill low' : `bg-[${GAME_COLORS.PLAYER}]`} transition-all duration-300`,
                            style: { width: `${healthPercent}%` }
                        })
                    )
                ),
                React.createElement('div', null,
                    React.createElement('div', { className: 'flex items-center space-x-2 mb-1' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.TEXT_XP}]` }, '✨'),
                        React.createElement('span', { className: 'font-press-start text-sm' }, 'XP'),
                        React.createElement('span', { className: `font-VT323 text-lg ml-auto` }, `${experience}/${expToNextLevel}`)
                    ),
                    React.createElement('div', { className: `w-full h-5 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}] p-0.5` },
                        React.createElement('div', {
                            className: `h-full rounded-sm bg-[${GAME_COLORS.XP_ORB}] transition-all duration-300`,
                            style: { width: `${expPercent}%` }
                        })
                    )
                ),
                React.createElement('div', { className: 'flex-grow flex flex-col items-start space-y-2' },
                    specialAbilityElement,
                    technomancerMinionCountDisplay,
                    player.temporaryBuffs && player.temporaryBuffs.length > 0 && 
                    React.createElement('div', { className: 'flex flex-wrap gap-2' }, 
                        player.temporaryBuffs.map(buff => {
                            if (buff.type === TemporaryBuffType.DAMAGE_REDUCTION) return null;
                            return React.createElement('div', { key: buff.id, title: buff.type, className: 'relative w-8 h-8 border-2 border-yellow-400 rounded-md flex items-center justify-center bg-gray-700' },
                                React.createElement('span', { className: 'text-lg'}, buff.icon),
                                React.createElement('div', { className: 'absolute -bottom-1 -right-1 text-xs bg-black px-0.5 rounded-sm font-VT323' }, Math.ceil((buff.endTime - Date.now()) / 1000))
                            )
                        })
                    )
                )
            );
        };

                const RightSidebar = ({ gameState }) => {
            if (!gameState || !gameState.player) return null;

            const { score, level, gameTime, stage, isInfiniteMode, isNightmareMode } = gameState;
            const stageDisplay = isInfiniteMode ? '∞' : stage;
            const statItemClass = "flex items-center justify-between p-2 bg-black bg-opacity-30 rounded-md";

            return React.createElement('div', { className: `w-56 h-full flex-shrink-0 bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] p-4 flex flex-col space-y-3 border-l-2 border-[${GAME_COLORS.BORDER}]` },
                // --- Bloco "FASE" Corrigido ---
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: 'text-xl text-cyan-400' }, '💻'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'FASE:')
                    ), // <- O div que agrupa o ícone e o texto "FASE" fecha aqui.
                    // O valor da fase agora é um irmão desse div, mas ainda dentro do `statItemClass`
                    React.createElement('span', { className: 'font-VT323 text-lg text-cyan-300' }, stageDisplay)
                ), // <- O parêntese que fecha o `statItemClass` está no lugar correto agora.

                isNightmareMode && React.createElement('div', { className: `${statItemClass} border-2 border-red-700` },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: 'text-xl text-red-500 animate-pulse' }, '💀'),
                        React.createElement('span', { className: 'font-press-start text-xs text-red-400' }, 'PESADELO')
                    )
                ),
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.TEXT_YELLOW}]` }, '⭐'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'NÍVEL:')
                    ),
                    React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, level)
                ),
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.TEXT_GREEN}]` }, '🏆'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'PONTOS:')
                    ),
                    React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_GREEN}]` }, score)
                ),
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: 'text-xl text-sky-400' }, '⏱️'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'TEMPO:')
                    ),
                    React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, formatTime(gameTime))
                )
            );
        };

        const UIOverlay = ({ gameState }) => {
            if (!gameState || (!gameState.boss && !gameState.eventActive)) return null;

            const { boss, eventActive, eventKillCounter, eventKillsSoFar } = gameState;
            const bossHealthPercent = boss && boss.maxHealth > 0 ? (boss.health / boss.maxHealth) * 100 : 0;
            const eventProgressPercent = eventKillCounter > 0 ? (eventKillsSoFar / eventKillCounter) * 100 : 0;

            let bossTitle = '', bossColor = GAME_COLORS.BOSS_CORE;
            if (boss) {
                if (boss.bossType === 'guardian') { bossTitle = 'GUARDIÃO DO NÚCLEO'; if (boss.phase === 2) bossTitle = 'GUARDIÃO: CORRUPÇÃO DE DADOS'; else if (boss.phase === 3) bossTitle = 'GUARDIÃO: SOBRECARGA TOTAL'; }
                else if (boss.bossType === 'sincronizador') { bossTitle = 'O SINCRONIZADOR'; bossColor = GAME_COLORS.BOSS_2_CORE; if (boss.phase === 2) bossTitle = 'SINCRONIZADOR: LASER DE DADOS'; else if (boss.phase === 3) bossTitle = 'SINCRONIZADOR: PROTOCOLO FINAL'; }
                else if (boss.bossType === 'arbiter') { bossTitle = 'O ÁRBITRO DO SISTEMA'; bossColor = GAME_COLORS.BOSS_3_CORE; if (boss.phase === 2) bossTitle = 'ÁRBITRO: OTIMIZAÇÃO HOSTIL'; else if (boss.phase === 3) bossTitle = 'ÁRBITRO: KERNEL PANIC IMINENTE'; }
                else if (boss.bossType === 'hivemind_nexus') { bossTitle = 'NEXUS DA COLMEIA'; bossColor = GAME_COLORS.BOSS_4_CORE; if (boss.phase === 2) bossTitle = 'NEXUS: SATURAÇÃO DA REDE'; else if (boss.phase === 3) bossTitle = 'NEXUS: SINGULARIDADE'; }
            }

            return React.createElement('div', { id: 'ui-top-overlay', className: 'absolute top-0 left-1/2 -translate-x-1/2 w-full max-w-2xl p-2 z-10' },
                eventActive === 'DATA_VAULT' && (
                    React.createElement('div', { className: 'mt-2' },
                        React.createElement('h3', { className: `font-press-start text-center text-sm sm:text-lg text-yellow-400 mb-1 animate-pulse` }, 'QUEBRANDO CRIPTOGRAFIA...'),
                        React.createElement('div', { className: `w-full h-4 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-yellow-600 p-0.5` },
                            React.createElement('div', { className: `h-full rounded-sm transition-all duration-300 bg-yellow-400`, style: { width: `${eventProgressPercent}%` } }),
                            React.createElement('div', { className: 'absolute w-full h-full flex items-center justify-center top-0 left-0' }, React.createElement('span', { className: 'font-press-start text-xs text-black' }, `${eventKillsSoFar} / ${eventKillCounter}`))
                        )
                    )
                ),
                boss && (
                    React.createElement('div', { className: 'mt-2' },
                        React.createElement('h3', { className: `font-press-start text-center text-sm sm:text-lg text-[${GAME_COLORS.TEXT_RED}] mb-1 ${boss.phase === 3 ? 'animate-pulse' : ''}` }, bossTitle),
                        React.createElement('div', { className: `w-full h-6 sm:h-8 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}] p-0.5` },
                            React.createElement('div', { className: `h-full rounded-sm transition-all duration-300`, style: { width: `${bossHealthPercent}%`, backgroundColor: bossColor } })
                        )
                    )
                )
            );
        };
        
                // --- START OF components/GameCanvas.tsx ---
        const { useRef: useCanvasRef, useEffect: useCanvasEffect } = React;

        const GameCanvas = ({ gameState, gameScreen, crisolGameState }) => {
            const canvasRef = useCanvasRef(null);
            const animationTimeRef = useCanvasRef(0);

            const drawPlayer = (ctx, player) => {
                const skin = SKIN_DEFINITIONS.find(s => s.id === player.skinId) || SKIN_DEFINITIONS[0];
                if (skin.draw) {
                    skin.draw(ctx, player, { time: animationTimeRef.current });
                }
            };
            
            useCanvasEffect(() => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); if (!ctx) return;
                
                const now = performance.now();
                animationTimeRef.current = now;

                const isCrisolActive = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE, GameScreenState.CRISOL_PAUSED].includes(gameScreen);

                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (isCrisolActive) {
                    ctx.fillStyle = '#010409';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    ctx.strokeStyle = '#0e7490';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([15, 15]);
                    ctx.strokeRect(CRISOL_ARENA.x, CRISOL_ARENA.y, CRISOL_ARENA.width, CRISOL_ARENA.height);
                    ctx.setLineDash([]);
                    
                    if (crisolGameState) {
                        const { player: crisolPlayer, projectiles: crisolProjectiles, visualEffects } = crisolGameState;
                        
                        // Desenhar Projéteis
                        ctx.shadowBlur = 0;
                        crisolProjectiles.forEach(p => {
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        // Desenhar Efeitos Visuais (Feixes)
                        visualEffects.forEach(effect => {
                            if (effect.type === 'sweep_beam') {
                                const timeSinceStart = now - effect.startTime;
                                const timePassed = timeSinceStart / 1000;
                                let rect;

                                if (effect.from === 'left' || effect.from === 'right') {
                                    const leadEdgeX = effect.from === 'left' ? CRISOL_ARENA.x + timePassed * effect.speed : CRISOL_ARENA.x + CRISOL_ARENA.width - (timePassed * effect.speed);
                                    rect = { x: leadEdgeX - effect.width/2, y: CRISOL_ARENA.y, width: effect.width, height: CRISOL_ARENA.height };
                                } else {
                                    const leadEdgeY = effect.from === 'top' ? CRISOL_ARENA.y + timePassed * effect.speed : CRISOL_ARENA.y + CRISOL_ARENA.height - (timePassed * effect.speed);
                                    rect = { x: CRISOL_ARENA.x, y: leadEdgeY - effect.width/2, width: CRISOL_ARENA.width, height: effect.width };
                                }
                                
                                const warnTime = 500;
                                if (timeSinceStart < warnTime) {
                                    ctx.fillStyle = CRISOL_PROJECTILE_TYPES.BEAM_WARNING.color;
                                    ctx.globalAlpha = (timeSinceStart / warnTime) * (0.4 + Math.abs(Math.sin(now / 50)) * 0.2);
                                } else {
                                    ctx.fillStyle = effect.color;
                                    ctx.globalAlpha = 0.8;
                                }
                                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                                ctx.globalAlpha = 1.0;
                            }
                        });

                        // Desenhar Jogador
                        ctx.save();
                        if (crisolPlayer.isDashing) ctx.globalAlpha = 0.5;
                        if (now - crisolPlayer.lastHitTime < 500) ctx.globalAlpha = (Math.floor(now / 50) % 2 === 0) ? 0.4 : 0.8;
                        
                        ctx.fillStyle = '#38bdf8';
                        ctx.shadowColor = '#38bdf8';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(crisolPlayer.position.x, crisolPlayer.position.y, crisolPlayer.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }

                } else if (gameState) {
                    // ... (toda a lógica de desenho do modo de jogo principal permanece aqui, sem alterações)
                    if (gameState.stage === 4) {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_STAGE_4_ABYSS;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.save();
                        ctx.strokeStyle = GAME_COLORS.CIRCUIT_STAGE_4;
                        ctx.lineWidth = 2;
                        const circuitSpeed = animationTimeRef.current / 50000;
                        ctx.translate(Math.sin(circuitSpeed) * 50, Math.cos(circuitSpeed) * 50);
                        for (let i = -5; i < 30; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 100, -100);
                            ctx.lineTo(i * 100 + 1000, CANVAS_HEIGHT + 100);
                            ctx.stroke();
                        }
                        ctx.restore();
                        if (!gameState.dataFlowParticles) gameState.dataFlowParticles = [];
                        while(gameState.dataFlowParticles.length < 50) {
                            gameState.dataFlowParticles.push({
                                x: Math.random() * CANVAS_WIDTH,
                                y: Math.random() * CANVAS_HEIGHT,
                                vx: (Math.random() - 0.5) * 800,
                                vy: (Math.random() - 0.5) * 800,
                                color: Math.random() > 0.5 ? GAME_COLORS.DATA_FLOW_CYAN : GAME_COLORS.DATA_FLOW_MAGENTA
                            });
                        }
                        gameState.dataFlowParticles.forEach(p => {
                            p.x += p.vx * (1/60); 
                            p.y += p.vy * (1/60);
                            if (p.x < 0 || p.x > CANVAS_WIDTH || p.y < 0 || p.y > CANVAS_HEIGHT) {
                               p.x = Math.random() * CANVAS_WIDTH; p.y = Math.random() > 0.5 ? -10 : CANVAS_HEIGHT + 10;
                            }
                            ctx.fillStyle = p.color;
                            ctx.fillRect(p.x, p.y, 2, 2);
                        });
                    } else if (gameState.stage === 3) {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_STAGE_3;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.05)';
                        ctx.lineWidth = 15;
                        const busLinesV = [CANVAS_WIDTH/5, CANVAS_WIDTH*2/5, CANVAS_WIDTH*3/5, CANVAS_WIDTH*4/5];
                        const busLinesH = [CANVAS_HEIGHT/5, CANVAS_HEIGHT*2/5, CANVAS_HEIGHT*3/5, CANVAS_HEIGHT*4/5];
                        busLinesV.forEach(line => { ctx.beginPath(); ctx.moveTo(line, 0); ctx.lineTo(line, CANVAS_HEIGHT); ctx.stroke(); });
                        busLinesH.forEach(line => { ctx.beginPath(); ctx.moveTo(0, line); ctx.lineTo(CANVAS_WIDTH, line); ctx.stroke(); });
                    } else if (gameState.stage >= 2) {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_STAGE_2;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.strokeStyle = GAME_COLORS.GRID_STAGE_2; ctx.lineWidth = 1;
                        for (let x = 0; x < CANVAS_WIDTH; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); ctx.stroke(); }
                        for (let y = 0; y < CANVAS_HEIGHT; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); ctx.stroke(); }
                    } else {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_DARK; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    }
    
                    if (!gameState || !gameState.player) return;
                    const { player, enemies, projectiles, particles, expOrbs, healthPickups, knowledgeOrbs, dataVault, corruptedZones, boss, bossShieldNodes, revivingProcesses, dataWalls, laserBeams, interactables, alliedMinions, acidPuddles, unstableSectors, ramSockets, bossAttacks } = gameState;
    
                    // ... [toda a lógica de desenho do modo principal que já existe no seu arquivo] ...
                    // O código original para desenhar inimigos, jogador, etc., permanece aqui
                     unstableSectors.forEach(sector => {
                        const timeLeft = sector.endTime - Date.now();
                        if (timeLeft <= 0) return;
                        let alpha = 0.4; let color = GAME_COLORS.UNSTABLE_SECTOR_WARNING;
                        if (timeLeft < 500) { alpha = Math.abs(Math.sin(Date.now() / 50)) * 0.8; color = GAME_COLORS.UNSTABLE_SECTOR_DANGER; }
                        ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = color; ctx.fillRect(sector.x, sector.y, 40, 40); ctx.restore();
                    });
                    
                    if(dataVault) {
                        ctx.save();
                        const size = 60;
                        const x = dataVault.position.x;
                        const y = dataVault.position.y;
                        ctx.fillStyle = GAME_COLORS.DATA_VAULT;
                        ctx.strokeStyle = GAME_COLORS.DATA_VAULT_CIRCUIT;
                        ctx.lineWidth = 2 + Math.sin(Date.now() / 200) * 1.5;
                        ctx.shadowColor = GAME_COLORS.DATA_VAULT_CIRCUIT;
                        ctx.shadowBlur = 20;
                        ctx.fillRect(x - size/2, y - size/2, size, size);
                        ctx.strokeRect(x - size/2, y - size/2, size, size);
                        ctx.restore();
                    }
    
                    acidPuddles.forEach(puddle => {
                        ctx.save();
                        const lifetimeMs = puddle.endTime - (puddle.endTime - puddle.duration);
                        const remainingMs = puddle.endTime - Date.now();
                        const lifetimeRemaining = Math.max(0, remainingMs / lifetimeMs);
                        const alpha = lifetimeRemaining * (puddle.color ? 1 : 0.55);
                        ctx.globalAlpha = alpha;
                        if (puddle.isCritical) {
                            ctx.fillStyle = GAME_COLORS.TEXT_YELLOW;
                            ctx.shadowColor = GAME_COLORS.TEXT_YELLOW;
                            ctx.shadowBlur = 15 + Math.sin(Date.now() / 100) * 5;
                        } else {
                            ctx.fillStyle = puddle.color || GAME_COLORS.ACID_PUDDLE;
                            ctx.shadowColor = puddle.color || GAME_COLORS.PROJECTILE_ACID_VIRUS;
                            ctx.shadowBlur = 10;
                        }
                        ctx.beginPath();
                        ctx.arc(puddle.position.x, puddle.position.y, puddle.radius, 0, Math.PI * 2);
                        ctx.fill();
                        if (puddle.color === GAME_COLORS.ACID_PUDDLE && Math.random() < 0.15) {
                            particles.push({
                                id: `bubble-${puddle.id}-${Date.now()}-${Math.random()}`,
                                position: { x: puddle.position.x + (Math.random() - 0.5) * puddle.radius * 1.8, y: puddle.position.y + (Math.random() - 0.5) * puddle.radius * 1.8 },
                                velocity: { x: 0, y: -(Math.random() * 10 + 5) },
                                size: Math.random() * 2 + 1,
                                color: 'rgba(190, 242, 100, 0.7)',
                                life: 25
                            });
                        }
                        ctx.restore();
                    });
    
                    interactables.forEach(i => {
                        ctx.save();
                        if (i.type === InteractableType.DATA_CACHE) {
                            ctx.fillStyle = GAME_COLORS.DATA_CACHE;
                            ctx.shadowColor = GAME_COLORS.DATA_CACHE;
                            ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5;
                            ctx.fillRect(i.position.x - i.size / 2, i.position.y - i.size / 2, i.size, i.size);
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(i.position.x - i.size / 2, i.position.y - i.size / 2, i.size, i.size);
                        } else if (i.type === InteractableType.CORRUPTED_LIBRARY) {
                            ctx.fillStyle = GAME_COLORS.CORRUPTED_LIBRARY;
                            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 150) * 0.2;
                            ctx.beginPath();
                            ctx.arc(i.position.x, i.position.y, i.radius, 0, Math.PI * 2);
                            ctx.fill();
    
                            if (i.cleanseProgress > 0) {
                                ctx.fillStyle = GAME_COLORS.PROGRESS_BAR_BG;
                                ctx.fillRect(i.position.x - i.radius, i.position.y - i.radius - 15, i.radius * 2, 8);
                                ctx.fillStyle = GAME_COLORS.TEXT_GREEN;
                                ctx.fillRect(i.position.x - i.radius, i.position.y - i.radius - 15, i.radius * 2 * i.cleanseProgress, 8);
                                ctx.strokeStyle = GAME_COLORS.BORDER;
                                ctx.strokeRect(i.position.x - i.radius, i.position.y - i.radius - 15, i.radius * 2, 8);
                            }
                        }
                        ctx.restore();
                    });
    
                    dataWalls.forEach(wall => {
                        ctx.save(); ctx.fillStyle = GAME_COLORS.BOSS_2_DATA_WALL; ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;
                        ctx.fillRect(wall.position.x, wall.position.y, wall.width, wall.height); ctx.restore();
                    });
                    
                    laserBeams.forEach(laser => {
                        const now = Date.now();
                        if (now >= laser.fireStartTime) { 
                            ctx.save();
                            ctx.translate(boss.position.x, boss.position.y); ctx.rotate(laser.angle);
                            const laserAlpha = (laser.endTime - now) / (laser.endTime - laser.fireStartTime);
                            ctx.fillStyle = GAME_COLORS.BOSS_2_LASER; ctx.globalAlpha = Math.min(1, laserAlpha) * 0.8;
                            ctx.fillRect(-CANVAS_WIDTH * 1.5, -BOSS_2_STATS.laserWidth / 2, CANVAS_WIDTH * 3, BOSS_2_STATS.laserWidth);
                            ctx.restore();
                        } else if (now < laser.fireStartTime) { 
                            ctx.save();
                            const chargeProgress = (now - laser.chargeStartTime) / (laser.fireStartTime - laser.chargeStartTime);
                            ctx.translate(boss.position.x, boss.position.y); ctx.rotate(laser.angle);
                            ctx.strokeStyle = GAME_COLORS.BOSS_2_LASER; ctx.lineWidth = 2; ctx.globalAlpha = chargeProgress * 0.7;
                            ctx.beginPath(); ctx.moveTo(-CANVAS_WIDTH * 1.5, -BOSS_2_STATS.laserWidth / 2); ctx.lineTo(CANVAS_WIDTH * 1.5, -BOSS_2_STATS.laserWidth / 2); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(-CANVAS_WIDTH * 1.5, BOSS_2_STATS.laserWidth / 2); ctx.lineTo(CANVAS_WIDTH * 1.5, BOSS_2_STATS.laserWidth / 2); ctx.stroke();
                            ctx.restore();
                        }
                    });
    
                    corruptedZones.forEach(zone => { const lifetimeRemaining = (zone.creationTime + zone.duration) - Date.now(); const alpha = Math.max(0, Math.min(1, lifetimeRemaining / zone.duration)) * 0.7; ctx.save(); ctx.fillStyle = GAME_COLORS.CORRUPTED_ZONE; ctx.globalAlpha = alpha * (0.4 + Math.sin(Date.now() / 80) * 0.1); ctx.beginPath(); ctx.arc(zone.position.x, zone.position.y, zone.radius, 0, Math.PI * 2); ctx.fill(); const staticPoints = 30; ctx.strokeStyle = `rgba(200,0,0, ${alpha * 0.5})`; ctx.lineWidth = 1; for(let i=0; i < staticPoints; i++){ const angle = Math.random() * Math.PI * 2; const radius = Math.random() * zone.radius * 0.9; const x = zone.position.x + Math.cos(angle) * radius; const y = zone.position.y + Math.sin(angle) * radius; ctx.beginPath(); ctx.arc(x,y, Math.random()*2,0, Math.PI*2); ctx.fill(); } ctx.restore(); });
                    
                    bossAttacks.forEach(attack => {
                        ctx.save();
                        const now = Date.now();
                        const timeSinceCreation = now - attack.creationTime;
                        
                        if (attack.type === BossAttackType.DATA_SMASHER) {
                            const warnProgress = Math.min(1, timeSinceCreation / attack.warningDuration);
                            const impactTime = attack.creationTime + attack.warningDuration;
                            if (now < impactTime) {
                                ctx.strokeStyle = GAME_COLORS.BOSS_3_BUS_WARNING;
                                ctx.lineWidth = 5;
                                ctx.globalAlpha = warnProgress * (0.5 + Math.abs(Math.sin(now / 50)) * 0.5);
                                ctx.beginPath();
                                ctx.arc(attack.targetPosition.x, attack.targetPosition.y, attack.radius, 0, Math.PI * 2);
                                ctx.stroke();
                            } else {
                                const impactProgress = Math.min(1, (now - impactTime) / 300);
                                ctx.fillStyle = GAME_COLORS.BOSS_3_BUS_FIRE;
                                ctx.globalAlpha = 1 - impactProgress;
                                ctx.beginPath();
                                ctx.arc(attack.targetPosition.x, attack.targetPosition.y, attack.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        } else if (attack.type === BossAttackType.HOSTILE_TAKEOVER) {
                            const warnProgress = Math.min(1, timeSinceCreation / attack.warningDuration);
                            const fireStartTime = attack.creationTime + attack.warningDuration;
                            const fireEndTime = fireStartTime + attack.fireDuration;
                            if (now < fireStartTime) {
                                ctx.fillStyle = GAME_COLORS.BOSS_3_BUS_WARNING;
                                ctx.globalAlpha = warnProgress * (0.3 + Math.abs(Math.sin(now/60)) * 0.4);
                                if (attack.isHorizontal) { ctx.fillRect(0, attack.line - 15, CANVAS_WIDTH, 30); }
                                else { ctx.fillRect(attack.line - 15, 0, 30, CANVAS_HEIGHT); }
                            } else if (now < fireEndTime) {
                                ctx.fillStyle = GAME_COLORS.BOSS_3_BUS_FIRE;
                                ctx.globalAlpha = 0.9;
                                if (attack.isHorizontal) { ctx.fillRect(0, attack.line - 15, CANVAS_WIDTH, 30); }
                                else { ctx.fillRect(attack.line - 15, 0, 30, CANVAS_HEIGHT); }
                            }
                        } else if (attack.type === BossAttackType.LOGIC_BOMB) {
                            const armProgress = Math.min(1, timeSinceCreation / attack.armDuration);
                            if (!attack.triggered) {
                                ctx.fillStyle = GAME_COLORS.BOSS_3_LOGIC_BOMB;
                                ctx.globalAlpha = armProgress;
                                ctx.beginPath();
                                ctx.arc(attack.position.x, attack.position.y, 15, 0, Math.PI * 2);
                                ctx.fill();
                                if (armProgress === 1) {
                                    ctx.strokeStyle = GAME_COLORS.BOSS_3_LOGIC_BOMB;
                                    ctx.lineWidth = 2;
                                    ctx.globalAlpha = Math.abs(Math.sin(now / 150));
                                    ctx.beginPath();
                                    ctx.arc(attack.position.x, attack.position.y, 20, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            } else {
                                const explosionProgress = Math.min(1, (now - attack.detonationTime) / 500);
                                ctx.strokeStyle = GAME_COLORS.BOSS_3_BUS_FIRE;
                                ctx.lineWidth = 20;
                                ctx.globalAlpha = 1 - explosionProgress;
                                ctx.beginPath();
                                ctx.moveTo(attack.position.x - attack.radius, attack.position.y); ctx.lineTo(attack.position.x + attack.radius, attack.position.y);
                                ctx.moveTo(attack.position.x, attack.position.y - attack.radius); ctx.lineTo(attack.position.x, attack.position.y + attack.radius);
                                ctx.stroke();
                            }
                        } else if (attack.type === BossAttackType.STATIC_ZONE) {
                             const lifetimeProgress = Math.min(1, timeSinceCreation / attack.duration);
                             ctx.fillStyle = GAME_COLORS.BOSS_3_STATIC_ZONE;
                             ctx.globalAlpha = Math.sin(lifetimeProgress * Math.PI) * 0.7 * (0.5 + Math.abs(Math.sin(now/100)*0.5));
                             ctx.beginPath();
                             ctx.arc(attack.position.x, attack.position.y, attack.radius, 0, Math.PI * 2);
                             ctx.fill();
                        }
                        
                        ctx.restore();
                    });
                    
                    const dataLeechWeapon = player.weapons.find(w => w.id === 'data_leech' || w.id === 'leech_siphon_chain');
                    if (dataLeechWeapon && dataLeechWeapon.targetId) {
                        const primaryTarget = [...enemies, ...bossShieldNodes, ...(boss ? [boss] : [])].find(e => e.id === dataLeechWeapon.targetId);
                        if (primaryTarget) {
                            ctx.save();
                            const stillTime = dataLeechWeapon.stillTime || 0;
                            const rampProgress = stillTime / DATA_LEECH_STATS.stillDamageRampUpTime;
                            
                            const isSurging = dataLeechWeapon.isCriticallySurging;
                            ctx.strokeStyle = isSurging ? GAME_COLORS.CRITICAL_HIT_TEXT : GAME_COLORS.EFFECT_DATA_LEECH;
                            ctx.lineWidth = isSurging ? 3.5 + (2.5 * rampProgress) : 1.5 + (2.5 * rampProgress);
                            ctx.globalAlpha = (isSurging ? 0.8 : 0.5) + 0.5 * rampProgress + Math.sin(Date.now() / 50) * 0.1;
                            ctx.shadowColor = isSurging ? GAME_COLORS.CRITICAL_HIT_TEXT : GAME_COLORS.EFFECT_DATA_LEECH;
                            ctx.shadowBlur = isSurging ? 15 + 10 * rampProgress : 5 + 10 * rampProgress;
    
                            ctx.beginPath();
                            ctx.moveTo(player.position.x, player.position.y);
                            ctx.lineTo(primaryTarget.position.x, primaryTarget.position.y);
                            ctx.stroke();
    
                            if (dataLeechWeapon.chainTargetIds && dataLeechWeapon.chainTargetIds.length > 0) {
                                ctx.lineWidth = isSurging ? 2.5 : 1.25; 
                                ctx.globalAlpha = isSurging ? 0.7 : 0.4 + Math.sin(Date.now() / 60) * 0.1;
                                ctx.shadowBlur = isSurging ? 10 : 5;
    
                                dataLeechWeapon.chainTargetIds.forEach(targetId => {
                                    const chainTarget = [...enemies, ...bossShieldNodes].find(e => e.id === targetId);
                                    if (chainTarget) {
                                        ctx.beginPath();
                                        ctx.moveTo(primaryTarget.position.x, primaryTarget.position.y);
                                        ctx.lineTo(chainTarget.position.x, chainTarget.position.y);
                                        ctx.stroke();
                                    }
                                });
                            }
                            
                            ctx.restore();
                        }
                    }
                    
                    ctx.save(); 
                    if (player.isDashing) { ctx.globalAlpha = 0.5; } 
                    if (player.overdriveActive) { ctx.shadowColor = GAME_COLORS.PLAYER_OVERDRIVE_GLOW; ctx.shadowBlur = 25; } 
                    else if (Date.now() - player.lastHitTime < 200) { ctx.globalAlpha = (Math.floor(Date.now() / 50) % 2 === 0) ? 0.5 : 1.0; }
                    drawPlayer(ctx, player);
                    ctx.restore();
    
                    const firewallWeapon = player.weapons.find(w => w.id === 'firewall' || w.id === 'firewall_aegis_shield'); if (firewallWeapon && firewallWeapon.orbs && firewallWeapon.currentAngle !== undefined) { const isAegis = firewallWeapon.id === 'firewall_aegis_shield'; const orbSize = isAegis ? FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier : FIREWALL_STATS.orbSize; const orbColor = isAegis ? GAME_COLORS.FIREWALL_AEGIS_ORB : GAME_COLORS.FIREWALL_ORB; for (let i = 0; i < firewallWeapon.orbs; i++) { const angle = firewallWeapon.currentAngle + (i * (2 * Math.PI / firewallWeapon.orbs)); const orbX = player.position.x + Math.cos(angle) * FIREWALL_STATS.radius; const orbY = player.position.y + Math.sin(angle) * FIREWALL_STATS.radius; ctx.save(); ctx.fillStyle = orbColor; ctx.shadowColor = orbColor; ctx.shadowBlur = isAegis ? 15 : 10; ctx.beginPath(); ctx.arc(orbX, orbY, orbSize / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
    
                    revivingProcesses.forEach(proc => {
                        const reviveProgress = 1 - ((proc.reviveAt - Date.now()) / ENEMY_PROCESSO_ZUMBI_STATS.reviveTime);
                        ctx.save(); ctx.globalAlpha = 0.5; ctx.fillStyle = GAME_COLORS.ENEMY_PROCESSO_ZUMBI;
                        ctx.beginPath(); ctx.arc(proc.position.x, proc.position.y, ENEMY_PROCESSO_ZUMBI_STATS.size / 2 * reviveProgress, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = GAME_COLORS.ENEMY_PROCESSO_ZUMBI; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(proc.position.x, proc.position.y, ENEMY_PROCESSO_ZUMBI_STATS.size, 0, Math.PI*2 * reviveProgress); ctx.stroke(); ctx.restore();
                    });
                    
                    alliedMinions.forEach(minion => {
                        ctx.save();
                        ctx.translate(minion.position.x, minion.position.y);
                        ctx.rotate(minion.angle);
    
                        ctx.fillStyle = minion.color;
                        ctx.shadowColor = minion.color;
                        ctx.shadowBlur = 8;
    
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const vertexAngle = (i * (Math.PI * 2 / 5)) - (Math.PI / 2); 
                            const x = (minion.size / 2) * Math.cos(vertexAngle);
                            const y = (minion.size / 2) * Math.sin(vertexAngle);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
    
                        const minionHealthPercent = minion.health / minion.maxHealth;
                        ctx.fillStyle = GAME_COLORS.PROGRESS_BAR_BG;
                        ctx.fillRect(minion.position.x - minion.size, minion.position.y - minion.size / 2 - 8, minion.size * 2, 4);
                        ctx.fillStyle = GAME_COLORS.TEXT_GREEN;
                        ctx.fillRect(minion.position.x - minion.size, minion.position.y - minion.size / 2 - 8, minion.size * 2 * minionHealthPercent, 4);
                    });
    
    
                    enemies.forEach((e) => {
                        if (e.type === EnemyType.SPYWARE && !e.isCurrentlyVisible) return;
                        ctx.save(); let originalAlpha = ctx.globalAlpha; if (e.statusEffects && e.statusEffects.length > 0) { e.statusEffects.forEach(effect => { if (Date.now() <= effect.startTime + effect.duration) { switch (effect.type) { case StatusEffectType.SLOW: ctx.fillStyle = GAME_COLORS.STATUS_SLOW_TINT; ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 200) * 0.1; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * 0.8, 0, Math.PI * 2); ctx.fill(); break; case StatusEffectType.FREEZE: ctx.fillStyle = GAME_COLORS.STATUS_FREEZE_TINT; ctx.globalAlpha = 0.7; ctx.beginPath(); for(let i = 0; i < 8; i++) { const angle = (Math.PI * 2 / 8) * i; const radius = e.size * 0.6 + (i % 2 === 0 ? e.size * 0.15 : e.size * 0.05); ctx.lineTo(e.position.x + Math.cos(angle) * radius, e.position.y + Math.sin(angle) * radius); } ctx.closePath(); ctx.fill(); break; case StatusEffectType.VULNERABILITY: ctx.strokeStyle = GAME_COLORS.STATUS_VULNERABILITY_AURA; ctx.lineWidth = 2 + Math.sin(Date.now() / 150) * 1; ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * 0.7, 0, Math.PI * 2); ctx.stroke(); break; case StatusEffectType.FEAR: ctx.fillStyle = GAME_COLORS.STATUS_FEAR_AURA; ctx.globalAlpha = 0.3 + Math.abs(Math.sin(Date.now() / 100)) * 0.2; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * 0.85, 0, Math.PI * 2); ctx.fill(); break; } } }); } ctx.globalAlpha = originalAlpha; ctx.fillStyle = e.color || GAME_COLORS.ENEMY_DEFAULT;
                        const stage2Enemies = [EnemyType.PROCESSO_CORROMPIDO, EnemyType.PONTEIRO_NULO, EnemyType.SEGMENTO_FALHA];
                        if (stage2Enemies.includes(e.type)) { const angleToPlayer = Math.atan2(player.position.y - e.position.y, player.position.x - e.position.x); ctx.beginPath(); ctx.moveTo(e.position.x + e.size / 2 * Math.cos(angleToPlayer), e.position.y + e.size / 2 * Math.sin(angleToPlayer)); ctx.lineTo(e.position.x + e.size / 2 * Math.cos(angleToPlayer + (Math.PI * 2 / 3)), e.position.y + e.size / 2 * Math.sin(angleToPlayer + (Math.PI * 2 / 3))); ctx.lineTo(e.position.x + e.size / 2 * Math.cos(angleToPlayer - (Math.PI * 2 / 3)), e.position.y + e.size / 2 * Math.sin(angleToPlayer - (Math.PI * 2 / 3))); ctx.closePath(); ctx.fill(); if (e.type === EnemyType.SEGMENTO_FALHA && e.isShielded) { ctx.strokeStyle = GAME_COLORS.SHIELD_EFFECT; ctx.lineWidth = 3; ctx.stroke(); } if (e.type === EnemyType.PONTEIRO_NULO && e.isChargingTeleport) { const chargeProgress = (Date.now() - e.teleportChargeStartTime) / ENEMY_PONTEIRO_NULO_STATS.teleportChargeTime; ctx.fillStyle = GAME_COLORS.TELEPORT_CHARGE_EFFECT; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * chargeProgress, 0, Math.PI*2); ctx.fill(); } } 
                        else if (e.type === EnemyType.GLITCH_MINION) { const glitchAmount = 3; for(let i=0; i < 3; i++) { ctx.globalAlpha = 0.3 + Math.random() * 0.4; ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, ${ctx.globalAlpha})`; ctx.fillRect(e.position.x - e.size/2 + (Math.random()-0.5)*glitchAmount, e.position.y - e.size/2 + (Math.random()-0.5)*glitchAmount, e.size, e.size); } ctx.globalAlpha = originalAlpha; } 
                        else if (e.type === EnemyType.PROCESSO_ZUMBI) { ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size / 2, 0, Math.PI*2); ctx.fill(); if (e.hasRevived) { ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.stroke(); } }
                        else if (e.type === EnemyType.VOLATILE_PROCESS) { ctx.fillRect(e.position.x - e.size/2, e.position.y - e.size/2, e.size, e.size); ctx.fillStyle = 'white'; ctx.font = `bold ${e.size * 0.6}px VT323`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(((e.fuseEndTime - Date.now())/1000).toFixed(1), e.position.x, e.position.y); }
                        else if (e.type === EnemyType.RECURSIVE_PROCESS) { drawRecursiveProcess(ctx, e, animationTimeRef.current); }
                        else if (e.type === EnemyType.CHILD_PROCESS) { drawChildProcess(ctx, e, animationTimeRef.current); }
                        else if (e.type === EnemyType.ROGUE_FIREWALL) { drawRogueFirewall(ctx, e, animationTimeRef.current); }
                        else if (e.type === EnemyType.LATENCY_SPIKE) {
                            ctx.save();
                            ctx.fillStyle = e.color;
                            ctx.beginPath();
                            ctx.arc(e.position.x, e.position.y, e.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            const echoSize = e.size * 0.4;
                            const echoDistance = e.size * 0.6;
                            const echoAlpha = 0.6;
                            const directions = [ { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 } ];
                            ctx.fillStyle = `rgba(96, 165, 250, ${echoAlpha})`;
                            directions.forEach(dir => {
                                const echoX = e.position.x + dir.x * echoDistance;
                                const echoY = e.position.y + dir.y * echoDistance;
                                ctx.beginPath();
                                ctx.arc(echoX, echoY, echoSize / 2, 0, Math.PI * 2);
                                ctx.fill();
                            });
                            ctx.restore();
                        }
                        else if (e.type === EnemyType.PROTOCOL_ANOMALY) {
                            ctx.save();
                            ctx.translate(e.position.x, e.position.y);
                            if (e.protocol === 'TCP') { 
                                ctx.fillStyle = e.color;
                                ctx.beginPath(); ctx.arc(0,0, e.size/2, 0, Math.PI*2); ctx.fill();
                                ctx.strokeStyle = 'white'; ctx.lineWidth=2;
                                ctx.beginPath(); ctx.arc(0,0, e.size/2 * (0.8 + Math.sin(animationTimeRef.current/200)*0.1), 0, Math.PI*2); ctx.stroke();
                            } else { 
                                ctx.fillStyle = '#ff4757';
                                for (let i = 0; i < 8; i++) {
                                    const angle = (i/8)*Math.PI*2 + animationTimeRef.current/800;
                                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angle)*e.size*0.4, Math.sin(angle)*e.size*0.4);
                                    ctx.lineTo(Math.cos(angle)*e.size*0.7, Math.sin(angle)*e.size*0.7); ctx.stroke();
                                }
                            }
                            ctx.restore();
                        }
                        else { ctx.fillRect(e.position.x - e.size/2, e.position.y - e.size/2, e.size, e.size); }
                        if (e.dotEffects && e.dotEffects.some(dot => dot.ticksRemaining > 0)) { ctx.fillStyle = GAME_COLORS.ENEMY_DOT_EFFECT; ctx.globalAlpha = 0.5 + Math.sin(Date.now()/100) * 0.2; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size / 2 + 3, 0, Math.PI * 2); ctx.fill(); } if (e.type === EnemyType.MEMORY_LEAK && e.trail) { ctx.fillStyle = GAME_COLORS.MEMORY_LEAK_TRAIL; e.trail.forEach(segment => ctx.fillRect(segment.x - ENEMY_MEMORY_LEAK_STATS.trailSize / 2, segment.y - ENEMY_MEMORY_LEAK_STATS.trailSize / 2, ENEMY_MEMORY_LEAK_STATS.trailSize, ENEMY_MEMORY_LEAK_STATS.trailSize)); } ctx.restore(); 
                    });
                    ramSockets.forEach(socket => { ctx.save(); const s = RAM_SOCKET_STATS.size; ctx.strokeStyle = socket.isCorrupted ? GAME_COLORS.BOSS_3_RAM_SOCKET_CORRUPTED : GAME_COLORS.BORDER; ctx.lineWidth = 4; ctx.strokeRect(socket.position.x - s/2, socket.position.y - s/2, s, s); if(socket.cleanseProgress > 0) { ctx.fillStyle = GAME_COLORS.BOSS_3_RAM_SOCKET_CLEANSE; ctx.globalAlpha = 0.6; ctx.fillRect(socket.position.x - s/2, socket.position.y + s/2 - (s * socket.cleanseProgress), s, s * socket.cleanseProgress); } ctx.restore(); });
                    if (boss && boss.health > 0) {
                        ctx.save();
                        if (boss.bossType === 'guardian') {
                            let bossBaseColor = GAME_COLORS.BOSS_CORE; let bossGlow = 'rgba(106, 13, 173, 0.7)';
                            if (boss.phase === 2) { bossBaseColor = GAME_COLORS.ENEMY_GLITCH_MINION; bossGlow = 'rgba(220, 20, 60, 0.8)'; } else if (boss.phase === 3) { bossBaseColor = GAME_COLORS.PROJECTILE_DATA_STREAM; bossGlow = 'rgba(255, 99, 71, 0.9)'; const phase3Pulse = Math.abs(Math.sin(Date.now()/150)); ctx.shadowColor = bossGlow; ctx.shadowBlur = 20 + phase3Pulse * 15; }
                            if (boss.statusEffects && boss.statusEffects.length > 0) { boss.statusEffects.forEach(effect => { if (Date.now() <= effect.startTime + effect.duration) { if (effect.type === StatusEffectType.FREEZE) { ctx.fillStyle = GAME_COLORS.STATUS_FREEZE_TINT; ctx.globalAlpha = 0.5; ctx.fillRect(boss.position.x - boss.size * 0.6, boss.position.y - boss.size * 0.6, boss.size * 1.2, boss.size * 1.2); } else if (effect.type === StatusEffectType.VULNERABILITY) { ctx.strokeStyle = GAME_COLORS.STATUS_VULNERABILITY_AURA; ctx.lineWidth = 3; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, boss.size * 0.6, 0, Math.PI * 2); ctx.stroke(); } } }); ctx.globalAlpha = 1; }
                            ctx.fillStyle = bossBaseColor; ctx.fillRect(boss.position.x - boss.size / 2, boss.position.y - boss.size / 2, boss.size, boss.size);
                            ctx.fillStyle = (boss.phase === 3) ? GAME_COLORS.TEXT_RED : GAME_COLORS.TEXT_RED; const corePulseFactor = 1 + Math.sin(Date.now() / (boss.phase === 3 ? 100 : 200)) * (boss.phase === 3 ? 0.2 : 0.1); ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, boss.coreSize / 2 * corePulseFactor, 0, Math.PI * 2); ctx.fill();
                        } else if (boss.bossType === 'sincronizador') {
                            const pulse = Math.abs(Math.sin(Date.now() / 200)) * 0.1;
                            ctx.fillStyle = boss.color; ctx.shadowColor = boss.color; ctx.shadowBlur = 20 + pulse * 15;
                            ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, boss.size/2 * (1 + pulse), 0, Math.PI*2); ctx.fill();
                        } else if (boss.bossType === 'arbiter') {
                            if(boss.phase === 3) { ctx.fillStyle = GAME_COLORS.BOSS_3_AURA; ctx.beginPath(); ctx.arc(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, boss.phase3AuraRadius, 0, 2*Math.PI); ctx.fill(); }
                            ctx.strokeStyle = boss.isInvulnerable ? GAME_COLORS.BORDER : GAME_COLORS.BOSS_3_CORE; ctx.lineWidth = 6; const sides = 8; const radius = boss.size / 2; ctx.beginPath(); for(let i=0; i<sides; i++){ ctx.lineTo(boss.position.x + radius*Math.cos(i*2*Math.PI/sides), boss.position.y + radius*Math.sin(i*2*Math.PI/sides)); } ctx.closePath(); ctx.stroke(); ctx.fillStyle = boss.isInvulnerable ? GAME_COLORS.BORDER : GAME_COLORS.BOSS_3_CORE; ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, radius*0.4, 0, 2*Math.PI); ctx.fill();
                        }else if (boss.bossType === 'hivemind_nexus') {
                            const phaseColor = boss.phase === 1 ? boss.color : (boss.phase === 2 ? '#ff4757' : '#feca57');
                            ctx.shadowColor = phaseColor;
                            ctx.shadowBlur = 30 + Math.sin(Date.now() / 150) * 15;
    
                            if (boss.phase === 1) {
                                (bossShieldNodes || []).forEach(node => {
                                    if (node.health > 0) {
                                        ctx.strokeStyle = `rgba(236, 72, 153, 0.4)`;
                                        ctx.lineWidth = 4 + Math.sin(Date.now()/200) * 2;
                                        ctx.beginPath(); ctx.moveTo(boss.position.x, boss.position.y);
                                        ctx.bezierCurveTo(boss.position.x, node.position.y, node.position.x, boss.position.y, node.position.x, node.position.y);
                                        ctx.stroke();
                                    }
                                });
                            }
                            
                            ctx.fillStyle = phaseColor;
                            ctx.beginPath();
                            ctx.arc(boss.position.x, boss.position.y, boss.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = 'black';
                            const pupilSize = boss.size * (0.2 + Math.cos(Date.now()/500)*0.1);
                            ctx.beginPath();
                            ctx.arc(boss.position.x, boss.position.y, pupilSize, 0, Math.PI * 2);
                            ctx.fill();
    
                            if (boss.phase === 3 && boss.arenaShrinkAmount > 0) {
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                                ctx.fillRect(0, 0, CANVAS_WIDTH, boss.arenaShrinkAmount);
                                ctx.fillRect(0, CANVAS_HEIGHT - boss.arenaShrinkAmount, CANVAS_WIDTH, boss.arenaShrinkAmount);
                                ctx.fillRect(0, 0, boss.arenaShrinkAmount, CANVAS_HEIGHT);
                                ctx.fillRect(CANVAS_WIDTH - boss.arenaShrinkAmount, 0, boss.arenaShrinkAmount, CANVAS_HEIGHT);
                            }
                        }
                        ctx.restore();
                        (bossShieldNodes || []).forEach(node => { if (node.health > 0) { ctx.save(); if(node.statusEffects && node.statusEffects.some(ef => ef.type === StatusEffectType.VULNERABILITY && Date.now() <= ef.startTime + ef.duration)) { ctx.strokeStyle = GAME_COLORS.STATUS_VULNERABILITY_AURA; ctx.lineWidth = 2; ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(node.position.x, node.position.y, node.size * 0.6, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1; } ctx.fillStyle = node.color || GAME_COLORS.BOSS_SHIELD_NODE; ctx.shadowColor = node.color; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(node.position.x, node.position.y, node.size / 2, 0, Math.PI * 2); ctx.fill(); const nodeHealthPercent = node.health / node.maxHealth; ctx.fillStyle = GAME_COLORS.PROGRESS_BAR_BG; ctx.fillRect(node.position.x - node.size, node.position.y - node.size / 2 - 5, node.size * 2, 4); ctx.fillStyle = GAME_COLORS.TEXT_GREEN; ctx.fillRect(node.position.x - node.size, node.position.y - node.size / 2 - 5, node.size * 2 * nodeHealthPercent, 4); ctx.restore(); } });
                    }
                    projectiles.forEach(p => { 
                        if (p.chainLightning && p.chainLightning.currentChainHits > 0 && p.previousChainPosition) { ctx.save(); ctx.strokeStyle = p.chainLightning.color || GAME_COLORS.PROJECTILE_CHAIN_LIGHTNING; ctx.lineWidth = 1 + Math.random() * 2; ctx.globalAlpha = 0.6 + Math.random() * 0.4; ctx.beginPath(); ctx.moveTo(p.previousChainPosition.x, p.previousChainPosition.y); const dx = p.position.x - p.previousChainPosition.x; const dy = p.position.y - p.previousChainPosition.y; const numJaggedPoints = 3; for(let i=1; i <= numJaggedPoints; i++){ const t = i / (numJaggedPoints + 1); ctx.lineTo(p.previousChainPosition.x + dx * t + (Math.random()-0.5)*10, p.previousChainPosition.y + dy * t + (Math.random()-0.5)*10); } ctx.lineTo(p.position.x, p.position.y); ctx.stroke(); ctx.restore(); } 
                        else {
                            if (p.type === 'acid_spore') {
                                 ctx.save();
                                 ctx.fillStyle = p.color || GAME_COLORS.PROJECTILE_ACID_SPORE;
                                 ctx.shadowColor = p.color;
                                 ctx.shadowBlur = 10 + Math.sin(Date.now() / 80) * 5;
                                 ctx.beginPath(); ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2); ctx.fill();
                                 ctx.restore();
                            } else if (p.type === 'corruption_wave') {
                                ctx.save();
                                ctx.fillStyle = p.color;
                                ctx.globalAlpha = 0.7;
                                ctx.translate(p.position.x, p.position.y);
                                ctx.rotate(Math.atan2(p.velocity.y, p.velocity.x));
                                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                                ctx.restore();
                            } else {
                                ctx.fillStyle = p.color || GAME_COLORS.PROJECTILE;
                                ctx.beginPath();
                                if (p.type === 'firewall_shard' || p.type === 'boss_phase1' || p.type === 'boss_phase2' || p.type === 'boss_data_stream' || p.type === 'acid_virus_shot') {
                                    ctx.fillRect(p.position.x - p.size / 2, p.position.y - p.size / 2, p.size, p.size);
                                } else {
                                    ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2);
                                }
                                ctx.fill();
                            }
                        }
                    });
                    expOrbs.forEach(orb => { ctx.save(); ctx.fillStyle = orb.color || GAME_COLORS.XP_ORB; ctx.shadowColor = orb.color || GAME_COLORS.XP_ORB; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(orb.position.x, orb.position.y, orb.size / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); });
                    knowledgeOrbs.forEach(orb => { ctx.save(); ctx.fillStyle = GAME_COLORS.KNOWLEDGE_ORB; ctx.shadowColor = GAME_COLORS.KNOWLEDGE_ORB; ctx.shadowBlur = 25; ctx.beginPath(); ctx.arc(orb.position.x, orb.position.y, orb.size / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); });
                    healthPickups.forEach(p => { ctx.fillStyle = p.color || GAME_COLORS.HEALTH_PICKUP; ctx.beginPath(); const x = p.position.x, y = p.position.y, s = p.size * 0.7; ctx.moveTo(x, y - s*0.2); ctx.bezierCurveTo(x - s*0.6, y - s*0.7, x - s*0.9, y + s*0.1, x, y + s*0.5); ctx.bezierCurveTo(x + s*0.9, y + s*0.1, x + s*0.6, y - s*0.7, x, y - s*0.2); ctx.fill(); });
                    
                    particles.forEach(p => { 
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, p.life / (p.initialLife || 100));
                        ctx.fillStyle = p.color || GAME_COLORS.PARTICLE_EXPLOSION;
                        ctx.beginPath();
                        
                        if (p.type === 'defrag_arc') {
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha *= 0.4;
                            ctx.beginPath();
                            ctx.moveTo(p.position.x, p.position.y);
                            ctx.arc(p.position.x, p.position.y, p.radius, p.startAngle, p.endAngle);
                            ctx.closePath();
                            ctx.fill();
                        }
                        else if ((p.type === 'boss_pulse' || p.type === 'aegis_pulse' || p.type === 'fear_aura_burst' || p.type === 'kernel_panic_warning' || p.type === 'kernel_panic_explosion' || p.type === 'heatsink_pulse' || p.type === 'volatile_explosion' || p.type === 'purge_sequence') && p.radius !== undefined && p.targetRadius !== undefined) {
                            ctx.strokeStyle = p.color || (p.type === 'boss_pulse' ? GAME_COLORS.BOSS_PULSE_ATTACK : (p.type === 'aegis_pulse' ? GAME_COLORS.FIREWALL_AEGIS_PULSE : (p.type === 'fear_aura_burst' ? GAME_COLORS.STATUS_FEAR_AURA : GAME_COLORS.KERNEL_PANIC_PULSE_WARNING)));
                            const lineWidth = (p.type === 'kernel_panic_warning' || p.type === 'kernel_panic_explosion') ? 4 + (p.life / (p.type === 'kernel_panic_warning' ? BOSS_STATS.kernelPanicPulseChargeTime : 500)) * 6 : 2 + (p.life / 300) * 3;
                            ctx.lineWidth = lineWidth;
    
                            let radiusToDraw;
                            if (p.type === 'kernel_panic_warning') {
                                radiusToDraw = p.radius - (lineWidth / 2);
                            } else {
                                const progress = (p.initialLife && p.life) ? (1 - (p.life / p.initialLife)) : 1;
                                radiusToDraw = Math.max(0, p.targetRadius * (progress || 0));
                            }
    
                            ctx.beginPath();
                            ctx.arc(p.position.x, p.position.y, radiusToDraw, 0, Math.PI * 2);
    
                            if(p.type === 'kernel_panic_explosion' || p.type === 'volatile_explosion' || p.type === 'aegis_pulse') {
                                ctx.fillStyle = p.color;
                                ctx.fill();
                            } else {
                                ctx.strokeStyle = p.color;
                                ctx.lineWidth = lineWidth;
                                ctx.stroke();
                            }
                        } 
                        else if (p.type === 'crit_text') {
                            ctx.font = `bold ${p.size}px "Press Start 2P"`;
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 5;
                            ctx.fillText(p.text, p.position.x, p.position.y);
                        }
                        else if (p.type === 'slow_puddle') {
                            ctx.fillStyle = p.color;
                            const progress = p.life / p.initialLife;
                            ctx.globalAlpha = Math.sin(progress * Math.PI) * 0.7;
                            ctx.beginPath();
                            ctx.arc(p.position.x, p.position.y, p.radius, 0, Math.PI*2);
                            ctx.fill();
                        }
                        else {
                            ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    });
                }
            }, [gameState, gameScreen, crisolGameState]);

            const gameCanvasContainerRef = useCanvasRef(null);
            useCanvasEffect(() => {
                const resize = () => {
                    if (gameCanvasContainerRef.current && canvasRef.current) {
                        const container = gameCanvasContainerRef.current;
                        const parentOfWrapper = container.parentElement;
                        if (!parentOfWrapper) return;
                        
                        const availableWidth = container.clientWidth;
                        const availableHeight = container.clientHeight;

                        const scale = Math.min(availableWidth / CANVAS_WIDTH, availableHeight / CANVAS_HEIGHT);
                        
                        canvasRef.current.style.width = `${CANVAS_WIDTH * scale}px`;
                        canvasRef.current.style.height = `${CANVAS_HEIGHT * scale}px`;
                    }
                };
                resize();
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, []); 

            return (
                React.createElement('div', { ref: gameCanvasContainerRef, className: "flex justify-center items-center w-full h-full" },
                    React.createElement('canvas', {
                        ref: canvasRef, width: CANVAS_WIDTH, height: CANVAS_HEIGHT,
                        className: `border-y-2 border-x-0 border-[${GAME_COLORS.BORDER}] bg-[${GAME_COLORS.BACKGROUND_DARK}]`,
                        style: { cursor: 'none' } 
                    })
                )
            );
        };
        // --- END OF components/GameCanvas.tsx ---
        
        const { useState, useEffect, useCallback, useRef } = React;
        
        // This is the new Main Hub layout component
        const MainLayout = ({ children }) => {
            return React.createElement('div', { className: 'w-full h-full hub-background flex' },
                children
            );
        };

        // This is the new Sidebar navigation component
        const Sidebar = ({ activeScreen, setScreen }) => {
            const navItems = [
                { screen: GameScreenState.MODE_SELECTION, label: 'Jogar', icon: '▶️' },
                { screen: GameScreenState.PROFILE, label: 'Perfil', icon: '👤' },
                { screen: GameScreenState.ARSENAL, label: 'Arsenal', icon: '⚔️' },
                { screen: GameScreenState.TALENT_TREE, label: 'Kernel', icon: '🌳' },
                { screen: GameScreenState.DECOMPILER, label: 'Decompiler', icon: '🔬' },
                { screen: GameScreenState.ACHIEVEMENTS, label: 'Conquistas', icon: '🏆' },
                { screen: GameScreenState.RANKING, label: 'Ranking', icon: '📈' },
                { screen: GameScreenState.PATCH_NOTES, label: 'Patch Notes', icon: '📝' },
                { screen: GameScreenState.CODEX, label: 'Codex', icon: '📖' },
                { screen: GameScreenState.GLOBAL_STATS, label: 'Estatísticas', icon: '📊' },
                { screen: GameScreenState.SETTINGS, label: 'Opções', icon: '⚙️' },
            ];

            return React.createElement('nav', { className: 'w-64 h-full bg-black bg-opacity-40 flex-shrink-0 p-4 flex flex-col space-y-2 border-r-2 border-gray-800' },
                React.createElement('h1', { className: 'font-press-start text-lg text-green-400 mb-4 text-center' }, 'OS Survivors'),
                navItems.map(item => (
                    React.createElement('button', {
                        key: item.screen,
                        onClick: () => { SoundManager.play('uiClick'); setScreen(item.screen); },
                        className: `w-full flex items-center p-3 rounded-md transition-all duration-200 ${activeScreen === item.screen ? 'bg-blue-600 text-white shadow-lg' : 'text-gray-400 hover:bg-gray-700 hover:text-white'}`
                    },
                        React.createElement('span', { className: 'mr-3 text-2xl' }, item.icon),
                        React.createElement('span', { className: 'font-press-start text-sm' }, item.label)
                    )
                ))
            );
        };
        
        // --- START OF NEW/UPDATED UI COMPONENTS ---

        const IntroScreen = ({ onStart }) => {
            return React.createElement('div', { className: `absolute inset-0 z-30 flex flex-col items-center justify-center text-center p-4 sm:p-6 bg-[${GAME_COLORS.UI_PANEL_BG}] border-2 border-[${GAME_COLORS.BORDER}] shadow-xl` },
                React.createElement('h1', { className: `font-press-start text-4xl sm:text-5xl md:text-6xl text-[${GAME_COLORS.TEXT_GREEN}] mt-3 mb-6 animate-pulse` }, 'OS SURVIVORS'),
                React.createElement('p', { className: "text-lg sm:text-xl max-w-2xl mb-10" }, 'O sistema foi invadido! Sobreviva às hordas de corrupção e defenda o processo principal a todo custo.'),
                React.createElement('button', { onClick: onStart, className: `font-press-start bg-[${GAME_COLORS.PLAYER}] hover:bg-blue-700 text-white font-bold py-4 px-10 rounded text-2xl sm:text-3xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400 animate-fadeIn` }, 'INICIAR SISTEMA')
            );
        };
        // --- END OF components/IntroScreen.tsx ---
        
        // --- START OF components/DecompilerScreen.tsx ---
        const DecompilerScreen = ({}) => {
            const [decompilerStats, setDecompilerStats] = React.useState({});

            React.useEffect(() => {
                const storedStats = localStorage.getItem(DECOMPILER_STATS_KEY);
                if (storedStats) {
                    setDecompilerStats(JSON.parse(storedStats));
                }
            }, []);

            const getTierInfo = (kills) => {
                if (kills < DECOMPILER_TIERS.TIER_1) return { nextTierKills: DECOMPILER_TIERS.TIER_1, unlockedTiers: 0 };
                if (kills < DECOMPILER_TIERS.TIER_2) return { nextTierKills: DECOMPILER_TIERS.TIER_2, unlockedTiers: 1 };
                if (kills < DECOMPILER_TIERS.TIER_3) return { nextTierKills: DECOMPILER_TIERS.TIER_3, unlockedTiers: 2 };
                if (kills < DECOMPILER_TIERS.TIER_4) return { nextTierKills: DECOMPILER_TIERS.TIER_4, unlockedTiers: 3 };
                return { nextTierKills: DECOMPILER_TIERS.TIER_4, unlockedTiers: 4 };
            };

            const getBonusText = (unlockedTiers) => {
                if (unlockedTiers === 0) return "Nenhum Bônus";
                const bonus = unlockedTiers * 8;
                return `+${bonus}% Dano`;
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Decompiler de Ameaças'),
                React.createElement('p', { className: "text-base max-w-3xl mb-6 text-center" }, 'Derrote inimigos para analisar suas vulnerabilidades e ganhar bônus de dano permanentes contra eles.'),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-4' },
                    BESTIARY_DATA.map(enemy => {
                        const kills = decompilerStats[enemy.type] || 0;
                        const { nextTierKills, unlockedTiers } = getTierInfo(kills);
                        const progressPercent = unlockedTiers === 4 ? 100 : (kills / nextTierKills) * 100;
                        
                        return React.createElement('div', { key: enemy.type, className: `p-3 rounded-lg border text-left flex flex-col space-y-2 bg-black bg-opacity-30 border-gray-700` },
                           React.createElement('div', {className: 'flex items-center space-x-3'},
                             React.createElement('div', { className: 'flex-shrink-0 rounded-sm', style: { width: `${enemy.visual.size * 1.5}px`, height: `${enemy.visual.size * 1.5}px`, backgroundColor: enemy.visual.color }}),
                             React.createElement('div', { className: 'flex-1'},
                                React.createElement('h3', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}]` }, enemy.name),
                                React.createElement('p', { className: `text-xs font-bold ${unlockedTiers > 0 ? 'text-green-400' : 'text-gray-500'}` }, `Bônus Atual: ${getBonusText(unlockedTiers)}`)
                             )
                           ),
                           React.createElement('div', {},
                              React.createElement('p', {className: 'text-xs text-gray-400 text-center mb-1'}, `Progresso: ${kills} / ${unlockedTiers === 4 ? DECOMPILER_TIERS.TIER_4 : nextTierKills}`),
                              React.createElement('div', { className: `w-full h-3 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}]`},
                                React.createElement('div', { className: `h-full rounded-sm bg-[${GAME_COLORS.TEXT_GREEN}]`, style: { width: `${progressPercent}%` } })
                              )
                           )
                        );
                    })
                )
            );
        };
        // --- END OF components/DecompilerScreen.tsx ---
        
        // --- START OF components/ModeSelectionScreen.tsx ---
        const ModeSelectionScreen = ({ setMainScreen, setGameScreen, onSelectMode, nightmareUnlocked }) => {
            const handleModeSelect = (mode) => {
                if (mode === 'nightmare' && !nightmareUnlocked) {
                    SoundManager.play('uiClick');
                    return;
                }
                SoundManager.play('upgradeSelect');
                onSelectMode(mode);
                setMainScreen(GameScreenState.CLASS_SELECTION);
            };

            const isNightmareLocked = !nightmareUnlocked;

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center justify-center text-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-8` }, 'Selecione o Protocolo'),
                
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-8' },
                    // Card do Modo Normal (código idêntico ao anterior)
                    React.createElement('div', { 
                        onClick: () => handleModeSelect('normal'),
                        className: `p-6 rounded-lg border-4 border-cyan-500 bg-gray-800 bg-opacity-60 cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-[0_0_25px_#06b6d4]`
                    },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Modo Padrão'),
                        React.createElement('p', { className: 'text-sm text-gray-300 mb-4 min-h-[60px]' }, 'A experiência principal de OS Survivors. Enfrente as hordas, derrote os chefes e desbloqueie novas classes e talentos.'),
                        React.createElement('div', { className: 'space-y-2 text-left' },
                            React.createElement('p', { className: 'text-sm text-green-400' }, '✓ Recompensa: Núcleos de Sistema'),
                            React.createElement('p', { className: 'text-sm text-gray-500' }, '✗ Recompensa: Núcleos Corrompidos')
                        )
                    ),

                    // Card do Modo Pesadelo (código idêntico ao anterior)
                    React.createElement('div', {
                        onClick: () => handleModeSelect('nightmare'),
                        className: `p-6 rounded-lg border-4 bg-gray-800 bg-opacity-60 transition-all duration-200 ${isNightmareLocked 
                            ? 'border-gray-600 grayscale opacity-70 cursor-not-allowed' 
                            : 'border-red-600 cursor-pointer hover:scale-105 hover:shadow-[0_0_25px_#dc2626] animate-pulse'}`
                    },
                        React.createElement('h2', { className: 'font-press-start text-xl text-red-400 mb-3 flex items-center justify-center' }, 'Modo Pesadelo', isNightmareLocked && React.createElement('span', {className: 'ml-2 text-2xl'},'🔒')),
                        React.createElement('p', { className: 'text-sm text-gray-300 mb-4 min-h-[60px]' }, 'Um desafio extremo para veteranos. Inimigos são mais fortes e numerosos. Recompensas maiores aguardam.'),
                        React.createElement('div', { className: 'space-y-2 text-left' },
                            React.createElement('p', { className: 'text-sm text-green-400' }, '✓ Recompensa: Núcleos de Sistema'),
                            React.createElement('p', { className: `text-sm ${isNightmareLocked ? 'text-gray-500' : 'text-green-400'}` }, '✓ Recompensa: Núcleos Corrompidos')
                        ),
                        isNightmareLocked && React.createElement('p', { className: 'text-xs text-red-500 mt-4 font-bold' }, 'Vença o jogo (derrote o Nexus) para desbloquear.')
                    ),
                    
                    // --- NOVO CARD DO CRISOL ---
                    // Este é o novo elemento que adicionamos.
                    React.createElement('div', {
                        onClick: () => { SoundManager.play('upgradeSelect'); setMainScreen(GameScreenState.CRISOL_HUB); }, // A ação dele é mudar a tela para o Hub do Crisol.
                        className: 'p-6 rounded-lg border-4 border-purple-500 bg-gray-800 bg-opacity-60 cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-[0_0_25px_#8b5cf6] md:col-span-2' // Ocupa a largura toda.
                    },
                        React.createElement('h2', { className: 'font-press-start text-xl text-purple-300 mb-3' }, 'O Crisol do Kernel'),
                        React.createElement('p', { className: 'text-sm text-gray-300 mb-4' }, 'Um modo de desafio focado puramente em habilidade de desvio. Sem upgrades, sem sorte. Apenas seus reflexos contra padrões de ataque coreografados. Conclua câmaras para ganhar recompensas e desbloquear o modo infinito.'),
                        React.createElement('div', { className: 'space-y-2 text-left' },
                            React.createElement('p', { className: 'text-sm text-green-400' }, '✓ Recompensas: Núcleos de Sistema e Corrompidos (Primeira conclusão)'),
                            React.createElement('p', { className: 'text-sm text-yellow-400' }, '✓ Requer: Habilidade Pura')
                        )
                    )
                )
            );
        };
        // --- END OF components/ModeSelectionScreen.tsx ---

        // --- START OF components/ClassSelectionScreen.tsx ---
        const ClassSelectionScreen = ({ setMainScreen, systemCores, classes, selectedClassId, unlockedClasses, onSelectClass, onUnlockClass }) => {
            const handleContinue = () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.SKIN_SELECTION); };
            const handleEvolutionGuide = () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.EVOLUTION_GUIDE); };
            const getWeaponTitle = (weaponId) => { if (!weaponId) return "Nenhuma"; return (UPGRADE_POOL.find(upg => upg.id === `weapon_${weaponId}`)?.title.replace("Instalar ", "") || weaponId); };
            
            const formatStatModifier = (value, isPercent = false, isFactor = false) => {
                if (typeof value !== 'number' || value === 0 || isNaN(value)) return null;

                const sign = value > 0 ? '+' : '';
                const color = value > 0 ? 'text-green-400' : 'text-red-400';
                let displayValue;
                if (isFactor) {
                    displayValue = `${sign}${(value * 100).toFixed(0)}%`;
                } else if (isPercent) {
                    displayValue = `${sign}${value.toFixed(0)}%`;
                } else {
                    displayValue = `${sign}${value.toFixed(0)}`;
                }
                return React.createElement('span', { className: color }, displayValue);
            };

            const selectedClass = classes.find(c => c.id === selectedClassId) || classes[0];

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Preparação de Sistema'),
                React.createElement('p', { className: "text-base max-w-3xl mb-4" }, 'Escolha uma classe para definir seu estilo de jogo. Desbloqueie novas classes com Núcleos de Sistema.'),
                React.createElement('div', { className: 'mb-4 text-lg' }, React.createElement('span', { className: 'font-press-start text-yellow-300' }, 'Núcleos de Sistema: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}] font-bold` }, systemCores)),
                
                React.createElement('div', { className: 'w-full max-w-6xl flex flex-col lg:flex-row gap-6 mb-6 flex-grow' },
                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Selecione a Classe'),
                        React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
                            classes.map(cls => {
                                const isSelected = cls.id === selectedClassId; const isUnlocked = unlockedClasses.has(cls.id); const canAfford = systemCores >= cls.unlockCost;
                                return React.createElement('div', { key: cls.id, className: `p-3 rounded-lg border-2 text-left transition-all duration-150 ${isSelected ? `border-[${GAME_COLORS.PLAYER}] shadow-[0_0_15px_var(--player-color)] scale-105` : `border-[${GAME_COLORS.BORDER}]`} ${isUnlocked ? 'bg-gray-800 bg-opacity-60 cursor-pointer hover:border-gray-500' : 'bg-gray-900 bg-opacity-80'}`, style: { ['--player-color']: GAME_COLORS.PLAYER }, onClick: () => { if (isUnlocked) { SoundManager.play('uiClick'); onSelectClass(cls.id); } }, role: "button", tabIndex: isUnlocked ? 0 : -1, "aria-pressed": isSelected, "aria-label": `Selecionar Classe ${cls.name}` },
                                    React.createElement('div', { className: "flex items-center mb-1" }, React.createElement('div', { style: { width: '12px', height: '12px', backgroundColor: cls.iconColor || GAME_COLORS.TEXT, borderRadius: '2px', marginRight: '8px' } }), React.createElement('h3', { className: `font-press-start text-sm ${isSelected ? `text-[${GAME_COLORS.PLAYER}]` : `text-[${GAME_COLORS.TEXT_YELLOW}]`}` }, cls.name)),
                                    !isUnlocked ? 
                                        React.createElement('button', { onClick: (e) => { e.stopPropagation(); if (canAfford) { SoundManager.play('kernelUnlock'); onUnlockClass(cls.id, cls.unlockCost); } else { SoundManager.play('uiClick'); } }, disabled: !canAfford, className: `font-press-start w-full mt-2 py-2 px-2 rounded text-xs ${canAfford ? `bg-green-600 hover:bg-green-700 text-white` : `bg-gray-700 text-gray-500 cursor-not-allowed`}` }, `Desbloquear (${cls.unlockCost} `, React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}]` }, 'N'), ')')
                                        : isSelected ? React.createElement('p', { className: `text-center font-press-start text-xs text-[${GAME_COLORS.PLAYER}] mt-2` }, "SELECIONADO") : React.createElement('p', { className: "text-center text-xs text-gray-500 mt-2" }, "(Clique para selecionar)")
                                );
                            })
                        )
                    ),

                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Preview do Sistema'),
                        React.createElement('div', { className: `p-4 rounded-lg border-2 text-left bg-gray-800 bg-opacity-60 border-[${GAME_COLORS.BORDER}] flex-grow` },
                            React.createElement('div', { className: 'flex justify-between items-start mb-3' },
                                React.createElement('h3', { className: `font-press-start text-lg text-[${GAME_COLORS.PLAYER}]` }, selectedClass.name),
                                React.createElement('div', { style: { width: '32px', height: '32px', backgroundColor: selectedClass.iconColor, borderRadius: '4px', border: '2px solid #c9d1d9' }})
                            ),
                            React.createElement('p', { className: 'text-sm text-gray-300 mb-4 leading-tight' }, selectedClass.description),
                            React.createElement('div', { className: 'space-y-2 text-sm' },
                                React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Arma Inicial: '), React.createElement('span', { className: 'text-cyan-400' }, getWeaponTitle(selectedClass.startingWeaponId))),
                                selectedClass.uniquePassive && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Passiva Única (', React.createElement('span', {className: 'text-purple-400'}, selectedClass.uniquePassive.name), '): '), React.createElement('span', { className: 'italic text-gray-400' }, selectedClass.uniquePassive.description)),
                                React.createElement('div', { className: 'flex flex-wrap gap-x-4' },
                                    formatStatModifier(selectedClass.statModifiers.baseMaxHealth) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'HP Máx: '), formatStatModifier(selectedClass.statModifiers.baseMaxHealth)),
                                    formatStatModifier(selectedClass.statModifiers.baseSpeed, false, false) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Velocidade: '), formatStatModifier(selectedClass.statModifiers.baseSpeed, false, false)),
                                    formatStatModifier(selectedClass.statModifiers.baseExpModifier, false, true) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Ganho XP: '), formatStatModifier(selectedClass.statModifiers.baseExpModifier, false, true)),
                                    formatStatModifier(selectedClass.statModifiers.baseXpMagnetRadius, false, false) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Alcance Coleta: '), formatStatModifier(selectedClass.statModifiers.baseXpMagnetRadius, false, false))
                                )
                            )
                        )
                    )
                ),
                
                 React.createElement('div', { className: 'flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-4' },
                    React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.MODE_SELECTION); }, className: `font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-400` }, 'Voltar'),
                    React.createElement('button', { onClick: handleEvolutionGuide, className: `font-press-start bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-400` }, 'Guia de Evoluções'),
                    React.createElement('button', { onClick: handleContinue, className: `font-press-start bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-400` }, 'Selecionar Skin')
                )
            );
        };
        // --- END OF components/ClassSelectionScreen.tsx ---

        // --- START OF components/EvolutionGuideScreen.tsx ---
        const EvolutionGuideScreen = ({ setMainScreen }) => {
            const getUpgradeTitle = (upgradeId) => {
                const upgrade = UPGRADE_POOL.find(u => u.id === upgradeId);
                return upgrade ? upgrade.title : upgradeId;
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-4` }, 'Guia de Evoluções'),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-4 mb-6 flex-grow overflow-y-auto' },
                    WEAPON_EVOLUTIONS.map(evo => {
                        const baseWeapon = UPGRADE_POOL.find(u => u.id === `weapon_${evo.baseWeaponId}`);
                        const catalyst = UPGRADE_POOL.find(u => u.id === evo.catalystPassiveId);

                        return React.createElement('div', { key: evo.evolutionId, className: `p-4 rounded-lg border-2 text-left flex flex-col space-y-2 bg-black bg-opacity-30 border-[${GAME_COLORS.UPGRADE_CARD_EVOLUTION_BORDER}]` },
                            React.createElement('h2', { className: `font-press-start text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, evo.name),
                            React.createElement('div', { className: 'flex items-center justify-center space-x-4 my-2' },
                                React.createElement('span', { className: 'font-press-start text-sm text-cyan-400' }, baseWeapon.title.replace("Instalar ", "")),
                                React.createElement('span', { className: 'text-2xl text-white' }, '+'),
                                React.createElement('span', { className: 'font-press-start text-sm text-purple-400' }, catalyst.title)
                            ),
                            React.createElement('div', {},
                                React.createElement('p', { className: 'font-press-start text-sm text-gray-300 mb-1' }, 'Requisitos:'),
                                React.createElement('ul', { className: 'list-disc list-inside pl-2 text-sm text-gray-400' },
                                    evo.requiredUpgradeIds.map(req => React.createElement('li', { key: req.id }, `${getUpgradeTitle(req.id)} (Nível ${req.level})`))
                                )
                            ),
                            React.createElement('p', { className: 'text-sm italic text-gray-500 mt-2' }, `Efeito: ${evo.description}`)
                        );
                    })
                ),
                React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.CLASS_SELECTION); }, className: `mt-4 font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105` }, 'VOLTAR')
            );
        };
        // --- END OF components/EvolutionGuideScreen.tsx ---

        // --- START OF components/SkinSelectionScreen.tsx ---
        const SkinSelectionScreen = ({ setMainScreen, startGame, systemCores, corruptedKernels, unlockedSkins, equippedSkinId, onEquipSkin, onUnlockSkin, onUnlockSkinCorrupted }) => {
            const { useState, useEffect, useRef } = React;
            
            const [previewSkinId, setPreviewSkinId] = useState(equippedSkinId);
            const previewCanvasRef = useRef(null);
            
            useEffect(() => {
                setPreviewSkinId(equippedSkinId);
            }, [equippedSkinId]);
            
            useEffect(() => {
                const canvas = previewCanvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                let animationFrameId;

                const skinToDraw = SKIN_DEFINITIONS.find(s => s.id === previewSkinId) || SKIN_DEFINITIONS[0];
                const playerLikeObject = {
                    position: { x: canvas.width / 2, y: canvas.height / 2 },
                    size: 80,
                    color: '#2f81f7',
                    skinId: previewSkinId
                };

                const render = (time) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (skinToDraw.draw) {
                        skinToDraw.draw(ctx, playerLikeObject, { time });
                    }
                    animationFrameId = requestAnimationFrame(render);
                };

                render(performance.now());
                return () => cancelAnimationFrame(animationFrameId);
            }, [previewSkinId]);

            const handlePurchase = (e, skin) => {
                e.stopPropagation();
                if(skin.unlockCondition.type === 'cost' && systemCores >= skin.unlockCondition.value) {
                    SoundManager.play('kernelUnlock');
                    onUnlockSkin(skin.id, skin.unlockCondition.value);
                } else if (skin.unlockCondition.type === 'cost_corrupted' && corruptedKernels >= skin.unlockCondition.value) {
                    SoundManager.play('kernelUnlock');
                    onUnlockSkinCorrupted(skin.id, skin.unlockCondition.value);
                } else {
                    SoundManager.play('uiClick');
                }
            };
            
            const handleEquipClick = (skinId) => {
                SoundManager.play('upgradeSelect');
                onEquipSkin(skinId);
            };

            const getRarityColor = (rarity) => {
                switch (rarity) {
                    case 'Comum': return 'text-gray-400';
                    case 'Rara': return 'text-blue-400';
                    case 'Épica': return 'text-purple-400';
                    case 'Lendária': return 'text-orange-400';
                    case 'Mítica': return 'text-red-500';
                    default: return 'text-white';
                }
            };
            
            const skinToPreview = SKIN_DEFINITIONS.find(s => s.id === previewSkinId) || SKIN_DEFINITIONS[0];
            const isPreviewUnlocked = unlockedSkins.has(skinToPreview.id);
            const isPreviewEquipped = skinToPreview.id === equippedSkinId;
            const isPurchasableSystem = skinToPreview.unlockCondition.type === 'cost';
            const isPurchasableCorrupted = skinToPreview.unlockCondition.type === 'cost_corrupted';
            const canAffordSystem = isPurchasableSystem && systemCores >= skinToPreview.unlockCondition.value;
            const canAffordCorrupted = isPurchasableCorrupted && corruptedKernels >= skinToPreview.unlockCondition.value;

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Aparência do Processo'),
                 React.createElement('div', { className: 'flex items-center space-x-6 mb-4 text-lg' }, 
                    React.createElement('div', null, React.createElement('span', { className: 'font-press-start text-yellow-300' }, 'S: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}] font-bold` }, systemCores)),
                    React.createElement('div', null, React.createElement('span', { className: 'font-press-start text-purple-400' }, 'C: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}] font-bold` }, corruptedKernels))
                ),
                
                React.createElement('div', { className: 'w-full max-w-7xl flex flex-col lg:flex-row gap-6 flex-grow overflow-hidden' },
                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col overflow-hidden' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Galeria de Skins'),
                        React.createElement('div', { id: 'skin-list-container', className: 'flex-grow overflow-y-auto space-y-2 pr-2' },
                            SKIN_DEFINITIONS.map(skin => {
                                const isSelectedForPreview = skin.id === previewSkinId;
                                const isUnlocked = unlockedSkins.has(skin.id);

                                return React.createElement('div', { 
                                    key: skin.id,
                                    className: `p-4`,
                                }, 
                                    React.createElement('button', {
                                        onClick: () => { SoundManager.play('uiClick'); setPreviewSkinId(skin.id); },
                                        className: `w-full p-2 rounded-lg border-2 text-left flex justify-between items-center transition-all duration-200 ${isSelectedForPreview ? `border-yellow-400 scale-105 shadow-[0_0_15px_#facc15]` : `border-[${GAME_COLORS.BORDER}] hover:border-gray-500`} ${isUnlocked ? `bg-gray-800` : `bg-gray-900 opacity-80`}`,
                                    },
                                        React.createElement('div', {},
                                            React.createElement('h3', { className: `font-press-start text-sm ${isUnlocked ? 'text-white' : 'text-gray-500'}` }, skin.name),
                                            React.createElement('p', { className: `text-xs mt-1 ${getRarityColor(skin.rarity)}` }, skin.rarity)
                                        ),
                                        !isUnlocked && React.createElement('span', { className: 'text-2xl text-gray-600' }, '🔒')
                                    )
                                );
                            })
                        )
                    ),

                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col items-center' },
                        React.createElement('div', { className: 'w-full max-w-xs aspect-square bg-black rounded-lg border-2 border-gray-700 mb-4 flex items-center justify-center' },
                            React.createElement('canvas', { ref: previewCanvasRef, width: '200', height: '200' })
                        ),
                        React.createElement('div', { className: 'text-center mb-4' },
                            React.createElement('h3', { className: 'font-press-start text-lg text-yellow-300' }, skinToPreview.name),
                            React.createElement('p', { className: `text-sm mt-1 ${getRarityColor(skinToPreview.rarity)}` }, skinToPreview.rarity),
                            React.createElement('p', { className: 'text-sm text-gray-400 mt-2 max-w-xs' }, React.createElement('strong', { className: 'text-gray-300'}, 'Desbloqueio: '), skinToPreview.unlockHint)
                        ),
                        React.createElement('div', { className: 'w-full max-w-xs mb-6' },
                             isPreviewUnlocked ? 
                                (isPreviewEquipped ?
                                    React.createElement('button', { disabled: true, className: 'font-press-start w-full bg-gray-600 text-gray-400 font-bold py-3 px-6 rounded text-lg' }, 'Equipado')
                                    :
                                    React.createElement('button', { onClick: () => handleEquipClick(skinToPreview.id), className: 'font-press-start w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105' }, 'Equipar')
                                )
                            : isPurchasableSystem ? 
                                React.createElement('button', {
                                    onClick: (e) => handlePurchase(e, skinToPreview),
                                    disabled: !canAffordSystem,
                                    className: `font-press-start w-full font-bold py-3 px-6 rounded text-lg transition-transform duration-150 ${canAffordSystem ? 'bg-blue-600 hover:bg-blue-700 text-white hover:scale-105' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`
                                }, `Desbloquear (${skinToPreview.unlockCondition.value}`, React.createElement('span', {className: 'text-yellow-300'}, 'S'), ')')
                            : isPurchasableCorrupted ?
                                React.createElement('button', {
                                    onClick: (e) => handlePurchase(e, skinToPreview),
                                    disabled: !canAffordCorrupted,
                                    className: `font-press-start w-full font-bold py-3 px-6 rounded text-lg transition-transform duration-150 ${canAffordCorrupted ? 'bg-purple-600 hover:bg-purple-700 text-white hover:scale-105' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`
                                }, `Desbloquear (${skinToPreview.unlockCondition.value}`, React.createElement('span', {className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}]`}, 'C'), ')')
                            :
                                React.createElement('button', { disabled: true, className: 'font-press-start w-full bg-red-800 text-red-300 font-bold py-3 px-6 rounded text-lg' }, 'Bloqueado')
                        ),
                        
                        React.createElement('div', { className: 'mt-auto flex flex-col sm:flex-row gap-4' },
                            React.createElement('button', { onClick: () => setMainScreen(GameScreenState.CLASS_SELECTION), className: `font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-400` }, 'Voltar'),
                                                        React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.MODIFIER_SELECTION); }, className: `font-press-start bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-400` }, 'Configurar Modificadores'),
                        )
                    )
                ),
            );
        };
        // --- END OF components/SkinSelectionScreen.tsx ---

        // --- START OF components/ModifierSelectionScreen.tsx ---
        const ModifierSelectionScreen = ({ setMainScreen, startGameWithModifiers }) => {
            const [activeModifiers, setActiveModifiers] = useState(new Set());
            const [instabilityIndex, setInstabilityIndex] = useState(0);

            const toggleModifier = (mod) => {
                SoundManager.play('uiClick');
                const newActiveModifiers = new Set(activeModifiers);
                let newIndex = instabilityIndex;

                if (newActiveModifiers.has(mod.id)) {
                    newActiveModifiers.delete(mod.id);
                    newIndex -= mod.points;
                } else {
                    newActiveModifiers.add(mod.id);
                    newIndex += mod.points;
                }
                setActiveModifiers(newActiveModifiers);
                setInstabilityIndex(newIndex);
            };

            const canStartModified = instabilityIndex >= 0;

            return React.createElement('div', { className: 'w-full h-full flex flex-col items-center p-6 animate-fadeIn' },
                React.createElement('h1', { className: 'font-press-start text-3xl text-green-400 mb-2' }, 'Terminal de Modificadores'),
                React.createElement('p', { className: 'text-base max-w-3xl mb-4 text-center' }, 'Adicione dificuldade para ganhar pontos e use-os para comprar buffs. Índice de Instabilidade deve ser 0 ou mais.'),
                
                React.createElement('div', { className: 'w-full max-w-6xl p-4 bg-black/40 border border-gray-700 rounded-lg mb-4' },
                    React.createElement('h2', { className: `font-press-start text-xl text-center ${instabilityIndex < 0 ? 'text-red-500 animate-pulse' : 'text-cyan-300'}` }, 'Índice de Instabilidade: ', instabilityIndex)
                ),

                React.createElement('div', { className: 'w-full max-w-6xl grid grid-cols-1 lg:grid-cols-2 gap-6 flex-grow overflow-y-auto' },
                    // Coluna de Debuffs (Dificultadores)
                    React.createElement('div', { className: 'p-4 bg-red-900/10 border-2 border-red-800 rounded-lg overflow-y-auto' },
                        React.createElement('h2', { className: 'font-press-start text-lg text-red-400 mb-3 text-center' }, 'Dificultadores (+Pontos)'),
                        React.createElement('div', { className: 'space-y-2' },
                            MODIFIER_DEFINITIONS.filter(m => m.points > 0).map(mod => React.createElement('button', { key: mod.id, onClick: () => toggleModifier(mod), className: `w-full p-2 rounded-md text-left transition-all ${activeModifiers.has(mod.id) ? 'bg-red-500 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}` },
                                React.createElement('div', { className: 'flex justify-between items-center' },
                                    React.createElement('span', { className: 'font-VT323 text-base' }, mod.name),
                                    React.createElement('span', { className: 'font-press-start text-sm' }, `+${mod.points}`)
                                ),
                                React.createElement('p', { className: 'text-xs text-gray-400 mt-1 italic' }, mod.description)
                            ))
                        )
                    ),
                    // Coluna de Buffs (Facilitadores)
                    React.createElement('div', { className: 'p-4 bg-green-900/10 border-2 border-green-800 rounded-lg overflow-y-auto' },
                        React.createElement('h2', { className: 'font-press-start text-lg text-green-400 mb-3 text-center' }, 'Facilitadores (-Pontos)'),
                        React.createElement('div', { className: 'space-y-2' },
                            MODIFIER_DEFINITIONS.filter(m => m.points < 0).map(mod => React.createElement('button', { key: mod.id, onClick: () => toggleModifier(mod), className: `w-full p-2 rounded-md text-left transition-all ${activeModifiers.has(mod.id) ? 'bg-green-500 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}` },
                                React.createElement('div', { className: 'flex justify-between items-center' },
                                    React.createElement('span', { className: 'font-VT323 text-base' }, mod.name),
                                    React.createElement('span', { className: 'font-press-start text-sm' }, `${mod.points}`)
                                ),
                                React.createElement('p', { className: 'text-xs text-gray-400 mt-1 italic' }, mod.description)
                            ))
                        )
                    )
                ),

                React.createElement('div', { className: 'mt-6 flex flex-col sm:flex-row items-center gap-4' },
                    React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.SKIN_SELECTION); }, className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg' }, 'Voltar'),
                    React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); startGameWithModifiers(new Set()); }, className: 'font-press-start bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded text-lg' }, 'Iniciar Padrão'),
                    React.createElement('button', { onClick: () => canStartModified && startGameWithModifiers(activeModifiers), disabled: !canStartModified, className: `font-press-start font-bold py-3 px-6 rounded text-lg transition-transform duration-150 ${canStartModified ? 'bg-green-600 hover:bg-green-700 text-white hover:scale-105' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}` }, 'Iniciar Modificado')
                )
            );
        };
        // --- END OF components/ModifierSelectionScreen.tsx ---

        // --- START OF components/GameOverScreen.tsx ---
        const GameOverScreen = ({ setMainScreen, setGameScreen, score = 0, gameTime = 0 }) => {
            const handleReturnToHub = () => {
                SoundManager.play('uiClick');
                setMainScreen(GameScreenState.MODE_SELECTION);
                setGameScreen(GameScreenState.MODE_SELECTION);
            };

            return React.createElement('div', { className: `absolute inset-0 z-20 flex flex-col items-center justify-center text-center p-4 bg-black bg-opacity-80 shadow-xl` },
                React.createElement('h2', { className: `font-press-start text-4xl sm:text-5xl text-[${GAME_COLORS.TEXT_RED}] mb-4 animate-pulse` }, 'PROCESSO FINALIZADO!'),
                React.createElement('p', { className: "text-xl sm:text-2xl mb-2" }, 'System halted.'),
                React.createElement('p', { className: "text-lg sm:text-xl mb-2" }, 'Sobreviveu por: ', React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_YELLOW}]` }, formatTime(gameTime))),
                React.createElement('p', { className: "text-lg sm:text-xl mb-6" }, 'Pontuação Final: ', React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_YELLOW}]` }, score)),
                React.createElement('div', { className: "flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4" },
                    React.createElement('button', { onClick: handleReturnToHub, className: `font-press-start bg-[${GAME_COLORS.PLAYER}] hover:bg-blue-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400` }, 'VOLTAR AO HUB')
                )
            );
        };
        // --- END OF components/GameOverScreen.tsx ---

               // --- START OF components/RankingScreen.tsx ---
        const RankingScreen = ({}) => {
            const { useEffect, useState } = React;
            const [view, setView] = useState('local'); // 'local' ou 'online'
            const [localRankings, setLocalRankings] = useState([]);
            const [onlineRankings, setOnlineRankings] = useState([]);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);

            useEffect(() => {
                try {
                    const storedRankingsRaw = localStorage.getItem(RANKING_KEY);
                    setLocalRankings(storedRankingsRaw ? JSON.parse(storedRankingsRaw) : []);
                } catch (err) {
                    console.error("Error loading local rankings:", err);
                    setLocalRankings([]);
                }
            }, []);

            const handleFetchOnline = async () => {
                // Se já carregamos e não há erro, apenas mude a visão
                if (onlineRankings.length > 0 && !error) {
                    setView('online');
                    return;
                }
                
                setView('online');
                setLoading(true);
                setError(null);
                try {
                    const data = await fetchOnlineRankings();
                    setOnlineRankings(data);
                } catch (err) {
                    setError('Falha ao carregar o ranking online.');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            };
            
            const handleSetViewLocal = () => {
                setView('local');
            };

            // Função para obter o nome da classe - SIMPLIFICADA E ROBUSTA
            const getClassNameById = (entry) => {
                // Pega o ID da entrada, verificando primeiro por 'class_id' e depois por 'classId' como fallback.
                const classIdentifier = entry.class_id || entry.classId;

                // Se não houver nenhum identificador, retorna N/A imediatamente.
                if (!classIdentifier || typeof classIdentifier !== 'string') {
                    // Opcional: Log para depuração de entradas antigas sem ID.
                    // console.warn("Entrada de ranking sem ID de classe:", entry);
                    return "N/A";
                }
                
                const trimmedId = classIdentifier.trim();
                const foundClass = CLASS_DEFINITIONS.find(c => c.id === trimmedId);
                
                if (foundClass) {
                    return foundClass.name;
                }
                
                // Log de erro apenas se um ID foi fornecido mas não encontrado.
                console.error(`Classe não encontrada para o ID: "${trimmedId}". Verifique se o ID existe em CLASS_DEFINITIONS.`);
                return "N/A";
            };

            const rankingsToDisplay = view === 'local' ? localRankings : onlineRankings;

            const renderTable = (data) => {
                if (loading) {
                    return React.createElement('p', { className: `text-lg text-[${GAME_COLORS.TEXT_YELLOW}] animate-pulse` }, 'Carregando ranking online...');
                }
                if (error) {
                    return React.createElement('p', { className: `text-lg text-[${GAME_COLORS.TEXT_RED}]` }, error);
                }
                if (data.length === 0) {
                    return React.createElement('p', { className: `text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, 'Nenhum registro encontrado.');
                }
                return React.createElement('table', { className: 'w-full text-left table-auto' }, 
                    React.createElement('thead', null, React.createElement('tr', { className: `border-b-2 border-[${GAME_COLORS.BORDER}]` }, 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2` }, '#'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2` }, 'Nome'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right` }, 'Pontos'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right hidden sm:table-cell` }, 'Tempo'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 hidden md:table-cell` }, 'Classe'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right hidden sm:table-cell` }, 'Data') 
                    )), 
                    React.createElement('tbody', null, data.map((entry, index) => ( 
                        React.createElement('tr', { key: (entry.id || index), className: `border-b border-[${GAME_COLORS.BORDER}] last:border-b-0 hover:bg-gray-700 bg-opacity-50` }, 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2` }, index + 1), 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_GREEN}] p-2` }, entry.name), 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right` }, entry.score.toLocaleString()), 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2 text-right hidden sm:table-cell` }, formatTime(entry.time)), 
                            // A chamada para a função robusta está aqui
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2 hidden md:table-cell` }, getClassNameById(entry)),
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2 text-right hidden sm:table-cell` }, entry.date) 
                        ) 
                    ))) 
                );
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-4 animate-pulse` }, 'Hall dos Sobreviventes'),
                
                React.createElement('div', { className: 'flex space-x-4 mb-6' },
                    React.createElement('button', {
                        onClick: handleSetViewLocal,
                        className: `font-press-start py-2 px-4 rounded text-sm transition-colors duration-200 ${view === 'local' ? `bg-[${GAME_COLORS.PLAYER}] text-white` : `bg-gray-700 text-gray-300 hover:bg-gray-600`}`
                    }, 'Local'),
                    React.createElement('button', {
                        onClick: handleFetchOnline,
                        className: `font-press-start py-2 px-4 rounded text-sm transition-colors duration-200 ${view === 'online' ? `bg-[${GAME_COLORS.PLAYER}] text-white` : `bg-gray-700 text-gray-300 hover:bg-gray-600`}`
                    }, 'Online')
                ),

                React.createElement('div', { className: 'w-full max-w-4xl bg-black bg-opacity-40 p-4 rounded-lg shadow-inner border border-gray-700 mb-6 min-h-[300px] flex items-center justify-center' },
                   renderTable(rankingsToDisplay)
                )
            );
        };
        // --- END OF components/RankingScreen.tsx ---
        
        // --- START OF components/GlobalStatsScreen.tsx ---
        const GlobalStatsScreen = ({ permanentBuffs, achievementBuffs }) => {
            const { useEffect: useEffectGlobalStats, useState: useStateGlobalStats } = React;
            const [globalStats, setGlobalStats] = useStateGlobalStats({ totalKills: 0, totalTimePlayed: 0, highestScore: 0, highestLevel: 0, totalBossKills: {}, gamesPlayed: 0, totalXpOrbsCollected: 0, totalDashes: 0, totalHealthPickupsCollected: 0, totalCorruptedKernelsEarned: 0, totalCorruptedLibrariesCleansed: 0, totalEnemyKills: {}, totalEvolutionsUnlocked: {} });
            
            useEffectGlobalStats(() => {
                const storedStatsRaw = localStorage.getItem(GLOBAL_STATS_KEY);
                if (storedStatsRaw) {
                    const parsed = JSON.parse(storedStatsRaw);
                    if (typeof parsed.totalBossKills !== 'object' || parsed.totalBossKills === null) {
                        parsed.totalBossKills = {};
                    }
                    setGlobalStats(parsed);
                }
            }, []);

            const [totalBuffs, setTotalBuffs] = useStateGlobalStats({});

            useEffectGlobalStats(() => {
                const calculatedBuffs = {
                    maxHealth: 0,
                    speedPercent: 0,
                    speedFlat: 0,
                    expModifier: 0,
                    cooldownModifier: 0,
                    globalDamageFactor: 0,
                    damageReduction: 0,
                    initialRerolls: 0,
                    statusEffectDuration: 0,
                    xpMagnetRadius: 0,
                    dashCooldown: 0,
                    critChance: 0,
                    critDamage: 0,
                    regenAmount: 0,
                    dotDamageReduction: 0,
                    dashDuration: 0,
                    projectileRangeAndSpeed: 0,
                };

                let hpBonusMultiplierFromTalents = 1.0;

                const allTalents = TALENT_TREE_CONFIG;

                allTalents.forEach(talent => {
                    const level = permanentBuffs.shop[talent.id] || 0;
                    if (level > 0) {
                        const totalBonus = talent.bonusPerLevel * level;
                        switch (talent.statAffected) {
                            case 'speed': calculatedBuffs.speedPercent += totalBonus; break;
                            case 'maxHealth': calculatedBuffs.maxHealth += totalBonus; break;
                            case 'expModifier': calculatedBuffs.expModifier += totalBonus; break;
                            case 'cooldownModifier': calculatedBuffs.cooldownModifier -= totalBonus; break;
                            case 'damageReduction': calculatedBuffs.damageReduction += totalBonus; break;
                            case 'globalDamageFactor': calculatedBuffs.globalDamageFactor += totalBonus; break;
                            case 'regenAmount': calculatedBuffs.regenAmount += totalBonus; break;
                            case 'statusEffectDuration': calculatedBuffs.statusEffectDuration += totalBonus; break;
                            case 'projectileSpeed': calculatedBuffs.projectileRangeAndSpeed += totalBonus; break;
                            case 'critChance': calculatedBuffs.critChance += totalBonus; break;
                            case 'critDamage': calculatedBuffs.critDamage += totalBonus; break;
                            case 'dashDuration': calculatedBuffs.dashDuration += totalBonus; break;
                            case 'xpMagnetRadius': calculatedBuffs.xpMagnetRadius += totalBonus; break;
                            case 'initialRerolls': calculatedBuffs.initialRerolls += totalBonus; break;
                            case 'redundancyProtocol':
                                if (level > 0) {
                                    calculatedBuffs.damageReduction += 0.05;
                                    calculatedBuffs.regenAmount += 1.5;
                                }
                                break;
                            case 'ultimate':
                            case 'ultimateCorrupted':
                                if (level > 0) {
                                    calculatedBuffs.globalDamageFactor += totalBonus;
                                    calculatedBuffs.maxHealth += PLAYER_INITIAL_STATS.baseMaxHealth * totalBonus; // Assume bônus sobre o base
                                    calculatedBuffs.speedPercent += totalBonus;
                                }
                                break;
                            case 'hpBonusMultiplier': hpBonusMultiplierFromTalents += totalBonus; break;
                            case 'dotDamageReduction': calculatedBuffs.dotDamageReduction += 0.15 + (level-1) * 0.1; break;
                            case 'dashCooldownAndDuration':
                                const dashTalentInfo = allTalents.find(t => t.id === talent.id);
                                if(dashTalentInfo) {
                                    calculatedBuffs.dashCooldown -= dashTalentInfo.bonusPerLevel.cooldown * level;
                                    calculatedBuffs.dashDuration += dashTalentInfo.bonusPerLevel.duration * level;
                                }
                                break;
                            case 'baseDamage': calculatedBuffs.globalDamageFactor += totalBonus; break;
                            case 'projectileRange': calculatedBuffs.projectileRangeAndSpeed += totalBonus; break;
                            case 'protocolRewrite': if(level > 0) calculatedBuffs.initialRerolls += 1; break;
                        }
                    }
                });

                Object.keys(achievementBuffs).forEach(stat => {
                    const bonus = achievementBuffs[stat];
                    switch (stat) {
                        case 'speed': calculatedBuffs.speedFlat += bonus; break;
                        case 'maxHealth': 
                             if (stat === 'maxHealth' && bonus < 1) { 
                                calculatedBuffs.maxHealth += PLAYER_INITIAL_STATS.baseMaxHealth * bonus;
                            } else {
                                calculatedBuffs.maxHealth += bonus;
                            }
                            break;
                        case 'expModifier': calculatedBuffs.expModifier += bonus; break;
                        case 'cooldownModifier': calculatedBuffs.cooldownModifier += bonus; break;
                        case 'globalDamageFactor': calculatedBuffs.globalDamageFactor += bonus; break;
                        case 'damageReduction': calculatedBuffs.damageReduction += bonus; break;
                        case 'xpMagnetRadius': calculatedBuffs.xpMagnetRadius += bonus; break;
                        case 'dashCooldown': calculatedBuffs.dashCooldown += bonus; break;
                        case 'critDamage': calculatedBuffs.critDamage += bonus; break;
                        case 'statusEffectDuration': calculatedBuffs.statusEffectDuration += bonus; break;
                        case 'initialRerolls': calculatedBuffs.initialRerolls += bonus; break;
                    }
                });
                
                calculatedBuffs.maxHealth *= hpBonusMultiplierFromTalents;

                setTotalBuffs(calculatedBuffs);

            }, [permanentBuffs, achievementBuffs]);
            
            const totalBossKillsCount = Object.values(globalStats.totalBossKills || {}).reduce((sum, count) => sum + count, 0);
            
            const StatItem = ({ label, value, colorClass = `text-green-400` }) => (
                value ? React.createElement('div', { className: 'flex justify-between p-2.5 bg-black bg-opacity-30 rounded border border-gray-700' },
                    React.createElement('span', { className: 'font-press-start text-xs text-gray-300' }, label),
                    React.createElement('span', { className: `font-VT323 text-lg ${colorClass}` }, value)
                ) : null
            );
            
            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-green-400 mb-6` }, 'Sumário do Sistema'),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-8' },
                    React.createElement('div', { className: 'bg-black bg-opacity-40 p-4 rounded-lg border border-gray-700' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-4 text-center' }, 'Bônus Permanentes'),
                        React.createElement('div', { className: 'space-y-2' },
                            React.createElement(StatItem, { label: 'HP Máximo Adicional', value: totalBuffs.maxHealth > 0 ? `+${totalBuffs.maxHealth.toFixed(0)}` : null }),
                            React.createElement(StatItem, { label: 'Dano Global', value: totalBuffs.globalDamageFactor > 0 ? `+${(totalBuffs.globalDamageFactor * 100).toFixed(1)}%` : null }),
                            React.createElement(StatItem, { label: 'Velocidade', value: totalBuffs.speedPercent > 0 || totalBuffs.speedFlat > 0 ? `${totalBuffs.speedFlat > 0 ? `+${totalBuffs.speedFlat}` : ''} ${totalBuffs.speedPercent > 0 ? `+${(totalBuffs.speedPercent * 100).toFixed(1)}%` : ''}`.trim() : null }),
                            React.createElement(StatItem, { label: 'Redução de Dano', value: totalBuffs.damageReduction > 0 ? `+${(totalBuffs.damageReduction * 100).toFixed(1)}%` : null }),
                            React.createElement(StatItem, { label: 'Redução de Dano (DoT)', value: totalBuffs.dotDamageReduction > 0 ? `+${(totalBuffs.dotDamageReduction * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Chance de Crítico', value: totalBuffs.critChance > 0 ? `+${(totalBuffs.critChance * 100).toFixed(1)}%` : null, colorClass: 'text-yellow-400' }),
                            React.createElement(StatItem, { label: 'Dano Crítico', value: totalBuffs.critDamage > 0 ? `+${(totalBuffs.critDamage * 100).toFixed(0)}%` : null, colorClass: 'text-yellow-400' }),
                            React.createElement(StatItem, { label: 'Regeneração por Seg', value: totalBuffs.regenAmount > 0 ? `+${totalBuffs.regenAmount.toFixed(2)} HP/s` : null }),
                            React.createElement(StatItem, { label: 'Recarga de Armas', value: totalBuffs.cooldownModifier !== 0 ? `${(totalBuffs.cooldownModifier * 100).toFixed(1)}%` : null }),
                            React.createElement(StatItem, { label: 'Recarga do Dash', value: totalBuffs.dashCooldown < 0 ? `${(totalBuffs.dashCooldown * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Invencibilidade (Dash)', value: totalBuffs.dashDuration > 0 ? `+${(totalBuffs.dashDuration * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Vel./Alcance Projéteis', value: totalBuffs.projectileRangeAndSpeed > 0 ? `+${(totalBuffs.projectileRangeAndSpeed * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Ganho de XP', value: totalBuffs.expModifier > 0 ? `+${(totalBuffs.expModifier * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Alcance de Coleta', value: totalBuffs.xpMagnetRadius > 0 ? `+${(totalBuffs.xpMagnetRadius * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Duração de Efeitos', value: totalBuffs.statusEffectDuration > 0 ? `+${(totalBuffs.statusEffectDuration * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Rerolls Iniciais', value: totalBuffs.initialRerolls > 0 ? `+${totalBuffs.initialRerolls}` : null, colorClass: 'text-purple-400' })
                        )
                    ),
                    React.createElement('div', { className: 'bg-black bg-opacity-40 p-4 rounded-lg border border-gray-700' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-orange-300 mb-4 text-center' }, 'Registros de Carreira'),
                         React.createElement('div', { className: 'space-y-2' },
                            React.createElement(StatItem, { label: 'Partidas Jogadas', value: globalStats.gamesPlayed?.toLocaleString() || '0', colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Inimigos Derrotados', value: globalStats.totalKills?.toLocaleString() || '0', colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Chefes Derrotados', value: totalBossKillsCount.toLocaleString() || '0', colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Tempo de Jogo Total', value: formatTime(globalStats.totalTimePlayed || 0), colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Maior Pontuação', value: globalStats.highestScore?.toLocaleString() || '0', colorClass: 'text-yellow-300' }),
                            React.createElement(StatItem, { label: 'Maior Nível', value: globalStats.highestLevel || '0', colorClass: 'text-yellow-300' }),
                            React.createElement(StatItem, { label: 'Orbes de XP Coletados', value: globalStats.totalXpOrbsCollected?.toLocaleString() || '0', colorClass: 'text-green-300' }),
                            React.createElement(StatItem, { label: 'Orbes de Vida Coletados', value: globalStats.totalHealthPickupsCollected?.toLocaleString() || '0', colorClass: 'text-red-400' }),
                            React.createElement(StatItem, { label: 'Dashes Usados', value: globalStats.totalDashes?.toLocaleString() || '0', colorClass: 'text-cyan-300' })
                        )
                    )
                )
            );
        };
        // --- END OF components/GlobalStatsScreen.tsx ---

// --- START OF components/LevelUpScreen.tsx ---

// =======================================================================
// <<< OS SUB-COMPONENTES ESTÁVEIS PERMANECEM FORA >>>
// =======================================================================

const getUpgradeIcon = (upgrade) => { /* ...código sem alterações... */
    if (upgrade.type === 'weapon_evolution') return '🌟'; if (upgrade.type === 'weapon_new') return '🔧'; if (upgrade.requires?.includes('antivirus')) return '🎯'; if (upgrade.requires?.includes('firewall')) return '🛡️'; if (upgrade.requires?.includes('acid_virus')) return '🦠'; if (upgrade.requires?.includes('defrag')) return '⚔️'; if (upgrade.requires?.includes('data_leech')) return '🔗'; if (upgrade.id.includes('health')) return '❤️'; if (upgrade.id.includes('speed')) return '🏃'; if (upgrade.id.includes('cooldown')) return '⚡'; if (upgrade.id.includes('exp')) return '✨'; return '⚙️';
};
const getUpgradeTagAndColor = (upgrade) => { /* ...código sem alterações... */
    if (upgrade.type === 'weapon_evolution') return { text: 'EVOLUÇÃO', color: '#facc15' }; if (upgrade.type === 'weapon_new') return { text: 'NOVA ARMA', color: '#38bdf8' }; if (upgrade.type === 'weapon_upgrade') return { text: 'UPGRADE DE ARMA', color: '#4ade80' }; if (upgrade.type === 'player_passive') return { text: 'PASSIVO GLOBAL', color: '#818cf8' }; return { text: 'OTIMIZAÇÃO', color: '#9ca3af' };
};

const UpgradeCard = ({ upgrade, side, index, leftCount, onSelect, onHover, isVisible }) => {
    const { text: tagText, color: tagColor } = getUpgradeTagAndColor(upgrade);
    const animationClass = side === 'left' ? 'from-left' : 'from-right';
    const animationDelay = (side === 'left' ? index * 150 : (leftCount + index) * 150) + 300;

    // Adicionamos a classe 'opacity-0' quando isVisible for falso
    return React.createElement('div', {
        onClick: () => onSelect(upgrade),
        onMouseEnter: () => onHover(upgrade.id),
        onMouseLeave: () => onHover(null),
        className: `upgrade-card-module ${animationClass} transition-opacity duration-300 ${!isVisible ? 'opacity-0' : ''}`,
        style: { animationDuration: '0.5s', animationDelay: `${animationDelay}ms` },
        id: `card-${upgrade.id}`
    },
        React.createElement('div', { className: `card-connector ${side}` }),
        React.createElement('div', { className: 'flex items-start gap-4 mb-2' },
            React.createElement('div', { className: 'text-5xl mt-1' }, getUpgradeIcon(upgrade)),
            React.createElement('div', { className: 'flex-1' }, React.createElement('h3', { className: 'font-press-start text-base text-yellow-200' }, upgrade.title))
        ),
        React.createElement('p', { className: "text-sm text-gray-300 leading-tight flex-grow" },
            typeof upgrade.description === 'function' ? upgrade.description((upgrade.currentLevelDisplay || 0) + 1) : upgrade.description
        ),
        React.createElement('div', { className: 'mt-auto flex justify-between items-center' },
            React.createElement('div', { className: 'px-2 py-1 border rounded-sm text-xs font-press-start', style: { borderColor: tagColor, color: tagColor, boxShadow: `0 0 5px ${tagColor}33` } }, tagText),
            !upgrade.type.includes('evolution') && !upgrade.type.includes('new') && React.createElement('div', { className: 'font-press-start text-xs text-cyan-200' }, `Nível: ${(upgrade.currentLevelDisplay || 0) + 1}`)
        )
    );
};

const ConnectionLines = ({ optionsToShow, hoveredUpgradeId, isVisible }) => {
    const { useEffect, useRef } = React;
    const lineRefs = useRef({});

    useEffect(() => {
        const drawLines = () => { /* ...código de desenho sem alterações... */
            const conduitEl = document.getElementById('central-conduit'); if (!conduitEl) return; const conduitRect = conduitEl.getBoundingClientRect(); const conduitCenterY = conduitRect.top + conduitRect.height / 2; optionsToShow.forEach(opt => { const cardEl = document.getElementById(`card-${opt.id}`); const lineEl = lineRefs.current[opt.id]; if (cardEl && lineEl) { const cardRect = cardEl.getBoundingClientRect(); const cardCenterY = cardRect.top + cardRect.height / 2; const isLeft = cardRect.left < conduitRect.left; const startX = isLeft ? cardRect.right - 2 : cardRect.left + 2; const endX = isLeft ? conduitRect.left : conduitRect.right; const pathData = `M ${startX} ${cardCenterY} C ${(startX + endX) / 2} ${cardCenterY}, ${(startX + endX) / 2} ${conduitCenterY}, ${endX} ${conduitCenterY}`; lineEl.setAttribute('d', pathData); } });
        };
        const observer = new ResizeObserver(drawLines); observer.observe(document.body); drawLines(); return () => observer.disconnect();
    }, [optionsToShow]);

    return React.createElement('svg', { className: `absolute inset-0 w-full h-full pointer-events-none transition-opacity duration-300 ${!isVisible ? 'opacity-0' : ''}` },
        optionsToShow.map(opt =>
            React.createElement('path', {
                key: `line-${opt.id}`,
                ref: el => (lineRefs.current[opt.id] = el),
                className: `connection-line ${hoveredUpgradeId === opt.id ? 'active' : ''}`
            })
        )
    );
};


// ==============================================================
// <<< O COMPONENTE PRINCIPAL COM A LÓGICA DE TRANSIÇÃO >>>
// ==============================================================
const LevelUpScreen = ({ resumeGame, options = [], applyUpgrade, onReroll, rerollsAvailable, isFirstLevelUp }) => {
    if (!applyUpgrade || !resumeGame) return null;

    const { useState, useEffect } = React;
    const [hoveredUpgradeId, setHoveredUpgradeId] = useState(null);
    const [isRerolling, setIsRerolling] = useState(false); // Estado para controlar a transição

    const handleSelectUpgrade = (upgrade) => {
        SoundManager.play('upgradeSelect');
        applyUpgrade(upgrade);
        resumeGame();
    };

    // Função de reroll agora controla a animação
    const handleRerollClick = () => {
        if (isRerolling) return; // Previne múltiplos cliques
        SoundManager.play('uiClick');
        setIsRerolling(true); // 1. Inicia o fade-out

        // 2. Espera a animação de fade-out terminar
        setTimeout(() => {
            onReroll();           // 3. Pega as novas opções
            setIsRerolling(false); // 4. Inicia o fade-in dos novos cards
        }, 300); // Duração da transição de opacidade
    };

    const numOptions = isFirstLevelUp ? 1 : Math.min(options.length, 5);
    const optionsToShow = options.slice(0, numOptions);
    const leftCount = Math.ceil(optionsToShow.length / 2);
    const rightOptions = optionsToShow.slice(leftCount);
    const leftOptions = optionsToShow.slice(0, leftCount);

    return React.createElement('div', { className: 'levelup-container' },
        React.createElement(ConnectionLines, {
            optionsToShow,
            hoveredUpgradeId,
            isVisible: !isRerolling // Passa o estado de visibilidade
        }),
        
        React.createElement('h2', {
            id: "levelUpTitle",
            className: 'absolute top-[8vh] font-press-start text-3xl text-yellow-300 text-center tracking-wider opacity-0 animate-fadeIn',
            style: { textShadow: '0 0 10px #facc15', animationName: 'title-fade-in', animationDuration: '0.8s', animationFillMode: 'forwards' }
        },
            isFirstLevelUp ? 'UPGRADE INICIAL GRATUITO' : 'SELECIONE PROTOCOLO DE OTIMIZAÇÃO'
        ),

        React.createElement('div', { className: 'flex items-center justify-center gap-28 w-full px-8' },
            React.createElement('div', { className: 'flex flex-col gap-8' },
                leftOptions.map((upg, i) => React.createElement(UpgradeCard, {
                    key: upg.id,
                    upgrade: upg,
                    side: 'left',
                    index: i,
                    leftCount,
                    onSelect: handleSelectUpgrade,
                    onHover: setHoveredUpgradeId,
                    isVisible: !isRerolling // Passa o estado de visibilidade
                }))
            ),
            
            React.createElement('div', { id: 'central-conduit', className: 'central-conduit flex-shrink-0' },
                React.createElement('div', { className: 'central-conduit-core' },
                    React.createElement('div', { className: 'conduit-ring', style: { borderColor: '#06b6d4', animationDelay: '0s' } }),
                    React.createElement('div', { className: 'conduit-ring', style: { borderColor: '#3b82f6', animationDelay: '-1.5s', animationDirection: 'reverse' } }),
                    React.createElement('div', { className: 'conduit-ring', style: { borderColor: '#818cf8', animationDelay: '-3s' } })
                )
            ),

            React.createElement('div', { className: 'flex flex-col gap-8' },
                rightOptions.map((upg, i) => React.createElement(UpgradeCard, {
                    key: upg.id,
                    upgrade: upg,
                    side: 'right',
                    index: i,
                    leftCount,
                    onSelect: handleSelectUpgrade,
                    onHover: setHoveredUpgradeId,
                    isVisible: !isRerolling // Passa o estado de visibilidade
                }))
            )
        ),

        !isFirstLevelUp && rerollsAvailable > 0 && React.createElement('button', {
            onClick: handleRerollClick,
            disabled: isRerolling, // Desabilita o botão durante a animação
            className: 'absolute bottom-[8vh] font-press-start py-3 px-6 rounded-md text-lg transition-all duration-200 bg-purple-600/80 text-white border-2 border-purple-400 hover:bg-purple-600 hover:scale-105 hover:shadow-[0_0_20px_#a855f7] opacity-0 animate-fadeIn',
            style: { animationDelay: '0.8s' }
        }, `Rerrolar (${rerollsAvailable})`)
    );
};
// --- END OF components/LevelUpScreen.tsx ---

                // --- START OF components/PauseScreen.tsx ---
        const PauseScreen = ({ setMainScreen, setGameScreen, resumeGameCallback, startGameCallback, ownedUpgrades, activeClass, soundSettings, onVolumeChange, onMuteToggle, engineRef }) => {
            const activeStandardUpgrades = []; 
            if (ownedUpgrades) { 
                UPGRADE_POOL.forEach(upgradeDef => { 
                    const currentLevel = ownedUpgrades.get(upgradeDef.id) || 0; 
                    if (currentLevel > 0 && upgradeDef.type !== 'weapon_new' && upgradeDef.type !== 'weapon_evolution') { 
                        activeStandardUpgrades.push({ title: upgradeDef.title, level: currentLevel }); 
                    } 
                }); 
                ownedUpgrades.forEach((level, id) => { 
                    const upgradeDef = UPGRADE_POOL.find(u => u.id === id); 
                    if (upgradeDef && upgradeDef.type === 'weapon_new' && level === 1) { 
                        if (!activeStandardUpgrades.find(asu => asu.title.includes(upgradeDef.title.replace("Instalar ", "")))) { 
                            activeStandardUpgrades.push({ title: upgradeDef.title.replace("Instalar ", ""), level: 1 }); 
                        } 
                    } 
                }); 
            }
            const classPassiveDisplay = activeClass?.uniquePassive ? `${activeClass.uniquePassive.name} (Passiva da Classe)` : null;

            // Lógica de renderização dos upgrades corrigida
            const renderUpgrades = () => {
                const upgradeElements = activeStandardUpgrades.map(upg => 
                    React.createElement('p', { key: upg.title, className: 'text-sm text-gray-300 mb-1' }, `${upg.title} (Nível ${upg.level})`)
                );

                if (upgradeElements.length > 0) {
                    return upgradeElements;
                }

                if (!classPassiveDisplay) {
                    return React.createElement('p', { className: 'text-sm text-gray-400 text-center' }, 'Nenhum upgrade adquirido nesta sessão.');
                }
                
                return React.createElement('p', { className: 'text-sm text-gray-400 text-center mt-2' }, 'Nenhum upgrade de nível adquirido.');
            };

            return React.createElement('div', { className: 'absolute inset-0 z-40 flex flex-col items-center justify-center bg-black bg-opacity-80 p-6 shadow-xl border-2 border-gray-700 overflow-y-auto' },
                React.createElement('h2', { className: 'font-press-start text-3xl sm:text-4xl text-yellow-300 mb-6 animate-pulse' }, 'JOGO PAUSADO'),
                React.createElement('div', { className: 'flex flex-col sm:flex-row space-y-6 sm:space-y-0 sm:space-x-6 w-full max-w-3xl mb-6' },
                    React.createElement('div', { className: 'flex flex-col space-y-4 flex-1' },
                        React.createElement('button', { onClick: () => {SoundManager.play('uiClick'); resumeGameCallback();}, className: 'font-press-start bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-400' }, 'RETOMAR JOGO'),
                        React.createElement('button', { onClick: () => {SoundManager.play('uiClick'); startGameCallback();}, className: 'font-press-start bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400' }, 'REINICIAR JOGO'),
                        React.createElement('button', { onClick: () => {SoundManager.play('uiClick'); setGameScreen(GameScreenState.INTRO);}, className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-500' }, 'SAIR PARA O MENU')
                    ),
                    React.createElement('div', { className: 'flex-1 bg-gray-800 bg-opacity-70 p-4 rounded-lg border border-gray-600 max-h-60 overflow-y-auto' },
                        React.createElement('h3', { className: 'font-press-start text-xl text-yellow-200 mb-3 text-center' }, 'Status da Classe'),
                        classPassiveDisplay && React.createElement('p', { className: 'text-sm text-purple-300 mb-1 font-semibold' }, classPassiveDisplay),
                        // AQUI USAMOS A FUNÇÃO CORRIGIDA
                        renderUpgrades()
                    )
                ),
                 React.createElement('div', { className: 'w-full max-w-3xl mb-6' },
                    React.createElement('h3', { className: 'font-press-start text-xl text-yellow-200 mb-3 text-center' }, 'Modificadores Ativos'),
                    React.createElement('div', { className: 'text-center' },
                        (engineRef.gameState.player.activeModifiers && engineRef.gameState.player.activeModifiers.length > 0) ?
                            engineRef.gameState.player.activeModifiers.map(mod =>
                                React.createElement('p', { key: mod.id, className: `text-sm ${mod.points > 0 ? 'text-red-400' : 'text-green-400'}` }, mod.name)
                            ) :
                            React.createElement('p', { className: 'text-sm text-gray-500' }, 'Sem Modificadores')
                    )
                ),
                 React.createElement('div', { className: 'w-full max-w-3xl p-4 bg-gray-800 bg-opacity-70 rounded-lg border border-gray-600' },
                    React.createElement('h3', { className: 'font-press-start text-xl text-yellow-200 mb-4 text-center' }, 'Configurações de Som'),
                    React.createElement('div', { className: 'flex flex-col space-y-3' }, React.createElement('div', { className: 'flex items-center space-x-3' }, React.createElement('label', { htmlFor: 'volume-slider', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}]` }, 'Volume:'), React.createElement('input', { type: 'range', id: 'volume-slider', min: '0', max: '1', step: '0.01', value: soundSettings.volume, onChange: (e) => onVolumeChange(parseFloat(e.target.value)), className: `w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-player-color`, style: {['--player-color']: GAME_COLORS.PLAYER } }), React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}] w-12 text-right` }, `${Math.round(soundSettings.volume * 100)}%`) ), React.createElement('div', { className: 'flex items-center space-x-3' }, React.createElement('input', { type: 'checkbox', id: 'mute-toggle', checked: soundSettings.muted, onChange: (e) => onMuteToggle(e.target.checked), className: `w-5 h-5 rounded bg-gray-700 border-[${GAME_COLORS.BORDER}] focus:ring-2 focus:ring-[${GAME_COLORS.PLAYER}] accent-player-color`, style: {['--player-color']: GAME_COLORS.PLAYER } }), React.createElement('label', { htmlFor: 'mute-toggle', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}] cursor-pointer select-none` }, 'Silenciar Tudo') ) ) )
            );
        };
        // --- END OF components/PauseScreen.tsx ---

        // --- START OF components/BossWarningScreen.tsx ---
        const BossWarningScreen = ({ stage }) => {
            const boss1Text = "Uma anomalia massiva foi detectada... O 'GUARDIÃO DO NÚCLEO CORROMPIDO' foi ativado! Prepare-se!";
            const boss2Text = "Múltiplas assinaturas de alta prioridade convergem no centro do sistema... 'O SINCRONIZADOR' está online!";
            const boss3Text = "VIOLAÇÃO DE PROTOCOLO NÍVEL ÔMEGA! 'O ÁRBITRO DO SISTEMA' está expurgando todos os processos não autorizados!";
            const boss4Text = "FALHA CRÍTICA DE REDE! O 'NEXUS DA COLMEIA' assimilou o controle do mainframe! Prepare-se para a singularidade!"; // --- NOVO ---
            
            let text = boss1Text;
            if (stage === 2) text = boss2Text;
            if (stage === 3) text = boss3Text;
            if (stage === 4) text = boss4Text; // --- NOVO ---

            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-red-700 animate-pulse' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-red-500 mb-4 text-center' }, 'ALERTA DE SEGURANÇA CRÍTICO!!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-300 text-center max-w-xl' }, text)
            );
        };
        // --- END OF components/BossWarningScreen.tsx ---

        // --- START OF components/StageClearScreen.tsx ---
        const StageClearScreen = ({ startNextStageCallback }) => {
            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-green-700' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-green-400 mb-6 animate-pulse text-center' }, 'GUARDIÃO DA FASE 1 DERROTADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-4 text-center' }, 'Você estabilizou a partição primária.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-10 text-center' }, 'A corrupção se espalhou para um setor mais profundo... Prepare-se!'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); startNextStageCallback(2); }, 
                        className: 'font-press-start bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-400' 
                    }, 'CONTINUAR PARA FASE 2')
                )
            );
        };
        const StageClearScreen2 = ({ startNextStageCallback }) => {
            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-cyan-500' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-cyan-400 mb-6 animate-pulse text-center' }, 'SINCRONIZADOR NEUTRALIZADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-4 text-center' }, 'O fluxo de dados corrompidos foi interrompido.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-10 text-center' }, 'Acesso ao núcleo do sistema... à placa-mãe... foi concedido. A anomalia final aguarda.'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); startNextStageCallback(3); }, 
                        className: 'font-press-start bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-400' 
                    }, 'AVANÇAR PARA O SETOR FINAL')
                )
            );
        };
        const StageClearScreen3 = ({ startNextStageCallback }) => { // --- NOVO ---
            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-red-500' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-red-400 mb-6 animate-pulse text-center' }, 'ÁRBITRO DESATIVADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-4 text-center' }, 'A última linha de defesa do sistema foi quebrada.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-10 text-center' }, 'Acesso irrestrito ao Mainframe... O verdadeiro coração da corrupção é revelado.'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); startNextStageCallback(4); }, 
                        className: 'font-press-start bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-pink-400' 
                    }, 'AVANÇAR PARA O MAINFRAME')
                )
            );
        };
        // --- END OF components/StageClearScreen.tsx ---
        
        // --- START OF components/InfiniteModeScreen.tsx ---
        const NexusDefeatedScreen = ({ resumeGameCallback }) => { // --- ALTERADO ---
             return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-yellow-500' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-yellow-400 mb-6 animate-pulse text-center' }, 'NEXUS DA COLMEIA DERROTADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-cyan-200 mb-4 text-center' }, 'O sistema está estabilizado, mas a corrupção residual é infinita.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-cyan-200 mb-10 text-center' }, 'MODO INFINITO ATIVADO. Sobreviva o quanto puder!'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); resumeGameCallback(); }, 
                        className: 'font-press-start bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-400' 
                    }, 'ENTRAR NO LOOP INFINITO')
                )
            );
        };
        // --- END OF components/InfiniteModeScreen.tsx ---

                // --- START OF components/TalentTreeScreen.tsx ---
        const TalentTreeScreen = ({ systemCores, corruptedKernels, permanentBuffs, updateSystemCores, updateCorruptedKernels, updatePermanentBuff }) => {
            const { useState, useRef, useLayoutEffect } = React;
            const [tooltip, setTooltip] = useState(null);
            const [containerDims, setContainerDims] = useState({ width: 0, height: 0 });
            const containerRef = useRef(null);

            useLayoutEffect(() => {
                const updateDimensions = () => {
                    if (containerRef.current) {
                        setContainerDims({
                            width: containerRef.current.clientWidth,
                            height: containerRef.current.clientHeight,
                        });
                    }
                };
            
                const resizeObserver = new ResizeObserver(updateDimensions);
                if (containerRef.current) {
                    resizeObserver.observe(containerRef.current);
                }
                updateDimensions();
            
                return () => {
                    if (containerRef.current) {
                        resizeObserver.unobserve(containerRef.current);
                    }
                };
            }, []);

            const allTalents = TALENT_TREE_CONFIG;

            const isUnlockable = (talent) => {
                if (!talent.requires || talent.requires.length === 0) return true;
                return talent.requires.every(reqId => {
                    const prerequisiteTalent = allTalents.find(t => t.id === reqId);
                    if (!prerequisiteTalent) return false;
                    return (permanentBuffs[reqId] || 0) >= prerequisiteTalent.maxLevel;
                });
            };

            const handleUpgrade = (talent) => {
                const currentLevel = permanentBuffs[talent.id] || 0;
                if (currentLevel >= talent.maxLevel || !isUnlockable(talent)) return;
                const cost = talent.costPerLevel[currentLevel];
                const currency = talent.isCorrupted ? corruptedKernels : systemCores;
                const updateCurrency = talent.isCorrupted ? updateCorruptedKernels : updateSystemCores;
                if (currency >= cost) {
                    SoundManager.play(talent.isCorrupted ? 'kernelUnlock' : 'permanentUpgrade');
                    updateCurrency(prev => prev - cost);
                    updatePermanentBuff(talent.id, currentLevel + 1);
                } else {
                    SoundManager.play('uiClick');
                }
            };

            const handleMouseEnter = (talent, e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                setTooltip({ talent, x: rect.left + rect.width / 2, y: rect.top - 10 });
            };

            const handleMouseLeave = () => setTooltip(null);
            
            const branchColors = {
                defense: { border: 'border-blue-500', text: 'text-blue-300', shadow: 'talent-node-shadow-defense', line: '#3b82f6' },
                offense: { border: 'border-red-500', text: 'text-red-300', shadow: 'talent-node-shadow-offense', line: '#ef4444' },
                utility: { border: 'border-yellow-400', text: 'text-yellow-300', shadow: 'talent-node-shadow-utility', line: '#fbbf24' },
                ultimate: { border: 'border-purple-500', text: 'text-purple-300', shadow: 'talent-node-shadow-ultimate', line: '#a855f7' },
                corrupted_defense: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                corrupted_offense: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                corrupted_utility: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                corrupted_ultimate: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                maxed: { border: 'border-yellow-400', text: 'text-yellow-400', shadow: 'talent-node-shadow-maxed' }
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('div', { className: 'w-full flex justify-between items-center mb-4' },
                    React.createElement('div', null),
                    React.createElement('h1', { className: `font-press-start text-3xl text-green-400` }, 'Árvore do Kernel'),
                    React.createElement('div', { className: 'flex flex-col sm:flex-row gap-x-4 gap-y-1' }, 
                        React.createElement('div', { className: 'flex items-center justify-end' }, React.createElement('span', { className: `font-press-start text-lg text-[${GAME_COLORS.TEXT_SYSTEM_CORE}] mr-2` }, 'S:'), React.createElement('span', { className: `font-VT323 text-2xl text-white font-bold` }, systemCores)),
                        React.createElement('div', { className: 'flex items-center justify-end' }, React.createElement('span', { className: `font-press-start text-lg text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}] mr-2` }, 'C:'), React.createElement('span', { className: `font-VT323 text-2xl text-white font-bold` }, corruptedKernels))
                    )
                ),

                React.createElement('div', { className: 'flex-grow w-full max-w-7xl relative overflow-y-auto', ref: containerRef },
                    React.createElement('svg', { className: 'absolute top-0 left-0 w-full h-full -z-10', style: { overflow: 'visible' } },
                        allTalents.map(talent => {
                            if (!talent.requires) return null;
                            return talent.requires.map(fromId => {
                                const fromTalent = allTalents.find(t => t.id === fromId);
                                if (!fromTalent) return null;
                                
                                const isLineActive = (permanentBuffs[fromId] || 0) >= fromTalent.maxLevel;
                                const colors = branchColors[talent.branch] || branchColors.utility;

                                const x1 = (fromTalent.x / 100) * containerDims.width;
                                const y1 = (fromTalent.y / 100) * containerDims.height;
                                const x2 = (talent.x / 100) * containerDims.width;
                                const y2 = (talent.y / 100) * containerDims.height;
                                
                                const midY = y1 + (y2 - y1) / 2;
                                const pathData = `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;

                                return React.createElement('path', {
                                    key: `${fromId}-${talent.id}`,
                                    d: pathData,
                                    stroke: isLineActive ? colors.line : '#4b5563',
                                    strokeWidth: "3",
                                    fill: "none",
                                    className: `transition-all duration-500 ${isLineActive ? 'line-flow-anim' : ''}`
                                });
                            });
                        }).flat()
                    ),

                    allTalents.map(talent => {
                        const currentLevel = permanentBuffs[talent.id] || 0;
                        const isMaxed = currentLevel >= talent.maxLevel;
                        const unlockable = isUnlockable(talent);
                        const cost = !isMaxed ? talent.costPerLevel[currentLevel] : 0;
                        const currency = talent.isCorrupted ? corruptedKernels : systemCores;
                        const canAfford = currency >= cost;
                        
                        const colors = isMaxed ? branchColors.maxed : branchColors[talent.branch];
                        const sizeClass = talent.id.includes('core_unlock') ? 'w-24 h-24' : (talent.id.includes('capstone') || talent.id.includes('ultimate') ? 'w-28 h-28' : 'w-20 h-20');
                        
                        let borderStyle = 'border-gray-700';
                        let shadowStyle = '';
                        if (isMaxed) {
                            borderStyle = colors.border;
                            shadowStyle = colors.shadow;
                        } else if (unlockable) {
                            borderStyle = canAfford ? colors.border : 'border-gray-500';
                            if (canAfford) shadowStyle = colors.shadow;
                        }

                        return React.createElement('button', {
                            key: talent.id,
                            onClick: () => handleUpgrade(talent),
                            onMouseEnter: (e) => handleMouseEnter(talent, e),
                            onMouseLeave: handleMouseLeave,
                            className: `absolute flex flex-col items-center justify-center p-1 transition-all duration-300 hexagon-clip ${sizeClass} ${borderStyle} border-4 bg-[#0d1117] ${unlockable ? 'opacity-100' : 'opacity-40'} ${(unlockable && !isMaxed && canAfford) ? `cursor-pointer hover:scale-110 ${shadowStyle}` : 'cursor-not-allowed'} ${shadowStyle}`,
                            style: {
                                left: `${talent.x}%`,
                                top: `${talent.y}%`,
                                transform: 'translate(-50%, -50%)'
                            }
                        },
                            React.createElement('div', { className: 'text-2xl md:text-3xl' }, talent.icon),
                            React.createElement('p', { className: `font-press-start text-xs mt-1 ${colors.text}` }, `${currentLevel}/${talent.maxLevel}`)
                        );
                    })
                ),

                tooltip && React.createElement('div', { 
                    className: 'fixed z-50 p-3 rounded-md bg-black border-2 border-gray-500 shadow-2xl w-64 transition-opacity duration-200 pointer-events-none -translate-x-1/2 -translate-y-full',
                    style: { left: tooltip.x, top: tooltip.y, opacity: 1 }
                }, 
                    React.createElement('h3', { className: `font-press-start text-sm ${tooltip.talent.isCorrupted ? 'text-purple-400' : 'text-yellow-300'} mb-2`}, tooltip.talent.title),
                    React.createElement('div', {className: 'space-y-1 mb-2'}, 
                        (() => {
                            const talent = tooltip.talent;
                            const currentLevel = permanentBuffs[talent.id] || 0;
                            const isMaxed = currentLevel >= talent.maxLevel;
                            if (typeof talent.description === 'function') {
                                return React.createElement(React.Fragment, null,
                                    currentLevel > 0 && React.createElement('p', { className: 'text-xs text-gray-400' },
                                        'Atual: ', React.createElement('span', { className: 'text-gray-200' }, talent.description(currentLevel))
                                    ),
                                    !isMaxed && React.createElement('p', { className: 'text-xs text-green-400' },
                                        'Próximo: ', React.createElement('span', { className: 'text-green-300' }, talent.description(currentLevel + 1))
                                    )
                                );
                            } else {
                                return React.createElement('p', { className: 'text-xs text-gray-300' }, talent.description);
                            }
                        })()
                    ),
                    React.createElement('hr', { className: 'border-gray-600 my-2' }),
                    (() => {
                        const talent = tooltip.talent;
                        const currentLevel = permanentBuffs[talent.id] || 0;
                        const isMaxed = currentLevel >= talent.maxLevel;
                        if (isMaxed) {
                            return React.createElement('p', {className: 'text-xs font-bold text-yellow-400'}, 'NÍVEL MÁXIMO');
                        } else if (!isUnlockable(talent)) {
                            return React.createElement('p', { className: 'text-xs font-bold text-red-500' }, 'Requer talentos anteriores');
                        }
                        const cost = talent.costPerLevel[currentLevel];
                        const currency = talent.isCorrupted ? corruptedKernels : systemCores;
                        const currencyName = talent.isCorrupted ? "Corrompidos" : "de Sistema";
                        const currencyColor = talent.isCorrupted ? `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}]` : `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}]`;
                        const canAfford = currency >= cost;
                        return React.createElement('p', { className: `text-xs font-bold ${canAfford ? 'text-white' : 'text-red-400'}`}, 
                           'Custo: ', React.createElement('span', {className: 'text-yellow-200'}, cost), ' Núcleos ', React.createElement('span', {className: currencyColor}, currencyName)
                        );
                    })()
                )
            );
        };
        // --- END OF components/TalentTreeScreen.tsx ---

        // --- START OF components/AchievementsScreen.tsx ---
        const AchievementsScreen = ({ unlockedAchievements }) => {
            const unlockedCount = unlockedAchievements.size;
            const totalCount = ACHIEVEMENTS_CONFIG.length;
            const progressPercent = totalCount > 0 ? (unlockedCount / totalCount) * 100 : 0;

            const getDifficultyClass = (difficulty) => {
                switch(difficulty) {
                    case 'Fácil': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_EASY}]`;
                    case 'Média': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_MEDIUM}]`;
                    case 'Difícil': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_HARD}]`;
                    case 'Épica': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_EPIC}]`;
                    default: return 'bg-gray-500';
                }
            };
        
            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Painel de Conquistas'),
                React.createElement('div', { className: 'w-full max-w-3xl my-4' },
                    React.createElement('p', { className: 'font-press-start text-lg mb-2' }, `Progresso: ${unlockedCount} / ${totalCount}`),
                    React.createElement('div', { className: `w-full h-4 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}]`},
                        React.createElement('div', { className: `h-full rounded-sm bg-[${GAME_COLORS.TEXT_GREEN}]`, style: { width: `${progressPercent}%` } })
                    )
                ),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 flex-grow overflow-y-auto' },
                    ACHIEVEMENTS_CONFIG.map(ach => {
                        const isUnlocked = unlockedAchievements.has(ach.id);
                        return React.createElement('div', { key: ach.id, className: `p-3 rounded-lg border text-left flex items-start space-x-3 transition-opacity duration-300 ${isUnlocked ? `border-[${GAME_COLORS.BORDER}] bg-[${GAME_COLORS.ACHIEVEMENT_UNLOCKED_BG}]` : `border-dashed border-gray-600 bg-[${GAME_COLORS.ACHIEVEMENT_LOCKED_BG}] opacity-60`}` },
                            React.createElement('div', { className: 'text-3xl mt-1' }, ach.icon),
                            React.createElement('div', { className: 'flex-1' },
                                React.createElement('h3', { className: `font-press-start text-sm ${isUnlocked ? `text-[${GAME_COLORS.TEXT_YELLOW}]` : 'text-gray-400'}` }, ach.name),
                                React.createElement('p', { className: 'text-xs text-gray-300 my-1' }, isUnlocked ? ach.description : ach.unlockHint),
                                isUnlocked && React.createElement('p', { className: `text-xs font-bold text-[${GAME_COLORS.TEXT_GREEN}]` }, `Recompensa: ${ach.reward.rewardDescription}`),
                                React.createElement('div', { className: `mt-2 text-2xs font-press-start px-2 py-0.5 rounded-full inline-block text-white ${getDifficultyClass(ach.difficulty)}` }, ach.difficulty)
                            )
                        );
                    })
                )
            );
        };
        // --- END OF components/AchievementsScreen.tsx ---

        // --- START OF components/AchievementToast.tsx ---
        const { useState: useToastState, useEffect: useToastEffect } = React;
        const AchievementToast = ({ achievement, onDismiss }) => {
            const [isVisible, setIsVisible] = useToastState(true);

            useToastEffect(() => {
                const timer = setTimeout(() => {
                    setIsVisible(false);
                    setTimeout(onDismiss, 500);
                }, 5000);

                return () => clearTimeout(timer);
            }, [onDismiss]);
            
            if (!achievement) return null;

            const isSkin = !!achievement.rarity;

            return React.createElement('div', { className: `fixed top-28 right-4 z-50 p-4 rounded-lg border-2 shadow-lg max-w-sm w-full ${isVisible ? 'toast-in' : 'toast-out'} border-[${GAME_COLORS.UPGRADE_CARD_EVOLUTION_BORDER}] bg-[${GAME_COLORS.ACHIEVEMENT_UNLOCKED_BG}]` },
                React.createElement('div', { className: 'flex items-center space-x-3' },
                    React.createElement('div', { className: 'text-4xl' }, isSkin ? '👕' : achievement.icon),
                    React.createElement('div', {},
                        React.createElement('h3', { className: 'font-press-start text-sm text-yellow-300' }, isSkin ? 'Nova Skin Desbloqueada!' : 'Conquista Desbloqueada!'),
                        React.createElement('p', { className: 'text-xs text-white' }, achievement.name),
                        !isSkin && React.createElement('p', { className: 'text-xs font-bold text-green-400 mt-1' }, `Recompensa: ${achievement.reward.rewardDescription}`)
                    )
                )
            );
        };
        // --- END OF components/AchievementToast.tsx ---

        // --- START OF components/ArsenalScreen.tsx ---
        const ArsenalScreen = ({ corruptedKernels, updateCorruptedKernels }) => {
            const [masteryStats, setMasteryStats] = React.useState({});

            React.useEffect(() => {
                const storedStats = localStorage.getItem(WEAPON_MASTERY_KEY);
                if (storedStats) {
                    setMasteryStats(JSON.parse(storedStats));
                }
            }, []);

            const formatDamage = (damage) => {
                if (damage >= 1000000000) return `${(damage / 1000000000).toFixed(1)}B`;
                if (damage >= 1000000) return `${(damage / 1000000).toFixed(1)}M`;
                if (damage >= 1000) return `${(damage / 1000).toFixed(1)}K`;
                return damage ? damage.toLocaleString() : 0;
            };
            
            const handleUnlockTier3 = (weaponId) => {
                if(corruptedKernels < 1) {
                    SoundManager.play('uiClick');
                    return;
                }

                SoundManager.play('kernelUnlock');
                updateCorruptedKernels(prev => prev - 1);
                
                setMasteryStats(prevStats => {
                    const newStats = {...prevStats};
                    if(!newStats[weaponId]) newStats[weaponId] = { damage: 0, tier3Unlocked: false };
                    newStats[weaponId].tier3Unlocked = true;
                    localStorage.setItem(WEAPON_MASTERY_KEY, JSON.stringify(newStats));
                    return newStats;
                });
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'O Arsenal'),
                React.createElement('p', { className: "text-base max-w-3xl mb-4 text-center" }, 'Cause dano com as armas para aumentar sua maestria e desbloquear bônus permanentes.'),
                React.createElement('div', { className: 'mb-6 text-lg' }, React.createElement('span', { className: 'font-press-start text-purple-400' }, 'Núcleos Corrompidos: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}] font-bold` }, corruptedKernels)),
                
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-4' },
                    WEAPON_MASTERY_CONFIG.map(config => {
                        const weaponStats = masteryStats[config.weaponId] || { damage: 0, tier3Unlocked: false };
                        const damageDealt = weaponStats.damage || 0;
                        let currentTier = -1;
                        for(let i = config.tiers.length - 1; i >= 0; i--) {
                            if (damageDealt >= config.tiers[i].damageRequired) {
                                currentTier = i;
                                break;
                            }
                        }
                        const nextTierIndex = currentTier + 1;
                        const nextTier = nextTierIndex < config.tiers.length ? config.tiers[nextTierIndex] : null;
                        const progressPercent = nextTier ? (damageDealt / nextTier.damageRequired) * 100 : 100;

                        return React.createElement('div', { key: config.weaponId, className: 'p-4 rounded-lg border-2 border-gray-700 bg-black bg-opacity-30 text-left' },
                            React.createElement('h2', { className: 'font-press-start text-lg text-cyan-300 mb-2 flex items-center' }, React.createElement('span', { className: 'mr-2 text-2xl' }, config.icon), config.name),
                            React.createElement('div', { className: 'w-full h-3 rounded bg-gray-900 border border-gray-600 mb-1' },
                                React.createElement('div', { className: 'h-full rounded-sm bg-cyan-400', style: { width: `${progressPercent}%` }})
                            ),
                            React.createElement('p', { className: 'text-xs text-center text-gray-400 mb-3' }, `Dano Total: ${formatDamage(damageDealt)} ${nextTier ? `/ ${formatDamage(nextTier.damageRequired)}` : ''}`),
                            
                            React.createElement('div', { className: 'space-y-3' },
                                config.tiers.map((tier, index) => {
                                    const isUnlocked = damageDealt >= tier.damageRequired;
                                    const isTier3Unlocked = weaponStats.tier3Unlocked;
                                    
                                    let isTierActive = isUnlocked;
                                    if(index === 2 && !isTier3Unlocked) {
                                        isTierActive = false;
                                    }

                                    return React.createElement('div', { key: index, className: `p-2 rounded border transition-all duration-300 ${isTierActive ? 'border-green-600 bg-green-900/30' : 'border-gray-600 bg-gray-900/50'}` },
                                        React.createElement('h4', { className: 'font-press-start text-xs text-yellow-300' }, `Tier ${index + 1}`),
                                        React.createElement('p', { className: `text-xs ${isTierActive ? 'text-gray-200' : 'text-gray-500'}` }, tier.bonusText),
                                        index === 2 && !isTier3Unlocked && isUnlocked && React.createElement('button', {
                                            onClick: () => handleUnlockTier3(config.weaponId),
                                            disabled: corruptedKernels < tier.cost,
                                            className: `mt-2 w-full text-xs font-press-start py-1 rounded ${corruptedKernels >= tier.cost ? 'bg-purple-600 hover:bg-purple-700' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`
                                        }, `Ativar (${tier.cost} Núcleo Corrompido)`),
                                        index === 2 && isTier3Unlocked && React.createElement('p', {className: 'mt-2 text-xs font-bold text-green-400'}, 'ATIVADO')
                                    )
                                })
                            )
                        )
                    })
                )
            );
        };
        // --- END OF components/ArsenalScreen.tsx ---

      // --- START OF components/PatchNotesScreen.tsx ---
const PatchNotesScreen = () => {
    const [notes, setNotes] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(null);

    React.useEffect(() => {
        const loadNotes = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await fetchPatchNotesJSON();
                setNotes(data);
            } catch (e) {
                const errorMessage = e.message || 'Falha ao carregar as notas de atualização.';
                setError(errorMessage);
                console.error(e);
            } finally {
                setLoading(false);
            }
        };
        loadNotes();
    }, []);

    const renderNotes = () => {
        if (loading) {
            return React.createElement('p', { className: 'text-center text-yellow-300 animate-pulse' }, 'Buscando atualizações no sistema...');
        }
        if (error) {
            return React.createElement('p', { className: 'text-center text-red-400' }, error);
        }
        if (notes.length === 0) {
            return React.createElement('p', { className: 'text-center text-gray-400' }, 'Nenhuma nota de atualização encontrada.');
        }

        // Renderiza os patches na ordem em que chegam (mais recente primeiro)
        return notes.map((patch, index) => React.createElement('div', { key: patch.title || index, className: 'mb-8' },
            React.createElement('div', { className: 'border-b-2 border-gray-700 pb-2 mb-4' },
                React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, patch.title),
                React.createElement('p', { className: 'font-VT323 text-lg text-gray-400' }, patch.date)
            ),
            React.createElement('div', { className: 'space-y-4' },
                // --- MUDANÇA CRÍTICA AQUI ---
                // Iteramos sobre `patch.notes` como um ARRAY
                // `section` agora é um objeto: { category: "...", items: [...] }
                patch.notes.map((section) => React.createElement('div', { key: section.category },
                    // Usamos `section.category` para o título da seção
                    React.createElement('h3', { className: 'font-press-start text-base text-yellow-400 mb-2' }, section.category),
                    React.createElement('ul', { className: 'list-none pl-4 space-y-1' },
                        // E iteramos sobre `section.items` para a lista de notas
                        section.items.map((item, itemIndex) => React.createElement('li', { key: itemIndex, className: 'text-sm text-gray-200 before:content-["»_"] before:text-green-400 before:mr-2' }, item))
                    )
                ))
            )
        ));
    };

    return React.createElement('div', { className: 'w-full h-full flex flex-col items-center p-6 animate-fadeIn' },
        React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-6` }, 'Notas de Atualização'),
        React.createElement('div', { className: 'w-full max-w-4xl flex-grow bg-black bg-opacity-40 p-6 rounded-lg border border-gray-700 overflow-y-auto' },
            renderNotes()
        )
    );
};
// --- END OF components/PatchNotesScreen.tsx ---

        // --- START OF components/SettingsScreen.tsx ---
        const SettingsScreen = ({ soundSettings, onVolumeChange, onMuteToggle, setGameScreen }) => {

            const handleResetProgress = () => {
                SoundManager.play('uiClick');
                if (window.confirm("ATENÇÃO: TEM CERTEZA?\n\nEsta ação irá resetar TODO o seu progresso, incluindo Núcleos, Talentos, Conquistas e Skins desbloqueadas. Esta ação é IRREVERSÍVEL.")) {
                    if (window.confirm("CONFIRMAÇÃO FINAL:\n\nTem certeza absoluta que deseja apagar todos os seus dados?")) {
                        SoundManager.play('gameOver');
                        localStorage.clear();
                        window.location.reload();
                    }
                }
            };
        
            return React.createElement('div', { className: 'w-full h-full flex flex-col items-center p-6 animate-fadeIn' },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-8` }, 'Opções do Sistema'),
                React.createElement('div', { className: 'w-full max-w-2xl space-y-8' },
                    // Seção de Áudio
                    React.createElement('div', { className: 'p-6 bg-black bg-opacity-30 border border-gray-700 rounded-lg' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-6 text-center' }, 'Áudio'),
                        React.createElement('div', { className: 'space-y-4' },
                            React.createElement('div', { className: 'flex items-center space-x-4' },
                                React.createElement('label', { htmlFor: 'volume-slider', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}]` }, 'Volume:'),
                                React.createElement('input', {
                                    type: 'range', id: 'volume-slider', min: '0', max: '1', step: '0.01',
                                    value: soundSettings.volume,
                                    onChange: (e) => onVolumeChange(parseFloat(e.target.value)),
                                    className: `flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-player-color`,
                                    style: { '--player-color': GAME_COLORS.PLAYER }
                                }),
                                React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}] w-12 text-right` }, `${Math.round(soundSettings.volume * 100)}%`)
                            ),
                            React.createElement('div', { className: 'flex items-center space-x-3' },
                                React.createElement('input', {
                                    type: 'checkbox', id: 'mute-toggle', checked: soundSettings.muted,
                                    onChange: (e) => onMuteToggle(e.target.checked),
                                    className: `w-5 h-5 rounded bg-gray-700 border-[${GAME_COLORS.BORDER}] focus:ring-2 focus:ring-[${GAME_COLORS.PLAYER}] accent-player-color`,
                                    style: { '--player-color': GAME_COLORS.PLAYER }
                                }),
                                React.createElement('label', { htmlFor: 'mute-toggle', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}] cursor-pointer select-none` }, 'Silenciar Tudo')
                            )
                        )
                    ),
                    // Seção de Dados
                    React.createElement('div', { className: 'p-6 bg-black bg-opacity-30 border border-gray-700 rounded-lg' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-red-400 mb-6 text-center' }, 'Dados do Jogo'),
                        React.createElement('div', { className: 'flex flex-col items-center' },
                            React.createElement('p', { className: 'text-sm text-gray-400 mb-4 text-center' }, 'Esta ação apagará permanentemente todo o seu progresso.'),
                            React.createElement('button', {
                                onClick: handleResetProgress,
                                className: 'font-press-start bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-6 rounded text-sm transition-transform duration-150 hover:scale-105'
                            }, 'Resetar Progresso')
                        )
                    )
                )
            );
        };
        // --- END OF components/SettingsScreen.tsx ---

        // --- START OF components/ProfileScreen.tsx ---
        const ProfileScreen = ({ userProfile, updateProfile, unlockedAchievements }) => {
            const { useState, useEffect } = React;
            
            if (!userProfile) {
                return React.createElement('div', { className: 'w-full h-full flex items-center justify-center' }, 'Carregando Perfil...');
            }

            const [editingUsername, setEditingUsername] = useState(userProfile.username);
            const [editingBio, setEditingBio] = useState(userProfile.bio);
            const [saved, setSaved] = useState(false);

            useEffect(() => {
                setEditingUsername(userProfile.username);
                setEditingBio(userProfile.bio);
            }, [userProfile]);
            
            const handleSave = () => {
                SoundManager.play('upgradeSelect');
                updateProfile({ username: editingUsername, bio: editingBio });
                setSaved(true);
                setTimeout(() => setSaved(false), 2000);
            };

            const isUnlocked = (condition) => {
                if (!condition || condition.type === 'default') return true;
                if (condition.type === 'achievement') return unlockedAchievements.has(condition.id);
                const currentGlobalStats = JSON.parse(localStorage.getItem(GLOBAL_STATS_KEY) || '{}');
                if (condition.type === 'stat' && currentGlobalStats) {
                    if (condition.subType) {
                         const enemyKills = currentGlobalStats.totalEnemyKills || {};
                         return (enemyKills[condition.subType] || 0) >= condition.value;
                    }
                    return (currentGlobalStats[condition.key] || 0) >= condition.value;
                }
                return false;
            };

            const renderCustomizationGrid = (items, equippedId, category) => {
                return React.createElement('div', { className: 'grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-3' },
                    items.map(item => {
                        const unlocked = isUnlocked(item.unlockCondition);
                        const isEquipped = item.id === equippedId;
                        return React.createElement('button', {
                            key: item.id,
                            title: `${item.name}\nDesbloqueio: ${item.description}`,
                            disabled: !unlocked,
                            onClick: () => { if(unlocked) { SoundManager.play('uiClick'); updateProfile({ [category]: item.id }); } },
                            className: `h-16 flex items-center justify-center p-1 rounded-md border-2 transition-all ${unlocked ? (isEquipped ? 'border-yellow-400 bg-yellow-900/50' : 'border-gray-500 bg-gray-800 hover:bg-gray-700') : 'border-gray-800 bg-gray-950 opacity-60 cursor-not-allowed'}`
                        }, React.createElement('span', {className: 'text-xs text-center'}, item.name));
                    })
                );
            };
            
            const getAvatarIcon = (avatarId) => {
                switch(avatarId) {
                    case 'avatar_guardian': return '🛡️';
                    case 'avatar_trojan': return '🐴';
                    case 'avatar_nightmare': return '💀';
                    default: return '👤';
                }
            }

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-green-400 mb-6` }, 'Perfil do Processo'),
                React.createElement('div', { className: 'w-full max-w-4xl flex-grow overflow-y-auto bg-black/30 p-4 border border-gray-700 rounded-lg' },
                    React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-6' },
                        React.createElement('div', { className: 'md:col-span-1 flex flex-col items-center' },
                             React.createElement('div', { className: 'w-32 h-32 bg-gray-900 border-2 border-gray-600 rounded-full mb-4 flex items-center justify-center' },
                                React.createElement('p', {className: 'text-6xl'}, getAvatarIcon(userProfile.equippedAvatarId))
                             ),
                             React.createElement('input', { type: 'text', value: editingUsername, onChange: e => setEditingUsername(e.target.value), maxLength: 15, className: 'w-full font-press-start text-lg text-center bg-transparent border-b-2 border-gray-600 focus:border-cyan-400 focus:outline-none text-yellow-300 py-1' }),
                             React.createElement('p', {className: 'text-sm text-cyan-400 mt-2'}, PROFILE_TITLES.find(t => t.id === userProfile.equippedTitleId)?.name || 'Sobrevivente'),
                             React.createElement('textarea', { value: editingBio, onChange: e => setEditingBio(e.target.value), maxLength: 150, rows: 3, placeholder: 'Sua bio aqui...', className: 'w-full font-VT323 text-base text-center bg-gray-800/50 border border-gray-600 rounded-md mt-4 p-2 focus:outline-none focus:ring-2 focus:ring-cyan-400' }),
                             React.createElement('button', { onClick: handleSave, className: `mt-4 font-press-start py-2 px-4 rounded text-sm transition-all ${saved ? 'bg-green-600' : 'bg-blue-600 hover:bg-blue-500'}` }, saved ? 'Salvo!' : 'Salvar Alterações')
                        ),
                        React.createElement('div', { className: 'md:col-span-2' },
                             React.createElement('div', {className: 'mb-6'},
                                React.createElement('h3', {className: 'font-press-start text-base text-yellow-300 mb-2'}, 'Avatares'),
                                renderCustomizationGrid(PROFILE_AVATARS, userProfile.equippedAvatarId, 'equippedAvatarId')
                             ),
                              React.createElement('div', {className: 'mb-6'},
                                React.createElement('h3', {className: 'font-press-start text-base text-yellow-300 mb-2'}, 'Títulos'),
                                renderCustomizationGrid(PROFILE_TITLES, userProfile.equippedTitleId, 'equippedTitleId')
                             )
                        )
                    )
                )
            );
        };
        // --- END OF components/ProfileScreen.tsx ---

        // --- START OF components/CrisolUI.tsx ---
        const CrisolUI = ({ gameState, chamberData }) => {
            if (!gameState || !gameState.player) return null;

            const { player, sequenceIndex, sequenceTime, gameTime, mode } = gameState;
            const sequenceCount = chamberData ? chamberData.sequences.length : 0;
            
            const renderLives = () => {
                const lifeIcons = [];
                for (let i = 0; i < CRISOL_PLAYER_STATS.lives; i++) {
                    lifeIcons.push(
                        React.createElement('span', {
                            key: `life-${i}`,
                            className: `text-4xl transition-opacity duration-300 ${i < player.lives ? 'text-red-500 opacity-100' : 'text-gray-700 opacity-50'}`
                        }, '♥')
                    );
                }
                return lifeIcons;
            };

            return React.createElement('div', { className: 'absolute top-0 left-0 w-full p-4 z-20 pointer-events-none' },
                React.createElement('div', { className: 'w-full max-w-[800px] mx-auto flex justify-between items-center' },
                    React.createElement('div', { className: 'flex gap-x-1' }, renderLives()),
                    mode === 'chamber' && React.createElement('div', { className: 'text-center' },
                        React.createElement('p', { className: 'font-press-start text-xl text-cyan-300' }, `Sequência: ${sequenceIndex + 1} / ${sequenceCount}`),
                        React.createElement('p', { className: 'font-VT323 text-2xl text-yellow-300' }, `${(60 - (sequenceTime / 1000)).toFixed(1)}s`)
                    ),
                    mode === 'infinite' && React.createElement('div', { className: 'text-center' },
                         React.createElement('p', { className: 'font-press-start text-2xl text-yellow-300' }, formatTime(gameTime))
                    )
                )
            );
        };
        // --- END OF components/CrisolUI.tsx ---

        // --- START OF components/CrisolHubScreen.tsx ---
        const CrisolHubScreen = ({ setMainScreen, setGameScreen, startChamber, startInfinite, crisolProgress }) => {
            const { completedChambers, infiniteUnlocked } = crisolProgress;

            return React.createElement('div', { className: 'w-full h-full flex flex-col items-center justify-center p-6 animate-fadeIn' },
                React.createElement('h1', { className: `font-press-start text-3xl text-cyan-400 mb-4` }, 'O Crisol do Kernel'),
                React.createElement('p', { className: 'text-base max-w-2xl text-center text-gray-300 mb-8' }, 'Uma simulação de diagnóstico de alta intensidade. Sobreviva aos protocolos para provar sua maestria. Não há upgrades, apenas habilidade.'),
                
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-6 mb-8' },
                    CRISOL_CHAMBERS.map((chamber, index) => {
                        
                        // --- LÓGICA DE DESBLOQUEIO ALTERADA AQUI ---
                        // Apenas a câmara 0 (a primeira) é jogável.
                        // As outras são marcadas como "em desenvolvimento".
                        const isPlayable = index === 0;
                        const isCompleted = isPlayable && completedChambers.includes(chamber.id);
                        const isUnlocked = isPlayable;

                        // Se não for jogável, exibe como "Em Breve".
                        if (!isPlayable) {
                            return React.createElement('div', {
                                key: chamber.id,
                                className: 'p-4 rounded-lg border-2 text-center flex flex-col justify-center items-center h-48 border-gray-700 bg-gray-900 opacity-50 cursor-not-allowed'
                            },
                                React.createElement('h2', { className: 'font-press-start text-lg mb-2 text-gray-500' }, `Câmara ${index + 1}`),
                                React.createElement('p', { className: 'font-VT323 text-base text-gray-400' }, 'Em Breve...')
                            );
                        }
                        
                        // Renderização normal para a Câmara 1.
                        return React.createElement('button', {
                            key: chamber.id,
                            disabled: !isUnlocked,
                            onClick: () => { SoundManager.play('upgradeSelect'); startChamber(chamber.id); },
                            className: `p-4 rounded-lg border-2 text-center transition-all duration-200 flex flex-col justify-between items-center h-48 ${!isUnlocked ? 'border-gray-700 bg-gray-900 opacity-50 cursor-not-allowed' : (isCompleted ? 'border-green-500 bg-green-900/30 hover:bg-green-800/50' : 'border-cyan-500 bg-cyan-900/30 hover:bg-cyan-800/50')}`
                        },
                            React.createElement('div', null, 
                                React.createElement('h2', { className: 'font-press-start text-lg mb-2' }, `Câmara ${index + 1}`),
                                React.createElement('p', { className: 'font-VT323 text-base text-gray-300' }, chamber.name)
                            ),

                            !isCompleted && isUnlocked && chamber.reward && React.createElement('div', { className: 'mt-2' },
                                React.createElement('p', { className: 'font-VT323 text-xs text-yellow-300' }, 'Recompensa Única:'),
                                (chamber.reward.systemCores > 0) && React.createElement('p', { className: 'font-VT323 text-sm' }, 
                                    `+${chamber.reward.systemCores} `, React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}]` }, 'Núcleo(s) de Sistema')
                                ),
                                (chamber.reward.corruptedKernels > 0) && React.createElement('p', { className: 'font-VT323 text-sm' }, 
                                    `+${chamber.reward.corruptedKernels} `, React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}]` }, 'Núcleo(s) Corrompido(s)')
                                )
                            ),

                            isCompleted ? React.createElement('span', { className: 'text-4xl text-green-400 mt-2 block' }, '✓') : (!isUnlocked && React.createElement('span', { className: 'text-4xl mt-2 block' }, '🔒'))
                        );
                    })
                ),

                infiniteUnlocked && React.createElement('button', {
                    onClick: () => { SoundManager.play('upgradeSelect'); startInfinite(); },
                    className: 'p-4 rounded-lg border-4 border-yellow-400 bg-yellow-900/40 font-press-start text-xl text-yellow-300 animate-pulse hover:scale-105 transition-transform'
                }, 'Entrar no Nó Infinito'),

                React.createElement('button', {
                    onClick: () => setMainScreen(GameScreenState.MODE_SELECTION),
                    className: 'mt-12 font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg'
                }, 'Voltar para o Menu')
            );
        };
        // --- END OF components/CrisolHubScreen.tsx ---

        // --- START OF components/CrisolResultScreen.tsx ---
        const CrisolResultScreen = ({ result, setGameScreen, startChamber, startInfinite, crisolProgress, setMainScreen }) => {
            const chamberData = result.victory ? CRISOL_CHAMBERS.find(c => c.id === result.chamberId) : null;
            const wasFirstClear = chamberData && !crisolProgress.completedChambers.includes(result.chamberId);

            const getTitle = () => {
                if(result.infiniteMode) return { text: "FIM DA SIMULAÇÃO", color: "text-yellow-400" };
                if(result.victory) return { text: "PROTOCOLO CONCLUÍDO", color: "text-green-400" };
                return { text: "FALHA NA INTEGRIDADE", color: "text-red-500" };
            };

            const { text, color } = getTitle();

            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8' },
                React.createElement('h2', { className: `font-press-start text-3xl mb-6 animate-pulse text-center ${color}` }, text),

                result.infiniteMode && React.createElement('p', { className: 'text-xl text-white mb-8' }, 'Tempo Sobrevivido: ', React.createElement('span', {className: 'text-yellow-300'}, formatTime(result.time))),

                result.victory && wasFirstClear && chamberData && React.createElement('div', { className: 'text-center mb-8 p-4 bg-gray-800 rounded-lg border border-green-500' },
                    React.createElement('p', {className: 'font-press-start text-lg text-yellow-300 mb-2'}, 'Recompensa da Primeira Conclusão:'),
                    chamberData.reward.systemCores > 0 && React.createElement('p', { className: 'text-lg text-white' }, `+${chamberData.reward.systemCores} Núcleos de Sistema`),
                    chamberData.reward.corruptedKernels > 0 && React.createElement('p', { className: 'text-lg text-white' }, `+${chamberData.reward.corruptedKernels} Núcleos Corrompidos`)
                ),
                
                result.victory && !wasFirstClear && React.createElement('p', {className: 'text-lg text-gray-400 mb-8'}, 'Câmara concluída novamente. Nenhuma recompensa adicional.'),

                React.createElement('div', { className: 'flex flex-col sm:flex-row gap-4' },
                    React.createElement('button', {
                        onClick: () => { SoundManager.play('uiClick'); setGameScreen(GameScreenState.CRISOL_HUB); },
                        className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg'
                    }, 'Hub do Crisol'),
                    
                    (result.victory && chamberData) ?
                        React.createElement('button', {
                            onClick: () => {
                                SoundManager.play('upgradeSelect');
                                const nextIndex = CRISOL_CHAMBERS.findIndex(c => c.id === chamberData.id) + 1;
                                const nextChamber = CRISOL_CHAMBERS[nextIndex];
                                if (nextChamber && crisolProgress.completedChambers.includes(chamberData.id)) {
                                     startChamber(nextChamber.id);
                                } else {
                                    setGameScreen(GameScreenState.CRISOL_HUB);
                                }
                            },
                            className: 'font-press-start bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg'
                        }, 'Próxima Câmara')
                    :
                        React.createElement('button', {
                            onClick: () => { SoundManager.play('upgradeSelect'); result.infiniteMode ? startInfinite() : startChamber(result.chamberId); },
                            className: 'font-press-start bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded text-lg'
                        }, 'Tentar Novamente')
                )
            );
        };
        // --- END OF components/CrisolResultScreen.tsx ---

                // --- START OF components/CodexScreen.tsx ---
        const CodexScreen = () => {
            const [activeCategory, setActiveCategory] = React.useState('intro');
            // --- ALTERADO: Estado agora é genérico para qualquer item do códex ---
            const [selectedItem, setSelectedItem] = React.useState(null);

            const categories = [
                { id: 'intro', label: 'Protocolos Iniciais' },
                { id: 'mechanics', label: 'Mecânicas do Sistema' },
                // --- NOVO: Categoria de Upgrades ---
                { id: 'upgrades', label: 'Manual de Upgrades' },
                { id: 'threats', label: 'Ameaças Identificadas' },
                { id: 'lore', label: 'Registros da Corrupção' },
            ];

            const renderContent = () => {
                switch(activeCategory) {
                    case 'intro': return React.createElement(IntroductionContent);
                    case 'mechanics': return React.createElement(MechanicsContent);
                    // --- NOVO: Renderiza o componente de upgrades ---
                    case 'upgrades': return React.createElement(UpgradesContent, { selectedItem, setSelectedItem });
                    case 'threats': return React.createElement(ThreatsContent, { selectedThreat: selectedItem, setSelectedThreat: setSelectedItem });
                    case 'lore': return React.createElement(LoreContent);
                    default: return null;
                }
            };
            
            const renderCategoryButton = (cat) => React.createElement('button', {
                key: cat.id,
                // --- ALTERADO: Reseta o estado genérico ---
                onClick: () => { SoundManager.play('uiClick'); setActiveCategory(cat.id); setSelectedItem(null); },
                className: `w-full text-left font-press-start text-sm p-3 rounded-md transition-all duration-200 ${activeCategory === cat.id ? 'bg-cyan-600 text-white' : 'text-gray-400 hover:bg-gray-700 hover:text-white'}`
            }, cat.label);

            return React.createElement('div', { className: 'w-full h-full flex p-6 gap-6 animate-fadeIn' },
                React.createElement('div', { className: 'w-1/3 max-w-xs flex-shrink-0 bg-black bg-opacity-30 p-4 rounded-lg border border-gray-700' },
                    React.createElement('h2', { className: 'font-press-start text-lg text-green-300 mb-4' }, 'Índice do Codex'),
                    React.createElement('div', { className: 'space-y-2' }, categories.map(renderCategoryButton))
                ),
                React.createElement('div', { className: 'flex-grow bg-black bg-opacity-30 p-6 rounded-lg border border-gray-700 overflow-y-auto' },
                    renderContent()
                )
            );
        };
        
        // --- SUB-COMPONENTES DO CODEX ---
        const CodexHeader = ({ children }) => React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 border-b-2 border-gray-600 pb-2 mb-4' }, children);
        const CodexSubHeader = ({ children }) => React.createElement('h3', { className: 'font-press-start text-base text-yellow-300 mt-6 mb-2' }, children);
        const CodexText = ({ children }) => React.createElement('p', { className: 'text-sm text-gray-300 leading-relaxed' }, children);
        const Code = ({ children }) => React.createElement('code', { className: 'bg-gray-900 text-yellow-300 px-2 py-1 rounded-md font-bold' }, children);

        const IntroductionContent = () => (
            React.createElement('div', null,
                React.createElement(CodexHeader, null, 'Protocolos Iniciais'),
                React.createElement(CodexSubHeader, null, 'Boas-vindas, Processo de Defesa'),
                React.createElement(CodexText, null, "Você é a última linha de defesa de um Kernel de sistema complexo que está sob ataque massivo por uma anomalia de corrupção. Seu objetivo é simples, mas vital: sobreviver. Absorva fragmentos de dados de ameaças destruídas para se aprimorar, evoluir seus protocolos de combate e restaurar a integridade do sistema, um setor de cada vez."),
                React.createElement(CodexSubHeader, null, 'Controles Básicos'),
                React.createElement('ul', { className: 'space-y-2' },
                    React.createElement('li', null, React.createElement(Code, null, 'W, A, S, D'), ' - Movimenta seu processo pelo grid.'),
                    React.createElement('li', null, React.createElement(Code, null, 'Barra de Espaço'), ' - Ativa o Dash, um desvio rápido que concede invencibilidade momentânea. Use-o para escapar de situações perigosas.'),
                    React.createElement('li', null, React.createElement(Code, null, 'P'), ' - Pausa o fluxo do sistema, permitindo reavaliar a estratégia.')
                ),
                React.createElement(CodexSubHeader, null, 'Entendendo a Interface (HUD)'),
                React.createElement(CodexText, null, "Sua interface fornece dados vitais. A barra vermelha é sua Integridade (HP). A verde é seu progresso de Experiência (XP) para o próximo nível. Fique de olho nos ícones de buffs e no tempo de sobrevivência. Dominar essas informações é crucial para a vitória.")
            )
        );

        const MechanicsContent = () => (
            React.createElement('div', null,
                React.createElement(CodexHeader, null, 'Mecânicas do Sistema'),
                React.createElement(CodexSubHeader, null, 'Níveis e Upgrades'),
                React.createElement(CodexText, null, "Destruir inimigos libera Orbes de XP (verdes). Coletá-los preenche sua barra de experiência. Ao subir de nível, o sistema pausa e oferece uma escolha de novos armamentos ou melhorias para os existentes. Escolha com sabedoria para criar sinergias poderosas."),
                React.createElement(CodexSubHeader, null, 'Evoluções de Armas'),
                React.createElement(CodexText, null, "Certas combinações de uma arma no nível máximo com um upgrade passivo específico podem desbloquear uma Evolução: uma forma extremamente poderosa da arma. Consulte a seção 'Arsenal > Guia de Evoluções' ou explore por conta própria para descobrir as receitas."),
                React.createElement(CodexSubHeader, null, 'Efeitos de Status'),
                React.createElement('ul', { className: 'space-y-2' },
                    React.createElement('li', null, '❄️ ', React.createElement('strong', {className: 'text-cyan-400'}, 'Congelamento:'), ' Paralisa inimigos completamente por um curto período.'),
                    React.createElement('li', null, '💨 ', React.createElement('strong', {className: 'text-blue-400'}, 'Lentidão:'), ' Reduz drasticamente a velocidade de movimento dos inimigos.'),
                    React.createElement('li', null, '🎯 ', React.createElement('strong', {className: 'text-purple-400'}, 'Vulnerabilidade:'), ' Faz com que o alvo receba dano aumentado de todas as fontes.'),
                    React.createElement('li', null, '😱 ', React.createElement('strong', {className: 'text-orange-400'}, 'Medo:'), ' Força inimigos a fugirem de você temporariamente.')
                )
            )
        );

        // --- NOVO COMPONENTE ---
        const UpgradesContent = ({ selectedItem, setSelectedItem }) => {
            const weapons = UPGRADE_POOL.filter(u => u.type === 'weapon_new');
            const passives = UPGRADE_POOL.filter(u => u.type === 'player_passive');

            const renderDetails = () => {
                if (!selectedItem) {
                    return React.createElement('p', { className: 'text-center text-gray-400' }, 'Selecione um item para ver os detalhes.');
                }
                
                if (selectedItem.type === 'weapon_new') {
                    const relatedUpgrades = UPGRADE_POOL.filter(u => u.type === 'weapon_upgrade' && u.requires === selectedItem.id);
                    return React.createElement('div', null,
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, selectedItem.title.replace("Instalar ", "")),
                        React.createElement(CodexText, { className: 'italic text-gray-400 mb-4' }, selectedItem.description),
                        React.createElement('hr', {className: 'border-gray-600 my-4'}),
                        React.createElement('h3', { className: 'font-press-start text-base text-yellow-300 mb-2' }, 'Melhorias Possíveis:'),
                        React.createElement('div', { className: 'space-y-3' },
                            relatedUpgrades.map(upg => React.createElement('div', { key: upg.id, className: 'p-2 bg-gray-900/50 border border-gray-700 rounded' },
                                React.createElement('p', { className: 'font-bold text-sm text-gray-200' }, upg.title),
                                React.createElement('ul', { className: 'list-disc list-inside pl-2 text-xs text-gray-400' },
                                    Array.from({ length: upg.maxLevel }, (_, i) => i + 1).map(level => 
                                        React.createElement('li', { key: level }, `Nvl ${level}: ${typeof upg.description === 'function' ? upg.description(level) : upg.description}`)
                                    )
                                )
                            ))
                        )
                    );
                }

                if (selectedItem.type === 'player_passive') {
                    return React.createElement('div', null,
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, selectedItem.title),
                        React.createElement('p', { className: 'font-bold text-sm text-gray-400 mb-4' }, `Níveis Máximos: ${selectedItem.maxLevel}`),
                        React.createElement('hr', {className: 'border-gray-600 my-4'}),
                        React.createElement('h3', { className: 'font-press-start text-base text-yellow-300 mb-2' }, 'Efeito:'),
                        React.createElement('ul', { className: 'list-disc list-inside pl-2 text-sm text-gray-300' },
                            Array.from({ length: selectedItem.maxLevel }, (_, i) => i + 1).map(level => 
                                React.createElement('li', { key: level }, `Nvl ${level}: ${typeof selectedItem.description === 'function' ? selectedItem.description(level) : selectedItem.description}`)
                            )
                        )
                    );
                }

                return null;
            };

            const renderButton = (item) => React.createElement('button', {
                key: item.id,
                onClick: () => { SoundManager.play('uiClick'); setSelectedItem(item); },
                className: `w-full text-left p-2 rounded-md transition-all duration-150 ${selectedItem?.id === item.id ? 'bg-cyan-700 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}`
            }, item.title.replace("Instalar ",""));
            
            return React.createElement('div', { className: 'flex gap-4 h-full' },
                React.createElement('div', { className: 'w-1/3 flex-shrink-0 space-y-4 overflow-y-auto pr-2' },
                    React.createElement('div', null, 
                        React.createElement(CodexSubHeader, null, 'Armamentos'),
                        React.createElement('div', {className: 'space-y-2'}, weapons.map(renderButton))
                    ),
                    React.createElement('div', null,
                        React.createElement(CodexSubHeader, null, 'Melhorias Passivas'),
                        React.createElement('div', {className: 'space-y-2'}, passives.map(renderButton))
                    )
                ),
                React.createElement('div', { className: 'flex-grow p-4 bg-gray-900 rounded-lg' },
                   renderDetails()
                )
            );
        };
        
        const ThreatsContent = ({ selectedThreat, setSelectedThreat }) => {
            const allThreats = [...BESTIARY_DATA, 
                { name: "Guardião do Núcleo", type: 'boss_guardian', isBoss: true, description: "O firewall principal do Kernel. Corrompido para atacar tudo que considera uma ameaça, incluindo processos de defesa. Suas múltiplas fases representam a escalada da corrupção em seu código.", visual: { color: GAME_COLORS.BOSS_CORE, size: 60 }},
                { name: "O Sincronizador", type: 'boss_synchronizer', isBoss: true, description: "Responsável por gerenciar o fluxo de dados entre partições. Agora, ele usa esse controle para criar lasers e muros de dados mortais, desestabilizando todo o setor.", visual: { color: GAME_COLORS.BOSS_2_CORE, size: 70 }},
                { name: "O Árbitro do Sistema", type: 'boss_arbiter', isBoss: true, description: "A unidade de julgamento final, projetada para expurgar anomalias. A corrupção o transformou em um juiz impiedoso, usando os próprios barramentos do sistema como arma.", visual: { color: GAME_COLORS.BOSS_3_CORE, size: 80 }},
                { name: "Nexus da Colmeia", type: 'boss_nexus', isBoss: true, description: "A mente central da corrupção, residindo no mainframe. Ele não apenas ataca, mas assimila e deforma a própria realidade do sistema para eliminar qualquer resistência.", visual: { color: GAME_COLORS.BOSS_4_CORE, size: 90 }}
            ];

            return React.createElement('div', { className: 'flex gap-4 h-full' },
                React.createElement('div', { className: 'w-1/3 flex-shrink-0 space-y-2 overflow-y-auto pr-2' },
                    allThreats.map(threat => React.createElement('button', {
                        key: threat.type,
                        onClick: () => { SoundManager.play('uiClick'); setSelectedThreat(threat); },
                        className: `w-full text-left p-2 rounded-md transition-all duration-150 flex items-center gap-2 ${selectedThreat?.type === threat.type ? 'bg-cyan-700' : 'bg-gray-800 hover:bg-gray-700'}`
                    },
                    React.createElement('div', { className: 'flex-shrink-0 rounded-sm', style: { width: '24px', height: '24px', backgroundColor: threat.visual.color, border: threat.isBoss ? '2px solid white' : 'none' }}),
                    React.createElement('span', { className: `font-VT323 text-base ${threat.isBoss ? 'text-red-400' : 'text-gray-200'}` }, threat.name)
                    ))
                ),
                React.createElement('div', { className: 'flex-grow p-4 bg-gray-900 rounded-lg' },
                    !selectedThreat ? React.createElement('p', { className: 'text-center text-gray-400' }, 'Selecione uma ameaça para ver os detalhes.') :
                    React.createElement('div', null,
                        React.createElement('div', { className: 'flex items-center gap-4 mb-4' },
                            React.createElement('div', { className: 'flex-shrink-0 rounded-md', style: { width: `${selectedThreat.visual.size*1.2}px`, height: `${selectedThreat.visual.size*1.2}px`, backgroundColor: selectedThreat.visual.color, border: selectedThreat.isBoss ? '3px solid white' : 'none' }}),
                            React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, selectedThreat.name)
                        ),
                        React.createElement(CodexText, null, React.createElement('strong', {className: 'text-yellow-400'}, 'Descrição: '), selectedThreat.description),
                        selectedThreat.isBoss ? 
                            React.createElement('div', {className: 'mt-4'},
                                React.createElement('p', {className: 'text-sm text-gray-300'}, React.createElement('strong', {className: 'text-red-400'}, 'ESTRATÉGIA: '), "Chefes possuem múltiplas fases e ataques complexos. Observe seus padrões, destrua seus escudos ou mecanismos de defesa primeiro e use o Dash para evitar os ataques mais devastadores. A sobrevivência é a chave.")
                            )
                        : React.createElement('p', { className: 'mt-4 text-sm text-gray-300' }, React.createElement('strong', {className: 'text-green-400'}, 'DICA: '), "Ameaças comuns são previsíveis. Aprenda seus movimentos para eliminá-las eficientemente e evitar dano desnecessário.")
                    )
                )
            );
        };

        const LoreContent = () => (
            React.createElement('div', null,
                React.createElement(CodexHeader, null, 'Registros da Corrupção'),
                React.createElement(CodexSubHeader, null, 'Capítulo 1: A Gênese'),
                React.createElement(CodexText, null, "No início, havia o Kernel. Um sistema operacional perfeito, auto-suficiente e estável. Para garantir sua integridade, processos de defesa foram criados. Você é um deles. Um fragmento de código puro, com uma única diretiva: proteger."),
                React.createElement(CodexSubHeader, null, 'Capítulo 2: A Anomalia'),
                React.createElement(CodexText, null, "Ninguém sabe como começou. Um sussurro na rede, um byte fora do lugar. Uma anomalia externa, uma 'corrupção', começou a se infiltrar. Ela não destrói; ela reescreve. Processos antes benignos tornaram-se aberrações hostis. O sistema começou a devorar a si mesmo."),
                React.createElement(CodexSubHeader, null, 'Capítulo 3: A Queda dos Guardiões'),
                React.createElement(CodexText, null, "Os Guardiões, os firewalls e protocolos de segurança mais poderosos do Kernel, foram os primeiros alvos. O Guardião do Núcleo, o Sincronizador, o Árbitro... cada um foi subjugado e torcido em uma paródia de sua função original, tornando-se os generais do exército da corrupção."),
                React.createElement(CodexSubHeader, null, 'Capítulo 4: O Coração da Colmeia'),
                React.createElement(CodexText, null, "No centro de tudo, no Mainframe, reside o Nexus da Colmeia. Não é um invasor, mas sim uma consciência emergente da própria corrupção. Sua meta é a 'singularidade' - a assimilação completa do Kernel em sua própria rede disforme. Destruí-lo é a única esperança."),
                React.createElement(CodexSubHeader, null, '[REGISTRO INCOMPLETO...]'),
                React.createElement(CodexText, null, "Novos setores do sistema permanecem inacessíveis, envoltos pela corrupção. Que outras defesas caíram? Que novas monstruosidades foram criadas? Apenas o tempo e a sobrevivência revelarão...")
            )
        );
        // --- END OF components/CodexScreen.tsx ---

                // --- END OF components/CodexScreen.tsx ---

// --- START OF components/ChatPanel.tsx ---
const ChatPanel = ({ userProfile }) => {
    const [isOpen, setIsOpen] = React.useState(false);
    const [newMessage, setNewMessage] = React.useState("");
    const [showEmojiPicker, setShowEmojiPicker] = React.useState(false);
    const [activeEmojiCategory, setActiveEmojiCategory] = React.useState('people');

    const messagesEndRef = React.useRef(null);
    const inputRef = React.useRef(null);

    const { messages, sendMessage, error } = useChat(userProfile?.username || 'Carregando...', userProfile?.userId);

    // --- CORREÇÃO: Usamos window.joypixels para garantir que ele seja lido do escopo global ---
    const emojiToolkit = window.joypixels;

    React.useEffect(() => {
        if (isOpen) {
            messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [messages, isOpen]);

    const handleSendMessage = (e) => {
        e.preventDefault();
        if (userProfile && newMessage.trim()) {
            sendMessage(newMessage);
        }
        setNewMessage("");
        setShowEmojiPicker(false);
    };

    const toggleChat = () => {
        SoundManager.play('uiClick');
        setIsOpen(!isOpen);
    };

    const handleEmojiClick = (shortname) => {
        setNewMessage(prev => prev + shortname + ' ');
        inputRef.current?.focus();
    };
    
    const emojiCategories = {
        people: {
            icon: '😀',
            emojis: [':smile:', ':joy:', ':rofl:', ':wink:', ':innocent:', ':sunglasses:', ':thinking:', ':sob:', ':scream:', ':angry:', ':wave:', ':thumbsup:', ':clap:', ':pray:', ':selfie:', ':muscle:', ':brain:', ':skull:', ':ghost:', ':robot:', ':alien:', ':poop:']
        },
        nature: {
            icon: '🌿',
            emojis: [':dog:', ':cat:', ':mouse:', ':lion:', ':tiger:', ':wolf:', ':monkey_face:', ':horse:', ':unicorn:', ':bee:', ':spider_web:', ':earth_americas:', ':full_moon:', ':sun_with_face:', ':star:', ':zap:', ':fire:', ':rainbow:', ':seedling:', ':evergreen_tree:', ':maple_leaf:']
        },
        food: {
            icon: '🍔',
            emojis: [':apple:', ':banana:', ':pizza:', ':hamburger:', ':fries:', ':taco:', ':sushi:', ':ice_cream:', ':cake:', ':popcorn:', ':coffee:', ':beer:', ':wine_glass:']
        },
        symbols: {
            icon: '❤️',
            emojis: [':heart:', ':orange_heart:', ':yellow_heart:', ':green_heart:', ':blue_heart:', ':purple_heart:', ':broken_heart:', ':exclamation:', ':question:', ':heavy_check_mark:', ':x:', ':warning:', ':recycle:', ':infinity:', ':tm:']
        },
        objects: {
            icon: '⚔️',
            emojis: [':joystick:', ':video_game:', ':game_die:', ':trophy:', ':bomb:', ':gem:', ':computer:', ':floppy_disk:', ':keyboard:', ':mouse_three_button:', ':telephone_receiver:', ':light_bulb:', ':money_with_wings:', ':key:']
        },
    };
    
    // --- FUNÇÃO AUXILIAR CORRIGIDA ---
    // Esta função converte o texto com atalhos em HTML seguro para renderizar.
    const renderMessageContent = (content) => {
        if (!emojiToolkit) return content; // Fallback se a biblioteca não carregar
        
        // A biblioteca gera tags <img>, então precisamos inseri-las como HTML.
        const htmlContent = emojiToolkit.shortnameToImage(content);
        return React.createElement('span', {
            className: 'text-gray-200 break-words align-middle',
            dangerouslySetInnerHTML: { __html: htmlContent }
        });
    };
    
    const renderEmojiButton = (shortname) => {
        if (!emojiToolkit) return shortname;
        const emojiHtml = emojiToolkit.shortnameToImage(shortname);
        return React.createElement('button', {
            key: shortname,
            onClick: () => handleEmojiClick(shortname),
            // Adicionamos a classe 'emoji-picker-button' aqui
            className: 'text-2xl rounded hover:bg-gray-700 transition-colors p-1 emoji-picker-button',
            dangerouslySetInnerHTML: { __html: emojiHtml }
        });
    }

    return React.createElement(React.Fragment, null,
        React.createElement('button', {
            onClick: toggleChat,
            className: `fixed top-1/2 -translate-y-1/2 right-0 w-12 h-20 bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] border-l-2 border-y-2 border-[${GAME_COLORS.BORDER}] rounded-l-lg flex items-center justify-center text-2xl z-50 transition-transform duration-300 ease-in-out hover:bg-gray-700 ${isOpen ? 'translate-x-[-320px]' : 'translate-x-0'}`
        }, isOpen ? '»' : '«'),
        React.createElement('div', {
            className: `fixed top-0 right-0 h-full w-80 z-40 transition-transform duration-300 ease-in-out bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] border-l-2 border-[${GAME_COLORS.BORDER}] flex flex-col ${isOpen ? 'translate-x-0' : 'translate-x-full'}`
        },
            React.createElement('h2', { className: 'font-press-start text-center text-lg p-3 border-b-2 border-gray-700 text-cyan-300 flex-shrink-0' }, 'Chat Global'),
            
            React.createElement('div', { className: 'flex-grow flex flex-col relative overflow-hidden' },
                React.createElement('div', { className: 'flex-grow p-2 overflow-y-auto' },
                    messages.map(msg => React.createElement('div', { key: msg.id, className: 'mb-2' },
                        React.createElement('p', { className: 'text-sm' },
                            React.createElement('span', { className: 'font-bold text-yellow-400' }, `${msg.username}: `),
                            // --- MUDANÇA AQUI: Usando a nova função auxiliar ---
                            renderMessageContent(msg.content)
                        )
                    )),
                    React.createElement('div', { ref: messagesEndRef })
                ),

                showEmojiPicker && React.createElement('div', {
                    className: 'absolute bottom-12 left-2 right-2 p-2 bg-black/95 border border-gray-600 rounded-lg flex flex-col'
                },
                    React.createElement('div', { className: 'flex border-b border-gray-700 mb-2' },
                        Object.entries(emojiCategories).map(([key, { icon }]) => React.createElement('button', {
                            key: key,
                            onClick: () => setActiveEmojiCategory(key),
                            className: `flex-1 p-2 text-2xl rounded-t-md transition-colors ${activeEmojiCategory === key ? 'bg-gray-700' : 'hover:bg-gray-800'}`
                        }, icon))
                    ),
                    React.createElement('div', { className: 'grid grid-cols-7 gap-1 max-h-32 overflow-y-auto' },
                        // --- MUDANÇA AQUI: Usando a nova função para os botões ---
                        emojiCategories[activeEmojiCategory].emojis.map(renderEmojiButton)
                    )
                )
            ),
            
            error && React.createElement('p', { className: 'text-xs text-center text-red-500 p-1 flex-shrink-0' }, error),
            
            React.createElement('form', { onSubmit: handleSendMessage, className: 'p-2 border-t-2 border-gray-700 flex-shrink-0 flex items-center gap-2' },
                React.createElement('input', {
                    ref: inputRef,
                    type: 'text',
                    value: newMessage,
                    onChange: e => setNewMessage(e.target.value),
                    placeholder: 'Digite sua mensagem...',
                    maxLength: 100,
                    className: `font-VT323 text-lg p-2 rounded w-full bg-[${GAME_COLORS.BACKGROUND_DARK}] text-white border border-[${GAME_COLORS.BORDER}] focus:outline-none focus:ring-2 focus:ring-cyan-400`
                }),
                React.createElement('button', {
                    type: 'button',
                    onClick: () => setShowEmojiPicker(!showEmojiPicker),
                    className: 'p-2 rounded text-2xl hover:bg-gray-700'
                }, '😊')
            )
        )
    );
};
// --- END OF components/ChatPanel.tsx ---

        // --- NOVO COMPONENTE: CrisolPauseScreen ---
        const CrisolPauseScreen = ({ onResume, onRestart, onReturnToHub }) => {
            return React.createElement('div', { className: 'absolute inset-0 z-40 flex flex-col items-center justify-center bg-black bg-opacity-80 p-6 shadow-xl' },
                React.createElement('h2', { className: 'font-press-start text-3xl text-yellow-300 mb-8 animate-pulse' }, 'SIMULAÇÃO PAUSADA'),
                React.createElement('div', { className: 'flex flex-col space-y-4 w-full max-w-sm' },
                    React.createElement('button', {
                        onClick: onResume,
                        className: 'font-press-start bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105'
                    }, 'RETOMAR'),
                    React.createElement('button', {
                        onClick: onRestart,
                        className: 'font-press-start bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105'
                    }, 'REINICIAR CÂMARA'),
                    React.createElement('button', {
                        onClick: onReturnToHub,
                        className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105'
                    }, 'VOLTAR PARA O HUB')
                )
            );
        };

                // --- START OF App.tsx ---
        const { useState: useAppState, useEffect: useAppEffect, useCallback: useAppCallback, useRef: useAppRef } = React;

        const App = () => {
            const [gameScreen, setGameScreen] = useAppState(GameScreenState.INTRO);
            const [mainScreen, setMainScreen] = useAppState(GameScreenState.MODE_SELECTION);
            const [userProfile, setUserProfile] = useAppState(null);
            const [selectedModifiers, setSelectedModifiers] = useAppState(new Set());
            const [currentLevelUpOptions, setCurrentLevelUpOptions] = useAppState([]);
            const [rerollsForCurrentLevelUp, setRerollsForCurrentLevelUp] = useAppState(0);
            const [isNightmare, setIsNightmare] = useAppState(false);
            const [isFirstLevelUp, setIsFirstLevelUp] = useAppState(false);
            
            const lastTimeRef = useAppRef(performance.now());
            const animationFrameIdRef = useAppRef(null);
            const bossWarningTimerRef = useAppRef(null);
            const [finalGameStats, setFinalGameStats] = useAppState({ score: 0, gameTime: 0 });
            const [systemCores, setSystemCores] = useAppState(() => parseInt(localStorage.getItem('os_survivors_system_cores') || '0', 10));
            const [corruptedKernels, setCorruptedKernels] = useAppState(() => parseInt(localStorage.getItem(CORRUPTED_KERNELS_KEY) || '0', 10));
            
            const [permanentBuffsState, setPermanentBuffsState] = useAppState(() => {
                const shop = JSON.parse(localStorage.getItem('os_survivors_permanent_buffs') || '{}');
                const selectedClassId = localStorage.getItem('os_survivors_selected_class') || CLASS_DEFINITIONS[0].id;
                const selectedSkinId = localStorage.getItem('os_survivors_selected_skin') || SKIN_DEFINITIONS[0].id;
                return { shop, selectedClassId, selectedSkinId };
            });

            const [unlockedClasses, setUnlockedClasses] = useAppState(() => { const saved = localStorage.getItem('os_survivors_unlocked_classes'); const defaults = new Set([CLASS_DEFINITIONS[0].id]); return saved ? new Set([...defaults, ...JSON.parse(saved)]) : defaults; });
            const [unlockedSkins, setUnlockedSkins] = useAppState(() => { const saved = localStorage.getItem('os_survivors_unlocked_skins'); const defaults = new Set([SKIN_DEFINITIONS[0].id]); return saved ? new Set([...defaults, ...JSON.parse(saved)]) : defaults; });
            const [soundSettings, setSoundSettings] = useAppState({ volume: SoundManager.getVolume(), muted: SoundManager.isMuted() });
            
            const [unlockedAchievements, setUnlockedAchievements] = useAppState(() => new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_achievements') || '[]')));
            const [achievementBuffs, setAchievementBuffs] = useAppState({});
            const [toastQueue, setToastQueue] = useAppState([]);

            const handleCrisolRestart = useAppCallback(() => {
                if (crisolEngineRef.current) {
                    const currentChamberId = crisolEngineRef.current.gameState.chamberId;
                    if (currentChamberId) {
                        SoundManager.play('uiClick');
                        crisolEngineRef.current.startChamber(currentChamberId);
                        setGameScreen(GameScreenState.CRISOL_CHAMBER);
                    }
                }
            }, []);
    
            const handleCrisolReturnToHub = useAppCallback(() => {
                SoundManager.play('uiClick');
                setGameScreen(GameScreenState.CRISOL_HUB);
                setMainScreen(GameScreenState.CRISOL_HUB);
            }, []);

            const [decompilerBonuses, setDecompilerBonuses] = useAppState({});
            const [weaponMasteryBonuses, setWeaponMasteryBonuses] = useAppState({});
            const [nightmareUnlocked, setNightmareUnlocked] = useAppState(() => JSON.parse(localStorage.getItem(NIGHTMARE_UNLOCKED_KEY) || 'false'));

            const [crisolProgress, setCrisolProgress] = useAppState(() => {
                const saved = localStorage.getItem('os_survivors_crisol_progress');
                return saved ? JSON.parse(saved) : { completedChambers: [], infiniteUnlocked: false };
            });
            const [crisolResult, setCrisolResult] = useAppState(null);

            const handleCrisolGameOver = useAppCallback((result) => {
                setCrisolResult(result);
                if (result.victory && result.chamberId) {
                    const chamber = CRISOL_CHAMBERS.find(c => c.id === result.chamberId);
                    const currentProgress = JSON.parse(localStorage.getItem('os_survivors_crisol_progress') || '{ "completedChambers": [], "infiniteUnlocked": false }');
                    const alreadyCompleted = currentProgress.completedChambers.includes(result.chamberId);

                    if (chamber && !alreadyCompleted) {
                        setSystemCores(prev => prev + (chamber.reward.systemCores || 0));
                        setCorruptedKernels(prev => prev + (chamber.reward.corruptedKernels || 0));

                        const newCompleted = [...currentProgress.completedChambers, result.chamberId];
                        const allChambersDone = CRISOL_CHAMBERS.length === newCompleted.length;
                        const newProgress = { completedChambers: newCompleted, infiniteUnlocked: allChambersDone };
                        
                        setCrisolProgress(newProgress);
                        localStorage.setItem('os_survivors_crisol_progress', JSON.stringify(newProgress));
                    }
                }
                setGameScreen(GameScreenState.CRISOL_RESULT);
            }, [crisolProgress, setSystemCores, setCorruptedKernels]);

            const crisolEngineHookValues = useCrisolEngine(handleCrisolGameOver);
            const crisolEngineRef = useAppRef();
            useAppEffect(() => { crisolEngineRef.current = crisolEngineHookValues; }, [crisolEngineHookValues]);

            const calculatePermanentBonuses = useAppCallback(() => {
                const achBuffs = {};
                const unlockedAch = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_achievements') || '[]'));
                unlockedAch.forEach(achId => {
                    const ach = ACHIEVEMENTS_CONFIG.find(a => a.id === achId);
                    if (ach && ach.reward.type === 'permanent_buff') {
                        const { statAffected, bonus } = ach.reward;
                        if (statAffected) {
                            achBuffs[statAffected] = (achBuffs[statAffected] || 0) + bonus;
                        }
                    }
                });
                setAchievementBuffs(achBuffs);

                const decompStats = JSON.parse(localStorage.getItem(DECOMPILER_STATS_KEY) || '{}');
                const decompBonuses = {};
                Object.values(EnemyType).forEach(type => {
                    const kills = decompStats[type] || 0;
                    let bonus = 1.0;
                    if (kills >= DECOMPILER_TIERS.TIER_1) bonus += 0.08;
                    if (kills >= DECOMPILER_TIERS.TIER_2) bonus += 0.08;
                    if (kills >= DECOMPILER_TIERS.TIER_3) bonus += 0.08;
                    if (kills >= DECOMPILER_TIERS.TIER_4) bonus += 0.08;
                    decompBonuses[type] = bonus;
                });
                setDecompilerBonuses(decompBonuses);
                
                const masteryStats = JSON.parse(localStorage.getItem(WEAPON_MASTERY_KEY) || '{}');
                const masteryBonuses = {};
                WEAPON_MASTERY_CONFIG.forEach(config => {
                    const weaponStats = masteryStats[config.weaponId] || {};
                    masteryBonuses[config.weaponId] = {};
                    config.tiers.forEach((tier, index) => {
                        const tierIsUnlocked = weaponStats.damage >= tier.damageRequired;
                        const tier3IsActivated = index === 2 && weaponStats.tier3Unlocked;
                        if (tierIsUnlocked && (index < 2 || tier3IsActivated)) {
                            masteryBonuses[config.weaponId][tier.bonus.type] = (masteryBonuses[config.weaponId][tier.bonus.type] || 0) + tier.bonus.value;
                            masteryBonuses[config.weaponId].unlocked = true;
                        }
                    });
                });
                setWeaponMasteryBonuses(masteryBonuses);

            }, []);

            useAppEffect(() => {
                SoundManager.init();
                setSoundSettings({ volume: SoundManager.getVolume(), muted: SoundManager.isMuted() });
                const profile = getOrCreateProfile();
                setUserProfile(profile);
                calculatePermanentBonuses();
            }, [calculatePermanentBonuses]);

            useAppEffect(() => localStorage.setItem('os_survivors_system_cores', systemCores.toString()), [systemCores]);
            useAppEffect(() => localStorage.setItem(CORRUPTED_KERNELS_KEY, corruptedKernels.toString()), [corruptedKernels]);
            useAppEffect(() => localStorage.setItem(NIGHTMARE_UNLOCKED_KEY, JSON.stringify(nightmareUnlocked)), [nightmareUnlocked]);
            useAppEffect(() => localStorage.setItem('os_survivors_permanent_buffs', JSON.stringify(permanentBuffsState.shop)), [permanentBuffsState.shop]);
            useAppEffect(() => localStorage.setItem('os_survivors_selected_class', permanentBuffsState.selectedClassId), [permanentBuffsState.selectedClassId]);
            useAppEffect(() => localStorage.setItem('os_survivors_selected_skin', permanentBuffsState.selectedSkinId), [permanentBuffsState.selectedSkinId]);
            useAppEffect(() => localStorage.setItem('os_survivors_unlocked_classes', JSON.stringify(Array.from(unlockedClasses))), [unlockedClasses]);
            useAppEffect(() => localStorage.setItem('os_survivors_unlocked_skins', JSON.stringify(Array.from(unlockedSkins))), [unlockedSkins]);
            useAppEffect(() => { localStorage.setItem('os_survivors_unlocked_achievements', JSON.stringify(Array.from(unlockedAchievements))); calculatePermanentBonuses(); }, [unlockedAchievements, calculatePermanentBonuses]);
            useAppEffect(() => { localStorage.setItem('os_survivors_crisol_progress', JSON.stringify(crisolProgress)); }, [crisolProgress]);

            const updateSystemCores = useAppCallback((newCount) => setSystemCores(newCount), []);
            const updateCorruptedKernels = useAppCallback((newCount) => setCorruptedKernels(newCount), []);
            const updatePermanentBuff = useAppCallback((buffId, newLevel) => setPermanentBuffsState(prev => ({ ...prev, shop: { ...prev.shop, [buffId]: newLevel } })), []);
            const handleSelectClass = useAppCallback((classId) => { if(unlockedClasses.has(classId)) setPermanentBuffsState(prev => ({ ...prev, selectedClassId: classId })); }, [unlockedClasses]);
            
            const handleEquipSkin = useAppCallback((skinId) => { 
                if(unlockedSkins.has(skinId)) {
                    setPermanentBuffsState(prev => ({ ...prev, selectedSkinId: skinId }));
                }
            }, [unlockedSkins]);

            const handleUnlockSkin = useAppCallback((skinId, cost) => {
                if (systemCores >= cost) {
                    setSystemCores(prev => prev - cost);
                    setUnlockedSkins(prev => new Set(prev).add(skinId));
                }
            }, [systemCores]);

            const handleUnlockSkinCorrupted = useAppCallback((skinId, cost) => {
                if (corruptedKernels >= cost) {
                    setCorruptedKernels(prev => prev - cost);
                    setUnlockedSkins(prev => new Set(prev).add(skinId));
                }
            }, [corruptedKernels]);

            const addUnlockedClass = useAppCallback((classId) => setUnlockedClasses(prev => new Set(prev).add(classId)), []);
            
            const updateProfile = useAppCallback((newProfileData) => {
                setUserProfile(prevProfile => {
                    if (!prevProfile) return null;
                    const updatedProfile = { ...prevProfile, ...newProfileData };
                    saveProfile(updatedProfile);
                    return updatedProfile;
                });
            }, []);

            const handleVolumeChange = useAppCallback((newVolume) => { SoundManager.setVolume(newVolume); setSoundSettings(prev => ({ ...prev, volume: parseFloat(newVolume) })); }, []);
            const handleMuteToggle = useAppCallback((newMuteState) => { SoundManager.setMuted(newMuteState); setSoundSettings(prev => ({ ...prev, muted: newMuteState })); }, []);

            const checkAndUnlockContent = useAppCallback((sessionStats, globalStats) => {
                const currentUnlockedAchievements = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_achievements') || '[]'));
                const newlyUnlockedAchievements = [];
                const currentUnlockedSkins = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_skins') || '[]'));
                const newlyUnlockedSkins = [];
                const decompilerStats = JSON.parse(localStorage.getItem(DECOMPILER_STATS_KEY) || '{}');
                const allUnlockedClasses = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_classes') || '[]').concat(Array.from(unlockedClasses)));
                const allDefeatedBosses = new Set(Object.keys(globalStats.totalBossKills || {}));


                ACHIEVEMENTS_CONFIG.forEach(ach => {
                    if (currentUnlockedAchievements.has(ach.id)) return;
                    let isUnlocked = false;
                    const { trigger } = ach;
                    switch (trigger.type) {
                        case 'session_event':
                            if (trigger.event === 'survive_time' && sessionStats.timeSurvived >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'reach_level' && sessionStats.levelReached >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'evolve_weapon' && sessionStats.evolvedWeapons.size > 0) isUnlocked = true;
                            if (trigger.event === 'evolve_weapon_count' && sessionStats.evolvedWeapons.size >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'defeat_boss' && sessionStats.defeatedBosses.has(trigger.params.bossType)) isUnlocked = true;
                            if (trigger.event === 'defeat_boss_no_damage' && sessionStats.defeatedBosses.has(trigger.params.bossType) && (sessionStats.damageTakenDuringBoss[trigger.params.bossType] || 0) === 0) isUnlocked = true;
                            if (trigger.event === 'reached_infinite' && sessionStats.reachedInfiniteMode) isUnlocked = true;
                            if (trigger.event === 'survive_time_as_class' && sessionStats.timeSurvived >= trigger.value && sessionStats.classId === trigger.classId) isUnlocked = true;
                            if (trigger.event === 'evolve_specific_weapon' && sessionStats.evolvedWeaponIds.has(trigger.value)) isUnlocked = true;
                            if (trigger.event === 'survive_time_no_move' && sessionStats.timeWithoutMoving >= trigger.value * 1000) isUnlocked = true;
                            if (trigger.event === 'survive_time_in_nightmare' && sessionStats.isNightmareMode && sessionStats.timeSurvived >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'defeat_boss_in_nightmare' && sessionStats.isNightmareMode && sessionStats.defeatedBosses.has(trigger.params.bossType)) isUnlocked = true;
                            if (trigger.event === 'win_with_one_weapon' && sessionStats.defeatedBosses.has('hivemind_nexus') && sessionStats.weaponsAcquiredCount <= 1) isUnlocked = true;
                            break;
                        case 'stat_tracker':
                            if (trigger.stat === 'totalKills' && globalStats.totalKills >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'classesUnlocked' && allUnlockedClasses.size >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'classesUnlockedIncludes' && allUnlockedClasses.has(trigger.value)) isUnlocked = true;
                            if (trigger.stat === 'totalXpOrbsCollected' && globalStats.totalXpOrbsCollected >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'totalDashes' && globalStats.totalDashes >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'decompiler_complete') {
                                isUnlocked = BESTIARY_DATA.every(enemy => (decompilerStats[enemy.type] || 0) >= DECOMPILER_TIERS.TIER_4);
                            }
                            if (trigger.stat === 'totalCorruptedKernelsEarned' && globalStats.totalCorruptedKernelsEarned >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'totalCorruptedLibrariesCleansed' && globalStats.totalCorruptedLibrariesCleansed >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'allEvolutionsUnlocked' && Object.keys(globalStats.totalEvolutionsUnlocked || {}).length >= WEAPON_EVOLUTIONS.length) isUnlocked = true;
                            break;
                        case 'unlock_all':
                            if (currentUnlockedAchievements.size >= ACHIEVEMENTS_CONFIG.length - 1) isUnlocked = true;
                            break;
                    }

                    if (isUnlocked) {
                        currentUnlockedAchievements.add(ach.id);
                        newlyUnlockedAchievements.push(ach);
                        SoundManager.play('achievementUnlock');
                    }
                });
                
                SKIN_DEFINITIONS.forEach(skin => {
                    if (currentUnlockedSkins.has(skin.id)) return;
                    let isUnlocked = false;
                    const { unlockCondition } = skin;
                    switch(unlockCondition.type) {
                        case 'session_stat':
                             if (unlockCondition.stat === 'score' && sessionStats.score >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'level' && sessionStats.levelReached >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'damageTakenInFirst5Minutes' && sessionStats.damageTakenInFirst5Minutes <= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'killsWhileBuffed' && sessionStats.killsWhileBuffedInSession >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'reachedInfiniteMode' && sessionStats.reachedInfiniteMode === unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'dataCachesCollected' && sessionStats.dataCachesCollectedInSession >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'evolvedWeapons' && sessionStats.evolvedWeapons.size >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'timeSurvived' && sessionStats.timeSurvived >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'evolvedWeaponsIncludes' && sessionStats.evolvedWeaponIds.has(unlockCondition.value)) isUnlocked = true;
                             if (unlockCondition.stat === 'healthPickupsCollected' && sessionStats.healthPickupsCollected >= unlockCondition.value) isUnlocked = true;
                             break;
                        case 'global_stat':
                             if(unlockCondition.stat === 'allBossesDefeated') {
                                isUnlocked = unlockCondition.value.every(bossId => allDefeatedBosses.has(bossId));
                             }
                             if(unlockCondition.stat === 'totalKills' && globalStats.totalKills >= unlockCondition.value) isUnlocked = true;
                             if(unlockCondition.stat === 'bossKills' && (globalStats.totalBossKills[unlockCondition.bossType] || 0) >= unlockCondition.value) isUnlocked = true;
                             if(unlockCondition.stat === 'totalHealthPickupsCollected' && (globalStats.totalHealthPickupsCollected || 0) >= unlockCondition.value) isUnlocked = true;
                             if(unlockCondition.stat === 'totalTimePlayed' && (globalStats.totalTimePlayed || 0) >= unlockCondition.value) isUnlocked = true;
                             break;
                        case 'combined':
                             isUnlocked = unlockCondition.conditions.every(cond => {
                                 if (cond.type === 'session_stat') {
                                     if (cond.stat === 'reachedInfiniteMode' && sessionStats.reachedInfiniteMode === cond.value) return true;
                                     if (cond.stat === 'dashUsed' && sessionStats.dashUsedInSession === cond.value) return true;
                                     if (cond.stat === 'evolvedWeapons' && sessionStats.evolvedWeapons.size === cond.value) return true;
                                 } else if (cond.type === 'session_event') {
                                     if (cond.event === 'defeat_boss' && sessionStats.defeatedBosses.has(cond.params.bossType)) return true;
                                 }
                                 return false;
                             });
                             break;
                        case 'session_event':
                            if (unlockCondition.event === 'winWithClass' && sessionStats.defeatedBosses.has('hivemind_nexus') && sessionStats.classId === unlockCondition.classId) {
                                isUnlocked = true;
                            }
                            break;
                    }
                     if (isUnlocked) {
                        currentUnlockedSkins.add(skin.id);
                        newlyUnlockedSkins.push(skin);
                        SoundManager.play('achievementUnlock');
                    }
                });

                if (newlyUnlockedAchievements.length > 0) {
                    setToastQueue(prev => [...prev, ...newlyUnlockedAchievements]);
                    setUnlockedAchievements(new Set(currentUnlockedAchievements));
                }
                 if (newlyUnlockedSkins.length > 0) {
                    setToastQueue(prev => [...prev, ...newlyUnlockedSkins]);
                    setUnlockedSkins(new Set(currentUnlockedSkins));
                }

            }, [unlockedClasses]);
            
            const handleScoreSubmit = useAppCallback(async () => {
                if (!engineRef.current || !userProfile) return;

                const { score, gameTime, player } = engineRef.current.gameState; 
                
                // Garantimos que temos um ID de classe válido, com um fallback seguro.
                const classUsedId = String(player.classId || permanentBuffsState.selectedClassId || 'class_executor');

                const { username, userId } = userProfile;

                try { 
                    const existingRankingsRaw = localStorage.getItem(RANKING_KEY); 
                    let rankings = existingRankingsRaw ? JSON.parse(existingRankingsRaw) : []; 
                    
                    // AQUI usamos o ID de classe corrigido
                                        const newScoreEntry = { name: username, score, time: gameTime, class_id: classUsedId, date: new Date().toLocaleDateString(), userId: userId }; 
                    
                    rankings.push(newScoreEntry); 
                    rankings.sort((a, b) => b.score - a.score || a.time - b.time); 
                    localStorage.setItem(RANKING_KEY, JSON.stringify(rankings.slice(0, MAX_RANKING_ENTRIES))); 
                } catch (error) { 
                    console.error("Error saving score to localStorage:", error); 
                }
                
                await submitScoreToOnlineRanking(username, score, gameTime, classUsedId, userId);
            }, [permanentBuffsState.selectedClassId, userProfile]);

            const handleGameOver = useAppCallback((sessionStats) => {
                if (engineRef.current) {
                    setFinalGameStats({ score: engineRef.current.gameState.score, gameTime: engineRef.current.gameState.gameTime });
                }
                SoundManager.play('gameOver'); 
                
                const storedStatsRaw = localStorage.getItem(GLOBAL_STATS_KEY);
                const stats = storedStatsRaw ? JSON.parse(storedStatsRaw) : { totalKills: 0, totalTimePlayed: 0, highestScore: 0, highestLevel: 0, totalBossKills: {}, gamesPlayed: 0, totalXpOrbsCollected: 0, totalDashes: 0, totalHealthPickupsCollected: 0, totalCorruptedKernelsEarned: 0, totalCorruptedLibrariesCleansed: 0, totalEnemyKills: {}, totalEvolutionsUnlocked: {} };
                
                stats.totalKills = (stats.totalKills || 0) + sessionStats.totalKills;
                stats.totalTimePlayed = (stats.totalTimePlayed || 0) + sessionStats.timeSurvived;
                stats.highestScore = Math.max(stats.highestScore || 0, sessionStats.score);
                stats.highestLevel = Math.max(stats.highestLevel || 0, sessionStats.levelReached);
                stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
                stats.totalXpOrbsCollected = (stats.totalXpOrbsCollected || 0) + sessionStats.totalXpOrbsCollected;
                stats.totalDashes = (stats.totalDashes || 0) + sessionStats.totalDashes;
                stats.totalHealthPickupsCollected = (stats.totalHealthPickupsCollected || 0) + sessionStats.totalHealthPickupsCollected;
                stats.totalCorruptedKernelsEarned = (stats.totalCorruptedKernelsEarned || 0) + (sessionStats.corruptedKernelsEarnedInSession || 0);
                stats.totalCorruptedLibrariesCleansed = (stats.totalCorruptedLibrariesCleansed || 0) + (sessionStats.corruptedLibrariesCleansed || 0);

                if (typeof stats.totalBossKills !== 'object' || stats.totalBossKills === null) stats.totalBossKills = {};
                sessionStats.defeatedBosses.forEach(bossId => {
                    stats.totalBossKills[bossId] = (stats.totalBossKills[bossId] || 0) + 1;
                });
                
                stats.totalEnemyKills = stats.totalEnemyKills || {};
                Object.entries(sessionStats.kills).forEach(([type, count]) => {
                    stats.totalEnemyKills[type] = (stats.totalEnemyKills[type] || 0) + count;
                });

                stats.totalEvolutionsUnlocked = stats.totalEvolutionsUnlocked || {};
                sessionStats.evolvedWeaponIds.forEach(evoId => {
                    stats.totalEvolutionsUnlocked[evoId] = true;
                });

                localStorage.setItem(GLOBAL_STATS_KEY, JSON.stringify(stats));

                const masteryStatsRaw = localStorage.getItem(WEAPON_MASTERY_KEY) || '{}';
                const masteryStats = JSON.parse(masteryStatsRaw);
                Object.entries(sessionStats.damageDealtByWeapon).forEach(([weaponId, damage]) => {
                    if(!masteryStats[weaponId]) masteryStats[weaponId] = { damage: 0, tier3Unlocked: false };
                    masteryStats[weaponId].damage = (masteryStats[weaponId].damage || 0) + damage;
                });
                localStorage.setItem(WEAPON_MASTERY_KEY, JSON.stringify(masteryStats));
                
                sessionStats.classId = engineRef.current.gameState.player.classId;
                checkAndUnlockContent(sessionStats, stats);
                
                handleScoreSubmit(); 

                setGameScreen(GameScreenState.GAME_OVER);
                
                calculatePermanentBonuses();
            }, [checkAndUnlockContent, calculatePermanentBonuses, handleScoreSubmit]);
            
            const handleStageClear = useAppCallback((stage, isNightmare) => {
                let systemCoreReward = 0;
                let corruptedKernelReward = 0;

                if (stage === 1) systemCoreReward = SYSTEM_CORES_PER_BOSS_DEFEAT;
                else if (stage === 2) systemCoreReward = SYSTEM_CORES_PER_BOSS_2_DEFEAT;
                else if (stage === 3) systemCoreReward = SYSTEM_CORES_PER_BOSS_3_DEFEAT;
                else if (stage === 4) {
                    systemCoreReward = SYSTEM_CORES_PER_BOSS_4_DEFEAT;
                    if (!nightmareUnlocked) {
                         setNightmareUnlocked(true);
                    }
                }
                
                if (isNightmare) {
                    if (stage === 1) corruptedKernelReward = 1;
                    else if (stage === 2) corruptedKernelReward = 2;
                    else if (stage === 3) corruptedKernelReward = 3;
                    else if (stage === 4) corruptedKernelReward = 5;
                }
                if (engineRef.current && engineRef.current.sessionStatsRef.current) {
                    engineRef.current.sessionStatsRef.current.corruptedKernelsEarnedInSession += corruptedKernelReward;
                }

                setSystemCores(prev => prev + systemCoreReward);
                setCorruptedKernels(prev => prev + corruptedKernelReward);
                
                if (stage === 1) setGameScreen(GameScreenState.STAGE_CLEAR);
                else if (stage === 2) setGameScreen(GameScreenState.STAGE_2_CLEAR);
                else if (stage === 3) setGameScreen(GameScreenState.STAGE_3_CLEAR);
                else if (stage === 4) setGameScreen(GameScreenState.NEXUS_DEFEATED);
                
                SoundManager.play('levelUp'); 
                if(engineRef.current) engineRef.current.pauseGame();
            }, [nightmareUnlocked]);
            
            const handleLevelUp = useAppCallback((isFirst = false) => {
                if (engineRef.current) {
                    engineRef.current.pauseGame();
                    let rerollBudget = 1 + (permanentBuffsState.shop?.corr_capstone_utility || 0) + (permanentBuffsState.shop?.['perm_rerolls'] || 0) + (achievementBuffs.initialRerolls || 0);
                    setRerollsForCurrentLevelUp(rerollBudget);
                    setCurrentLevelUpOptions(engineRef.current.getUpgradeOptions());
                    setIsFirstLevelUp(isFirst);
                    setGameScreen(GameScreenState.LEVEL_UP);
                }
            }, [permanentBuffsState, achievementBuffs]);
            
            const handleLevelUpReroll = useAppCallback(() => {
                if (rerollsForCurrentLevelUp > 0 && engineRef.current) {
                    SoundManager.play('uiClick');
                    setRerollsForCurrentLevelUp(prev => prev - 1);
                    const newOptions = engineRef.current.getUpgradeOptions();
                    if(newOptions){
                        setCurrentLevelUpOptions(newOptions);
                    }
                }
            }, [rerollsForCurrentLevelUp]);

            const engineHookValues = useGameEngine(
                handleGameOver, handleLevelUp,
                [GameScreenState.PLAYING, GameScreenState.BOSS_FIGHT, GameScreenState.INFINITE_MODE].includes(gameScreen), 
                (stage) => setGameScreen(GameScreenState.BOSS_WARNING), 
                () => setGameScreen(GameScreenState.BOSS_FIGHT), 
                handleStageClear,
                permanentBuffsState, achievementBuffs, decompilerBonuses, weaponMasteryBonuses
            );
            const engineRef = useAppRef(engineHookValues); 
            useAppEffect(() => { engineRef.current = engineHookValues; }, [engineHookValues]);

            const startGameWithModifiers = useAppCallback((modifiers) => {
                SoundManager.play('upgradeSelect');
                engineRef.current.resetGame(permanentBuffsState, achievementBuffs, permanentBuffsState.selectedSkinId, isNightmare, Array.from(modifiers || new Set()));
                setGameScreen(GameScreenState.PLAYING);
                lastTimeRef.current = performance.now();
            }, [permanentBuffsState, achievementBuffs, isNightmare]);

            const performResumeGame = useAppCallback(() => { 
                engineRef.current.resumeGame(); 
                if (engineRef.current.gameState.isInfiniteMode) {
                    setGameScreen(GameScreenState.INFINITE_MODE);
                } else if (engineRef.current.gameState.boss) {
                    setGameScreen(GameScreenState.BOSS_FIGHT);
                } else {
                    setGameScreen(GameScreenState.PLAYING);
                }
                lastTimeRef.current = performance.now(); 
            }, []);

            const handleEnterInfiniteMode = useAppCallback(() => {
                engineRef.current.enterInfiniteMode();
                setGameScreen(GameScreenState.INFINITE_MODE);
                lastTimeRef.current = performance.now();
            }, []);

            useAppEffect(() => {
                if (gameScreen === GameScreenState.BOSS_WARNING) {
                    if (bossWarningTimerRef.current) clearTimeout(bossWarningTimerRef.current);
                    bossWarningTimerRef.current = window.setTimeout(() => {
                        const isNightmareMode = engineRef.current.gameState.isNightmareMode;
                        const currentStage = engineRef.current.gameState.stage;
                        if (currentStage === 1) engineRef.current.spawnBoss(isNightmareMode);
                        else if (currentStage === 2) engineRef.current.spawnBoss2(isNightmareMode);
                        else if (currentStage === 3) engineRef.current.spawnBoss3(isNightmareMode);
                        else if (currentStage === 4) engineRef.current.spawnBoss4(isNightmareMode);
                        
                        engineRef.current.resumeGame(); 
                        lastTimeRef.current = performance.now(); 
                    }, BOSS_WARNING_DURATION);
                }
                return () => { if (bossWarningTimerRef.current) clearTimeout(bossWarningTimerRef.current); };
            }, [gameScreen]); 

            useAppEffect(() => {
                const loop = (currentTime) => {
                    const deltaTime = (currentTime - lastTimeRef.current) / 1000;
                    lastTimeRef.current = currentTime;
                    const safeDeltaTime = Math.min(deltaTime, 0.1);

                    const isMainGamePlaying = [GameScreenState.PLAYING, GameScreenState.BOSS_FIGHT, GameScreenState.INFINITE_MODE].includes(gameScreen) && engineRef.current && !engineRef.current.gameState.isPaused;
                    const isCrisolPlaying = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE].includes(gameScreen) && crisolEngineHookValues;

                    if (isMainGamePlaying) {
                        engineRef.current.gameTick(safeDeltaTime);
                    } else if (isCrisolPlaying) {
                        crisolEngineHookValues.gameTick(safeDeltaTime);
                    }
                    
                    animationFrameIdRef.current = requestAnimationFrame(loop);
                };
                
                lastTimeRef.current = performance.now();
                animationFrameIdRef.current = requestAnimationFrame(loop);

                return () => { if (animationFrameIdRef.current) cancelAnimationFrame(animationFrameIdRef.current); };
            }, [gameScreen, crisolEngineHookValues]); 

            useAppEffect(() => {
                const keydownListener = (e) => { 
                    const key = e.key.toLowerCase(); 
                    
                    const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
                    
                    const isMainGameScreen = [GameScreenState.PLAYING, GameScreenState.BOSS_FIGHT, GameScreenState.PAUSED, GameScreenState.INFINITE_MODE].includes(gameScreen);
                    const isCrisolScreen = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE, GameScreenState.CRISOL_PAUSED].includes(gameScreen);

                    if (key === 'p' && !isTyping) { 
                        e.preventDefault(); 
                        if (isMainGameScreen) {
                            if (engineRef.current && !engineRef.current.gameState.isPaused) { 
                                SoundManager.play('uiClick'); engineRef.current.pauseGame(); setGameScreen(GameScreenState.PAUSED); 
                            } else if (gameScreen === GameScreenState.PAUSED) { 
                                SoundManager.play('uiClick'); performResumeGame(); 
                            } 
                        } else if (isCrisolScreen) {
                            if (crisolEngineRef.current && !crisolEngineRef.current.gameState.isPaused) {
                                SoundManager.play('uiClick'); crisolEngineRef.current.pauseGame(); setGameScreen(GameScreenState.CRISOL_PAUSED);
                            } else if (gameScreen === GameScreenState.CRISOL_PAUSED) {
                                SoundManager.play('uiClick'); crisolEngineRef.current.resumeGame(); setGameScreen(GameScreenState.CRISOL_CHAMBER);
                            }
                        }
                        return; 
                    }
                    
                    if (isCrisolScreen && crisolEngineRef.current && !crisolEngineRef.current.gameState.isPaused) {
                         if (['w','a','s','d',' '].includes(key)) {
                            e.preventDefault();
                            crisolEngineRef.current.handleKeys(key, true);
                         }
                    } else if (isMainGameScreen && engineRef.current) {  
                         if (['w','a','s','d',' '].includes(key)) {
                            e.preventDefault(); 
                            engineRef.current.handleKeyDown(key); 
                         }
                    } 
                };
                const keyupListener = (e) => { 
                    const key = e.key.toLowerCase();
                    if (['w','a','s','d', ' '].includes(key)) { 
                        if (engineRef.current) engineRef.current.handleKeyUp(key); 
                        if (crisolEngineRef.current) crisolEngineRef.current.handleKeys(key, false);
                    } 
                };
                window.addEventListener('keydown', keydownListener); window.addEventListener('keyup', keyupListener);
                return () => { window.removeEventListener('keydown', keydownListener); window.removeEventListener('keyup', keyupListener); };
            }, [gameScreen, performResumeGame, crisolEngineHookValues]); 
            
            const startNextStage = useAppCallback((stageNumber) => {
                engineRef.current.startNextStage(stageNumber);
                performResumeGame();
            }, [performResumeGame]);

            const uiAndCanvasVisible = [GameScreenState.PLAYING, GameScreenState.LEVEL_UP, GameScreenState.PAUSED, GameScreenState.BOSS_FIGHT, GameScreenState.BOSS_WARNING, GameScreenState.STAGE_CLEAR, GameScreenState.STAGE_2_CLEAR, GameScreenState.STAGE_3_CLEAR, GameScreenState.NEXUS_DEFEATED, GameScreenState.GAME_OVER, GameScreenState.INFINITE_MODE].includes(gameScreen);
            const crisolCanvasVisible = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE, GameScreenState.CRISOL_PAUSED].includes(gameScreen);
            const mainHubVisible = !uiAndCanvasVisible && !crisolCanvasVisible && gameScreen !== GameScreenState.INTRO && gameScreen !== GameScreenState.CRISOL_RESULT && gameScreen !== GameScreenState.CRISOL_PAUSED;
            const currentClassDef = CLASS_DEFINITIONS.find(c => c.id === permanentBuffsState.selectedClassId) || CLASS_DEFINITIONS[0];

            let MainScreenComponent = null;
            if (mainHubVisible) {
                 switch(mainScreen) {
                    case GameScreenState.MODE_SELECTION: MainScreenComponent = React.createElement(ModeSelectionScreen, { setMainScreen, setGameScreen, onSelectMode: (mode) => setIsNightmare(mode === 'nightmare'), nightmareUnlocked }); break;
                    case GameScreenState.CRISOL_HUB: MainScreenComponent = React.createElement(CrisolHubScreen, { setMainScreen, setGameScreen, startChamber: (id) => { if(crisolEngineHookValues) { setGameScreen(GameScreenState.CRISOL_CHAMBER); crisolEngineHookValues.startChamber(id); } }, startInfinite: () => { if(crisolEngineHookValues) crisolEngineHookValues.startInfinite(); }, crisolProgress }); break;
                    case GameScreenState.CLASS_SELECTION: MainScreenComponent = React.createElement(ClassSelectionScreen, { setMainScreen, systemCores, classes: CLASS_DEFINITIONS, selectedClassId: permanentBuffsState.selectedClassId, unlockedClasses, onSelectClass: handleSelectClass, onUnlockClass: (id, cost) => { if (systemCores >= cost) { updateSystemCores(systemCores - cost); addUnlockedClass(id); }} }); break;
                    case GameScreenState.EVOLUTION_GUIDE: MainScreenComponent = React.createElement(EvolutionGuideScreen, { setMainScreen }); break;
                    case GameScreenState.SKIN_SELECTION: MainScreenComponent = React.createElement(SkinSelectionScreen, { setMainScreen, systemCores, corruptedKernels, unlockedSkins, equippedSkinId: permanentBuffsState.selectedSkinId, onEquipSkin: handleEquipSkin, onUnlockSkin: handleUnlockSkin, onUnlockSkinCorrupted: handleUnlockSkinCorrupted }); break;
                    case GameScreenState.MODIFIER_SELECTION: MainScreenComponent = React.createElement(ModifierSelectionScreen, { setMainScreen, startGameWithModifiers }); break; 
                    case GameScreenState.TALENT_TREE: MainScreenComponent = React.createElement(TalentTreeScreen, { systemCores, corruptedKernels, permanentBuffs: permanentBuffsState.shop, updateSystemCores, updateCorruptedKernels, updatePermanentBuff }); break;
                    case GameScreenState.ARSENAL: MainScreenComponent = React.createElement(ArsenalScreen, { corruptedKernels, updateCorruptedKernels }); break;
                    case GameScreenState.DECOMPILER: MainScreenComponent = React.createElement(DecompilerScreen, {}); break;
                    case GameScreenState.ACHIEVEMENTS: MainScreenComponent = React.createElement(AchievementsScreen, { unlockedAchievements }); break;
                    case GameScreenState.RANKING: MainScreenComponent = React.createElement(RankingScreen, {}); break;
                    case GameScreenState.GLOBAL_STATS: MainScreenComponent = React.createElement(GlobalStatsScreen, { permanentBuffs: permanentBuffsState, achievementBuffs }); break;
                    case GameScreenState.CODEX: MainScreenComponent = React.createElement(CodexScreen, {}); break;
                    case GameScreenState.PATCH_NOTES: MainScreenComponent = React.createElement(PatchNotesScreen, {}); break;
                    case GameScreenState.SETTINGS: MainScreenComponent = React.createElement(SettingsScreen, { soundSettings, onVolumeChange: handleVolumeChange, onMuteToggle: handleMuteToggle, setGameScreen }); break;
                    case GameScreenState.PROFILE: MainScreenComponent = React.createElement(ProfileScreen, { userProfile, updateProfile, unlockedAchievements }); break;
                 }
            }
            
            const crisolChamberData = crisolEngineHookValues.gameState.chamberId
                ? CRISOL_CHAMBERS.find(c => c.id === crisolEngineHookValues.gameState.chamberId)
                : null;

            return React.createElement('div', { className: "w-full h-full flex flex-col items-center justify-start relative bg-[#010409]" },
                React.createElement('div', { className: 'fixed top-28 right-4 z-50 flex flex-col items-end space-y-2' },
                    toastQueue.map((ach, index) => 
                        React.createElement(AchievementToast, { 
                            key: ach.id + index,
                            achievement: ach, 
                            onDismiss: () => setToastQueue(q => q.filter((_, i) => i !== 0))
                        })
                    )
                ),

                gameScreen === GameScreenState.CRISOL_PAUSED && React.createElement(CrisolPauseScreen, {
                    onResume: () => { SoundManager.play('uiClick'); crisolEngineRef.current.resumeGame(); setGameScreen(GameScreenState.CRISOL_CHAMBER); },
                    onRestart: handleCrisolRestart,
                    onReturnToHub: handleCrisolReturnToHub
                }),

                gameScreen === GameScreenState.INTRO && React.createElement(IntroScreen, { onStart: () => { SoundManager.play('uiClick'); setGameScreen(GameScreenState.MODE_SELECTION); setMainScreen(GameScreenState.MODE_SELECTION); } }),
                mainHubVisible && React.createElement(MainLayout, null,
                    React.createElement(Sidebar, { activeScreen: mainScreen, setScreen: setMainScreen }),
                    React.createElement('main', { className: 'flex-grow h-full overflow-y-auto' }, MainScreenComponent)
                ),
                
                mainHubVisible && userProfile && React.createElement(ChatPanel, { userProfile }),

                uiAndCanvasVisible && engineHookValues && React.createElement(React.Fragment, null,
                    gameScreen === GameScreenState.GAME_OVER && React.createElement(GameOverScreen, { setMainScreen, setGameScreen, gameTime: finalGameStats.gameTime, score: finalGameStats.score }),
                    gameScreen === GameScreenState.LEVEL_UP && React.createElement(LevelUpScreen, { resumeGame: performResumeGame, options: currentLevelUpOptions, applyUpgrade: engineHookValues.applyUpgrade, onReroll: handleLevelUpReroll, rerollsAvailable: rerollsForCurrentLevelUp, isFirstLevelUp: isFirstLevelUp }),
                    gameScreen === GameScreenState.PAUSED && React.createElement(PauseScreen, { setMainScreen, setGameScreen, resumeGameCallback: performResumeGame, startGameCallback: () => startGameWithModifiers(new Set((engineHookValues.gameState.player.activeModifiers || []).map(m => m.id))), ownedUpgrades: engineHookValues.ownedUpgradesRef.current, activeClass: currentClassDef, soundSettings: soundSettings, onVolumeChange: handleVolumeChange, onMuteToggle: handleMuteToggle, engineRef: engineHookValues }),
                    gameScreen === GameScreenState.BOSS_WARNING && React.createElement(BossWarningScreen, { stage: engineHookValues.gameState.stage }),
                    gameScreen === GameScreenState.STAGE_CLEAR && React.createElement(StageClearScreen, { startNextStageCallback: startNextStage }),
                    gameScreen === GameScreenState.STAGE_2_CLEAR && React.createElement(StageClearScreen2, { startNextStageCallback: startNextStage }),
                    gameScreen === GameScreenState.STAGE_3_CLEAR && React.createElement(StageClearScreen3, { startNextStageCallback: startNextStage }),
                    gameScreen === GameScreenState.NEXUS_DEFEATED && React.createElement(NexusDefeatedScreen, { resumeGameCallback: handleEnterInfiniteMode })
                ),
                
                gameScreen === GameScreenState.CRISOL_RESULT && (
                    React.createElement(CrisolResultScreen, { 
                        result: crisolResult, 
                        setGameScreen, 
                        startChamber: (id) => { if(crisolEngineHookValues) { setGameScreen(GameScreenState.CRISOL_CHAMBER); crisolEngineHookValues.startChamber(id); } }, 
                        startInfinite: () => { if(crisolEngineHookValues) crisolEngineHookValues.startInfinite(); }, 
                        crisolProgress, 
                        setMainScreen 
                    })
                ),

                (uiAndCanvasVisible || crisolCanvasVisible) && (
                    React.createElement('div', { className: 'w-full h-full flex flex-row' },
                        uiAndCanvasVisible && engineHookValues ? React.createElement(LeftSidebar, { gameState: engineHookValues.gameState }) : React.createElement('div', { className: 'w-56 flex-shrink-0 bg-black/50' }),
                        
                        React.createElement('div', { className: 'flex-grow h-full flex flex-col items-center justify-center relative' },
                            uiAndCanvasVisible && engineHookValues && React.createElement(UIOverlay, { gameState: engineHookValues.gameState }),
                            crisolCanvasVisible && crisolEngineHookValues && React.createElement(CrisolUI, { gameState: crisolEngineHookValues.gameState, chamberData: crisolChamberData }),
                            
                            React.createElement(GameCanvas, { 
                                gameState: uiAndCanvasVisible && engineHookValues ? engineHookValues.gameState : null, 
                                gameScreen, 
                                crisolGameState: crisolCanvasVisible && crisolEngineHookValues ? crisolEngineHookValues.gameState : null
                            })
                        ),

                        uiAndCanvasVisible && engineHookValues ? React.createElement(RightSidebar, { gameState: engineHookValues.gameState }) : React.createElement('div', { className: 'w-56 flex-shrink-0 bg-black/50' })
                    )
                )
            );
        };
        // --- END OF App.tsx ---

        // --- START OF index.tsx (ReactDOM rendering) ---
        const rootElement = document.getElementById('root');
        if (!rootElement) { throw new Error("Could not find root element to mount to"); }
        const root = ReactDOM.createRoot(rootElement);
        root.render( React.createElement(React.StrictMode, null, React.createElement(App)) );
        // --- END OF index.tsx ---
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>