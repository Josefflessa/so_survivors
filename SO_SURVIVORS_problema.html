<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Survivors</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/emoji-toolkit@7.0.0/lib/js/joypixels.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.production.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #0d1117; /* --bg-medium */
            color: #c9d1d9; /* --text-color */
            overflow: hidden;
        }
        .font-press-start {
            font-family: 'Press Start 2P', cursive;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0d1117; /* --bg-medium */
        }
        ::-webkit-scrollbar-thumb {
            background: #30363d; /* --border-color */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #2f81f7; /* --player-color */
        }
        
        /* Custom scrollbar for the skin list */
        #skin-list-container::-webkit-scrollbar-thumb {
             background: #ffc107; /* --text-yellow */
        }

        .health-bar-fill.low { background-color: #f85149 !important; } /* --enemy-color */

        /* General focus outline for accessibility */
        *:focus-visible {
            outline: 3px solid #2f81f7; /* --player-color */
            outline-offset: 2px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-fadeIn { animation: fadeIn 0.5s ease-out forwards; }
        
        @keyframes toastInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes toastOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        .toast-in { animation: toastInRight 0.5s ease-out forwards; }
        .toast-out { animation: toastOutRight 0.5s ease-in forwards; }

        /* For Tailwind accent color compatibility if needed */
        .accent-player-color {
            accent-color: var(--player-color, #2f81f7);
        }

        /* --- TALENT TREE & MAIN MENU NEW STYLES --- */
        @keyframes hexgrid-scroll {
            0% { background-position: 0 0; }
            100% { background-position: -104px 60px; }
        }
        .hub-background {
            background-color: #010409;
            background-image:
                radial-gradient(ellipse at center, rgba(13, 17, 23, 0.5) 0%, rgba(1, 4, 9, 1) 80%),
                linear-gradient(rgba(13, 17, 23, 0.95) 0%, rgba(13, 17, 23, 0.95) 100%),
                linear-gradient(60deg, #0d1117 1px, transparent 1px, transparent 26px, #0d1117 26px, #0d1117 27px, transparent 27px),
                linear-gradient(120deg, #0d1117 1px, transparent 1px, transparent 26px, #0d1117 26px, #0d1117 27px, transparent 27px),
                linear-gradient(#0d1117 1px, transparent 1px, transparent 26px, #0d1117 26px, #0d1117 27px, transparent 27px);
            background-size: 100% 100%, 100% 100%, 52px 30px, 52px 30px, 52px 30px;
            animation: hexgrid-scroll 5s linear infinite;
        }
        .hexagon-clip {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        .talent-node-shadow-defense { box-shadow: 0 0 15px 3px rgba(59, 130, 246, 0.5); }
        .talent-node-shadow-offense { box-shadow: 0 0 15px 3px rgba(239, 68, 68, 0.5); }
        .talent-node-shadow-utility { box-shadow: 0 0 15px 3px rgba(251, 191, 36, 0.5); }
        .talent-node-shadow-ultimate { box-shadow: 0 0 20px 5px rgba(168, 85, 247, 0.6); }
        .talent-node-shadow-maxed { box-shadow: 0 0 20px 5px rgba(250, 204, 21, 0.7); }
        .talent-node-shadow-corrupted { box-shadow: 0 0 20px 5px rgba(217, 70, 239, 0.6); }

        @keyframes line-flow {
            to { stroke-dashoffset: -100; }
        }
        .line-flow-anim {
            stroke-dasharray: 20 10;
            animation: line-flow 3s linear infinite;
        }
        /* Markdown styles for Patch Notes */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            font-family: 'Press Start 2P', cursive;
            border-bottom: 2px solid #30363d;
            padding-bottom: 0.3em;
            margin-bottom: 1rem;
        }
        .markdown-content h1 { font-size: 1.8rem; color: #38bdf8; }
        .markdown-content h2 { font-size: 1.4rem; color: #67e8f9; }
        .markdown-content h3 { font-size: 1.1rem; color: #a5f3fc; }
        .markdown-content ul { list-style-type: '¬ª '; padding-left: 1.5rem; }
        .markdown-content li { margin-bottom: 0.5rem; }
        .markdown-content strong { color: #facc15; }
        .markdown-content code { background-color: #161b22; padding: 0.2em 0.4em; border-radius: 6px; font-family: 'VT323', monospace; }
    
        .joypixels {
            display: inline-block;  /* Permite que a imagem se comporte como texto */
            height: 1.2em;          /* Define a altura relativa ao tamanho da fonte do texto ao redor */
            width: 1.2em;           /* Define a largura para manter a propor√ß√£o */
            vertical-align: middle; /* Alinha a imagem verticalmente com o meio do texto */
            margin: 0 0.1em;        /* Adiciona um pequeno espa√ßamento horizontal */
        }

        /* Opcional: Para os bot√µes do seletor, podemos aumentar um pouco */
        .emoji-picker-button .joypixels {
            height: 1.5em;
            width: 1.5em;
        }

/* --- LEVEL UP SCREEN NEW STYLES (V4 - Frosted Glass Overlay) --- */
.levelup-container {
    position: absolute;
    inset: 0;
    z-index: 20;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    
    /* A M√ÅGICA ACONTECE AQUI */
    background-color: rgba(1, 4, 9, 0.65); /* Cor escura semi-transparente */
    backdrop-filter: blur(8px) brightness(65%); /* Desfoca e escurece o que est√° atr√°s */
    -webkit-backdrop-filter: blur(8px) brightness(65%); /* Suporte para Safari */

    overflow: hidden;
}

/* O resto dos estilos permanece o mesmo, mas s√£o inclu√≠dos aqui para garantir */
@keyframes title-fade-in { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
@keyframes core-fade-in { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
@keyframes card-slide-in-left { from { opacity: 0; transform: translateX(-50px); } to { opacity: 1; transform: translateX(0); } }
@keyframes card-slide-in-right { from { opacity: 0; transform: translateX(50px); } to { opacity: 1; transform: translateX(0); } }

.central-conduit { perspective: 1000px; }
.central-conduit-core { width: 140px; height: 140px; position: relative; transform-style: preserve-3d; animation: core-fade-in 0.5s ease-out; }
.conduit-ring { position: absolute; inset: 0; border-radius: 50%; border: 4px solid; animation: spin 12s linear infinite; }
@keyframes spin { from { transform: rotateY(0deg) rotateX(70deg); } to { transform: rotateY(360deg) rotateX(70deg); } }

.upgrade-card-module {
    width: 350px; 
    height: 190px;
    background: linear-gradient(145deg, rgba(22, 27, 34, 0.85), rgba(13, 17, 23, 0.85)); /* Fundo do card um pouco transl√∫cido */
    backdrop-filter: blur(4px); /* Desfoque sutil no pr√≥prio card */
    border: 2px solid rgba(48, 54, 61, 0.8);
    border-radius: 0.5rem;
    padding: 1rem 1.25rem;
    position: relative;
    display: flex;
    flex-direction: column;
    transition: all 0.2s ease-in-out;
    cursor: pointer;
    opacity: 0;
    animation-fill-mode: forwards;
}
.upgrade-card-module.from-left { animation-name: card-slide-in-left; }
.upgrade-card-module.from-right { animation-name: card-slide-in-right; }
.upgrade-card-module:hover { border-color: #38bdf8; box-shadow: 0 0 25px rgba(56, 189, 248, 0.4); }
.upgrade-card-module:hover.from-left { transform: translateX(10px); }
.upgrade-card-module:hover.from-right { transform: translateX(-10px); }

.card-connector { position: absolute; top: 50%; transform: translateY(-50%); width: 24px; height: 48px; background-color: #4b5563; border: 2px solid #30363d; }
.card-connector.left { right: -26px; border-radius: 0 8px 8px 0; }
.card-connector.right { left: -26px; border-radius: 8px 0 0 8px; }

.connection-line { stroke-width: 3px; stroke: #2563eb; fill: none; transition: all 0.2s ease-in-out; stroke-dasharray: 4 8; }
.connection-line.active { stroke: #38bdf8; stroke-width: 4px; stroke-dasharray: 30 10; animation: line-flow 1s linear infinite; }

    
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-markdown": "https://esm.sh/react-markdown@8.0.7",
    "remark-gfm": "https://esm.sh/remark-gfm@3.0.1"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="flex flex-col items-center justify-center h-screen m-0 bg-[#0d1117]">
    <div id="root" class="w-full h-full flex flex-col items-center justify-center"></div>
    <script>

    </script>
    <script type="module">
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import ReactMarkdown from 'react-markdown';
        import remarkGfm from 'remark-gfm';
        import { produce } from "https://esm.sh/immer@9.0.12";

        // --- INICIALIZA√á√ÉO CORRETA DO SUPABASE ---
        const SUPABASE_URL = 'https://ffmxdkgijolpxnslursz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZmbXhka2dpam9scHhuc2x1cnN6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIxOTY0NzIsImV4cCI6MjA2Nzc3MjQ3Mn0.3oczYmSYUABV9veK2LjE9JqGvixupD0FOv2MWMLOuMg';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        if (supabase) {
            console.log("Supabase client initialized.");
        } else {
            console.error("Failed to initialize Supabase client.");
        }

        // --- START OF CUSTOM HOOK: useImmerState ---
        const { useState: useImmerInitialState, useCallback: useImmerCallback } = React;

        const useImmerState = (initialState) => {
            // Usamos o useState normal por baixo dos panos
            const [state, setState] = useImmerInitialState(initialState);
            
            // Criamos uma nova fun√ß√£o `setImmerState` que aceita uma "receita" do immer
            const setImmerState = useImmerCallback((updater) => {
                // A m√°gica acontece aqui: `produce` √© chamado dentro do setState
                setState(prevState => produce(prevState, updater));
            }, []);

            // Retornamos o estado e nossa nova fun√ß√£o de atualiza√ß√£o
            return [state, setImmerState];
        };
        // --- END OF CUSTOM HOOK: useImmerState ---


        // --- START OF SoundManager.ts ---
        const SoundManager = (() => {
            let audioCtx;
            const sounds = {};
            let globalVolume = 0.5; // Default volume
            let isMuted = false;    // Default mute state
            const SOUND_SETTINGS_KEY = 'os_survivors_sound_settings';

            const loadSettings = () => {
                try {
                    const storedSettings = localStorage.getItem(SOUND_SETTINGS_KEY);
                    if (storedSettings) {
                        const parsed = JSON.parse(storedSettings);
                        globalVolume = typeof parsed.volume === 'number' ? Math.max(0, Math.min(1, parsed.volume)) : 0.5;
                        isMuted = typeof parsed.muted === 'boolean' ? parsed.muted : false;
                    }
                } catch (e) {
                    console.error("Error loading sound settings:", e);
                    globalVolume = 0.5;
                    isMuted = false;
                }
            };

            const saveSettings = () => {
                try {
                    localStorage.setItem(SOUND_SETTINGS_KEY, JSON.stringify({ volume: globalVolume, muted: isMuted }));
                } catch (e) {
                    console.error("Error saving sound settings:", e);
                }
            };
            
            const init = () => {
                if (!audioCtx && typeof AudioContext !== 'undefined') {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                loadSettings(); 
            };


            const playTone = (frequency, duration, type = 'sine', individualVolume = 0.3, pan = 0, decay = 0.1) => {
                if (isMuted) return; 
                if (!audioCtx) init();
                if (!audioCtx) return;
                if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.warn("AudioContext resume failed:", e));

                const effectiveVolume = individualVolume * globalVolume; 

                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                
                gainNode.gain.setValueAtTime(effectiveVolume, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration + decay);


                if (panner) {
                    panner.pan.setValueAtTime(pan, audioCtx.currentTime);
                    oscillator.connect(panner);
                    panner.connect(gainNode);
                } else {
                    oscillator.connect(gainNode);
                }
                gainNode.connect(audioCtx.destination);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + duration + decay + 0.05); 
            };

            const playNoise = (duration, individualVolume = 0.2, pan = 0, attack = 0.01, decay = 0.1) => {
                if (isMuted) return; 
                if (!audioCtx) init();
                if (!audioCtx) return;
                 if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.warn("AudioContext resume failed:", e));

                const effectiveVolume = individualVolume * globalVolume; 

                const bufferSize = audioCtx.sampleRate * (duration + attack + decay); 
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; 
                }

                const noiseNode = audioCtx.createBufferSource();
                noiseNode.buffer = buffer;
                const gainNode = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

                gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(effectiveVolume, audioCtx.currentTime + attack);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + attack + duration + decay);


                if (panner) {
                    panner.pan.setValueAtTime(pan, audioCtx.currentTime);
                    noiseNode.connect(panner);
                    panner.connect(gainNode);
                } else {
                    noiseNode.connect(gainNode);
                }
                
                gainNode.connect(audioCtx.destination);
                noiseNode.start(audioCtx.currentTime);
                noiseNode.stop(audioCtx.currentTime + attack + duration + decay + 0.05);
            };
            
            sounds.shoot = () => playTone(330, 0.05, 'square', 0.08, -0.2, 0.05); 
            sounds.enemyHit = () => playTone(180, 0.04, 'sawtooth', 0.1, 0.2, 0.04);
            sounds.enemyDie = () => playNoise(0.15, 0.15, Math.random()*0.4 - 0.2, 0.01, 0.1);
            sounds.pickupXP = () => playTone(900, 0.03, 'sine', 0.06, 0, 0.03);
            sounds.pickupHealth = () => playTone(600, 0.15, 'triangle', 0.2, 0, 0.1);
            sounds.levelUp = () => { playTone(523, 0.08, 'sine', 0.25, -0.1, 0.1); setTimeout(() => playTone(659, 0.08, 'sine', 0.25, 0, 0.1), 80); setTimeout(() => playTone(783, 0.12, 'sine', 0.25, 0.1, 0.15), 160); };
            sounds.gameOver = () => { playNoise(0.4, 0.3, 0, 0.05, 0.3); setTimeout(() => playTone(100, 0.6, 'sawtooth', 0.25, 0, 0.5), 80); };
            sounds.playerHit = () => playTone(150, 0.1, 'square', 0.25, 0, 0.1);
            sounds.acidVirusShot = () => playTone(220, 0.08, 'sawtooth', 0.09, 0, 0.1);
            sounds.acidVirusImpact = () => playNoise(0.1, 0.12, 0, 0.01, 0.09); 
            sounds.acidSporeLaunch = () => playTone(600, 0.05, 'sine', 0.1, 0, 0.05); 
            sounds.bossWarning = () => { playTone(130.81, 0.4, 'sawtooth', 0.4); setTimeout(() => playNoise(0.25, 0.25, 0, 0.05, 0.2), 150); };
            sounds.uiClick = () => playTone(700, 0.05, 'triangle', 0.1, 0, 0.05);
            sounds.upgradeSelect = () => playTone(650, 0.08, 'sine', 0.15, 0, 0.08);
            sounds.kernelUnlock = () => { playTone(440, 0.1, 'sine', 0.2); setTimeout(() => playTone(880, 0.15, 'sine', 0.2), 100); };
            sounds.permanentUpgrade = () => playTone(550, 0.12, 'square', 0.18, 0, 0.1);
            sounds.freezeSound = () => playTone(1200, 0.1, 'sine', 0.15, 0, 0.15); 
            sounds.chainLightningSound = () => playTone(800, 0.03, 'sawtooth', 0.12, Math.random()*0.6-0.3, 0.03); 
            sounds.minionSpawn = () => playNoise(0.1, 0.1, Math.random() * 0.5 - 0.25, 0.02, 0.08);
            sounds.minionConvert = () => playTone(880, 0.1, 'triangle', 0.15, 0, 0.1);
            sounds.minionModeSwitch = () => playTone(300, 0.08, 'square', 0.1, 0, 0.08);
            sounds.corruptedZoneAppear = () => playTone(80, 0.3, 'sawtooth', 0.2, 0, 0.2);
            sounds.kernelPanicCharge = () => playTone(70, 1.5, 'sine', 0.4, 0, 0.1);
            sounds.kernelPanicExecute = () => { playNoise(0.6, 0.5, 0, 0.01, 0.4); playTone(50, 0.5, 'square', 0.35, 0, 0.3); };
            sounds.dataStreamFire = () => playTone(450, 0.02, 'triangle', 0.06, Math.random()*0.2-0.1, 0.02);
            sounds.bossPhaseChange = () => { playNoise(0.3, 0.3, 0, 0.02, 0.2); playTone(200, 0.2, 'sawtooth', 0.25, 0, 0.1);};
            sounds.teleportCharge = () => playTone(400, 0.4, 'sine', 0.15, 0, 0.05);
            sounds.teleportExecute = () => playTone(1000, 0.1, 'triangle', 0.2, 0, 0.1);
            sounds.shieldActivate = () => playNoise(0.1, 0.1, 0, 0.01, 0.08);
            sounds.shieldBreak = () => playNoise(0.2, 0.2, 0, 0.05, 0.15);
            sounds.zombieRevive = () => playTone(90, 0.5, 'sawtooth', 0.2, 0, 0.3);
            sounds.laserCharge = () => playTone(200, 1.0, 'sine', 0.3, 0, 0.1);
            sounds.laserFire = () => playNoise(1.5, 0.4, 0, 0.1, 0.5);
            sounds.playerDash = () => playTone(800, 0.08, 'sawtooth', 0.15, 0, 0.1);
            sounds.pickupBuff = () => playTone(1000, 0.1, 'triangle', 0.2, 0, 0.1);
            sounds.cleanseComplete = () => playTone(783, 0.15, 'sine', 0.25, 0, 0.15);
            sounds.enterDebuffZone = () => playTone(120, 0.2, 'square', 0.1, 0, 0.15);
            sounds.defragSwing = () => playNoise(0.08, 0.12, 0, 0.01, 0.07);
            sounds.dataLeechConnect = () => playTone(250, 0.1, 'triangle', 0.1, 0, 0.1);
            sounds.achievementUnlock = () => { playTone(659, 0.08, 'sine', 0.3, -0.2, 0.1); setTimeout(() => playTone(880, 0.15, 'triangle', 0.3, 0.2, 0.15), 100); };
            sounds.eventStart = () => playTone(200, 0.3, 'sawtooth', 0.3, 0, 0.2);
            sounds.eventSuccess = () => { playTone(783, 0.1, 'sine', 0.3); setTimeout(() => playTone(1046, 0.15, 'sine', 0.3), 120); };


            const resumeAudio = () => {
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(e => console.warn("AudioContext resume failed on user interaction:", e));
                }
            };
            
            const interactionEvents = ['click', 'keydown', 'touchstart'];
            const addResumeListeners = () => {
                interactionEvents.forEach(event => {
                    document.addEventListener(event, resumeAudio, { once: true });
                });
            };
            
            addResumeListeners();


            return {
                init, 
                play: (soundName) => {
                    if (isMuted) return;
                    if (!audioCtx) init(); 
                    if (!audioCtx) return; 
                    
                    if (audioCtx.state === 'suspended') {
                         audioCtx.resume().then(() => {
                            if (sounds[soundName]) {
                                sounds[soundName]();
                            } else {
                                console.warn(`Sound ${soundName} not found.`);
                            }
                         }).catch(e => console.warn("AudioContext resume failed in play:", e));
                         return; 
                    }


                    if (sounds[soundName]) {
                        sounds[soundName]();
                    } else {
                        console.warn(`Sound ${soundName} not found.`);
                    }
                },
                getVolume: () => globalVolume,
                setVolume: (level) => {
                    globalVolume = Math.max(0, Math.min(1, parseFloat(level)));
                    saveSettings();
                },
                isMuted: () => isMuted,
                setMuted: (mute) => {
                    isMuted = !!mute;
                    saveSettings();
                }
            };
        })();
        // --- END OF SoundManager.ts ---

        // --- START OF types.ts (converted to JS objects/comments) ---
        const GameScreenState = {
            // Screens with no main layout
            INTRO: 0,
            
            // Screens for the game UI
            PLAYING: 1,
            LEVEL_UP: 2,
            GAME_OVER: 3,
            PAUSED: 4,
            BOSS_WARNING: 5,
            BOSS_FIGHT: 6,
            STAGE_CLEAR: 7, 
            STAGE_2_CLEAR: 18,
            STAGE_3_CLEAR: 19,      // --- ALTERADO --- (era ARBITER_DEFEATED)
            NEXUS_DEFEATED: 26,     // --- NOVO ---
            INFINITE_MODE: 20,
            
            // Screens for the new Main Hub Layout
            PROFILE: 27,
            TALENT_TREE: 8,
            RANKING: 10,
            CLASS_SELECTION: 12, 
            ACHIEVEMENTS: 13,
            GLOBAL_STATS: 14,
            DECOMPILER: 15,
            SKIN_SELECTION: 16,
            EVOLUTION_GUIDE: 17,
            ARSENAL: 21,
            MODE_SELECTION: 22,
            PATCH_NOTES: 23,
            SETTINGS: 24,
            CODEX: 25,
            NEXUS_DEFEATED: 26,
            MODIFIER_SELECTION: 33,
            CRISOL_HUB: 28,           // Tela de sele√ß√£o de c√¢maras
            CRISOL_CHAMBER: 29,       // Jogando uma c√¢mara finita
            CRISOL_INFINITE: 30,      // Jogando o modo infinito
            CRISOL_RESULT: 31,        // Tela de resultado (vit√≥ria/derrota)
            CRISOL_PAUSED: 32,
        };

        const EnemyType = {
            // Fase 1
            DEFAULT: 'default',
            MEMORY_LEAK: 'memory_leak',
            SPYWARE: 'spyware',
            TROJAN_HORSE: 'trojan_horse',
            MALWARE_FRAGMENT: 'malware_fragment',
            ROOTKIT: 'rootkit',
            DDOS_BOT: 'ddos_bot',
            GLITCH_MINION: 'glitch_minion',
            // Fase 2
            PROCESSO_CORROMPIDO: 'processo_corrompido',
            PONTEIRO_NULO: 'ponteiro_nulo',
            SEGMENTO_FALHA: 'segmento_falha',
            PROCESSO_ZUMBI: 'processo_zumbi',
            // Fase 3
            NANITE: 'nanite',
            HEATSINK: 'heatsink',
            IO_CONTROLLER: 'io_controller',
            VOLATILE_PROCESS: 'volatile_process',
            // --- FASE 4 (NOVO) ---
            RECURSIVE_PROCESS: 'recursive_process',
            CHILD_PROCESS: 'child_process',
            ROGUE_FIREWALL: 'rogue_firewall',
            LATENCY_SPIKE: 'latency_spike',
            PROTOCOL_ANOMALY: 'protocol_anomaly',
        };

        const StatusEffectType = {
            SLOW: 'SLOW',
            FREEZE: 'FREEZE',
            VULNERABILITY: 'VULNERABILITY',
            FEAR: 'FEAR',
        };
        
        const TemporaryBuffType = {
            MOVE_SPEED: 'MOVE_SPEED',
            ATTACK_SPEED: 'ATTACK_SPEED',
            DAMAGE_AMP: 'DAMAGE_AMP',
            REGEN: 'REGEN',
            DAMAGE_REDUCTION: 'DAMAGE_REDUCTION',
        };

        const InteractableType = {
            DATA_CACHE: 'DATA_CACHE',
            CORRUPTED_LIBRARY: 'CORRUPTED_LIBRARY',
        };
        
        const BossAttackType = {
            DATA_SMASHER: 'DATA_SMASHER',
            CORRUPTION_WAVE: 'CORRUPTION_WAVE',
            HOSTILE_TAKEOVER: 'HOSTILE_TAKEOVER',
            LOGIC_BOMB: 'LOGIC_BOMB',
            FINAL_JUDGEMENT: 'FINAL_JUDGEMENT'
        };

        // --- END OF types.ts ---

        // --- START OF constants.ts ---
        const CANVAS_WIDTH = 1920;
        const CANVAS_HEIGHT = 1440; 
        const RANKING_KEY = 'os_survivors_ranking_local'; 
        const GLOBAL_STATS_KEY = 'os_survivors_global_stats';
        const DECOMPILER_STATS_KEY = 'os_survivors_decompiler_stats';
        const WEAPON_MASTERY_KEY = 'os_survivors_weapon_mastery_stats';
        const NIGHTMARE_UNLOCKED_KEY = 'os_survivors_nightmare_unlocked';
        const CORRUPTED_KERNELS_KEY = 'os_survivors_corrupted_kernels';
        const MAX_RANKING_ENTRIES = 10;

        // --- START OF SUPABASE INTEGRATION ---

const fetchOnlineRankings = async () => {
    if (!supabase) {
        console.error("Supabase client n√£o est√° inicializado.");
        return [];
    }
    try {
        // Seleciona todas as colunas da tabela 'rankings'
        // Ordena por 'score' em ordem decrescente
        // Limita o resultado a 10 entradas
        const { data, error } = await supabase
            .from('rankings')
            .select('*')
            .order('score', { ascending: false })
            .limit(10);

        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error("Erro ao buscar ranking do Supabase:", error);
        return [];
    }
};

// Adicione esta constante no topo do seu arquivo, junto com as outras
const BEST_ONLINE_SCORE_KEY = 'os_survivors_best_online_score';

// Substitua a fun√ß√£o inteira por esta
const submitScoreToOnlineRanking = async (name, score, time, classId, userId) => {
    if (!supabase || !userId) {
        console.error("Supabase client ou User ID n√£o est√£o dispon√≠veis. Pontua√ß√£o n√£o ser√° salva.");
        return;
    }

    try {
        // <<< 1. L√ìGICA LOCAL DE VERIFICA√á√ÉO >>>
        // Pega a melhor pontua√ß√£o online que j√° enviamos deste navegador.
        const storedBestScore = parseInt(localStorage.getItem(BEST_ONLINE_SCORE_KEY), 10) || 0;

        // Se a pontua√ß√£o atual n√£o for maior, n√£o fazemos nada.
        if (score <= storedBestScore) {
            console.log(`Pontua√ß√£o local (${score}) n√£o √© maior que o recorde online salvo (${storedBestScore}). N√£o ser√° enviada.`);
            return; // PARA A EXECU√á√ÉO AQUI
        }

        // <<< 2. CHAMADA SIMPLIFICADA PARA O SUPABASE >>>
        // Usamos um 'upsert' que vai INSERIR se o user_id for novo, ou ATUALIZAR se j√° existir.
        // Como a gente j√° filtrou a pontua√ß√£o no passo 1, s√≥ atualizaremos com pontua√ß√µes maiores.
        const { error } = await supabase
            .from('rankings')
            .upsert({
                user_id: String(userId), // A coluna de conflito, deve ser √öNICA na sua tabela
                name: name.trim() === '' ? 'An√¥nimo' : name.trim(),
                score: Number(score),
                "time": Number(time), // Nome da coluna entre aspas porque 'time' √© palavra reservada em SQL
                class_id: String(classId),
                date: new Date().toLocaleDateString() // Adiciona a data atual
            }, {
                onConflict: 'user_id' // Informa ao Supabase qual coluna usar para detectar conflitos
            });

        if (error) {
            // Se ainda der erro, ser√° mais f√°cil de depurar.
            console.error("Erro ao fazer upsert da pontua√ß√£o no Supabase:", error);
            // Poss√≠vel causa do erro: a coluna 'user_id' n√£o est√° definida como UNIQUE ou PRIMARY KEY na sua tabela do Supabase.
            throw error;
        }

        // <<< 3. ATUALIZA√á√ÉO DO RECORDE LOCAL >>>
        // Se o envio foi bem-sucedido, atualizamos o recorde local.
        localStorage.setItem(BEST_ONLINE_SCORE_KEY, score.toString());
        console.log(`Novo recorde online (${score}) salvo localmente e enviado com sucesso!`);

    } catch (error) {
        // O console.error j√° est√° dentro da fun√ß√£o original.
        // Apenas para garantir que a mensagem de erro seja clara.
        console.error("Falha na fun√ß√£o submitScoreToOnlineRanking:", error);
    }
};

const fetchPatchNotesJSON = async () => {
    if (!supabase) {
        console.error("Supabase client n√£o est√° inicializado.");
        return [];
    }
    try {
        // Seleciona as colunas da tabela 'patch_notes'
        // CORRE√á√ÉO: Ordena pela coluna 'date', que existe na sua tabela.
        const { data, error } = await supabase
            .from('patch_notes')
            .select('title, date, notes')
            .order('date', { ascending: false });

        if (error) throw error;
        
        // O Supabase j√° retorna os dados prontos, n√£o precisa de JSON.parse
        return data || [];
    } catch (error) {
        console.error("Erro ao buscar patch notes do Supabase:", error);
        throw error;
    }
};

// --- END OF SUPABASE INTEGRATION ---

        const DECOMPILER_TIERS = {
            TIER_1: 600,
            TIER_2: 1200,
            TIER_3: 2400,
            TIER_4: 4800,
        };
        
        const WEAPON_MASTERY_CONFIG = [
            {
                weaponId: 'antivirus',
                name: 'Antiv√≠rus',
                icon: 'üéØ',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+5% de Dano para o Antiv√≠rus', bonus: { type: 'damage_multiplier', value: 0.05 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+10% Velocidade de Proj√©til', bonus: { type: 'projectile_speed', value: 0.10 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Primeiro tiro em um novo alvo sempre √© Cr√≠tico.', bonus: { type: 'first_shot_crit', value: true } },
                ]
            },
            {
                weaponId: 'firewall',
                name: 'Firewall',
                icon: 'üõ°Ô∏è',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+8% de Dano de contato dos orbes', bonus: { type: 'damage_multiplier', value: 0.08 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+15% Raio Orbital', bonus: { type: 'radius_multiplier', value: 0.15 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Orbes de Firewall podem bloquear proj√©teis inimigos.', bonus: { type: 'projectile_block', value: true } },
                ]
            },
            {
                weaponId: 'acid_virus',
                name: 'V√≠rus √Åcido',
                icon: 'ü¶†',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+10% Dano da Po√ßa de √Åcido', bonus: { type: 'dot_damage_multiplier', value: 0.10 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+15% Dura√ß√£o da Po√ßa de √Åcido', bonus: { type: 'duration_multiplier', value: 0.15 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Po√ßas de √Åcido reduzem a armadura dos inimigos em 10%', bonus: { type: 'armor_shred', value: 0.10 } },
                ]
            },
            {
                weaponId: 'defrag',
                name: 'Desfragmentador',
                icon: '‚öîÔ∏è',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+5% Dano para o Desfragmentador', bonus: { type: 'damage_multiplier', value: 0.05 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '-10% Recarga do Desfragmentador', bonus: { type: 'cooldown_multiplier', value: -0.10 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'Atingir 3 ou mais inimigos com um √∫nico golpe concede um b√¥nus de velocidade tempor√°rio.', bonus: { type: 'speed_on_cleave', value: true } },
                ]
            },
            {
                weaponId: 'data_leech',
                name: 'Data Leech',
                icon: 'üîó',
                tiers: [
                    { damageRequired: 1000000, cost: 0, bonusText: '+8% Dano do Data Leech', bonus: { type: 'damage_multiplier', value: 0.08 } },
                    { damageRequired: 5000000, cost: 0, bonusText: '+15% Alcance do Raio', bonus: { type: 'range_multiplier', value: 0.15 } },
                    { damageRequired: 15000000, cost: 1, bonusText: 'O b√¥nus de dano por ficar parado √© acumulado 50% mais r√°pido.', bonus: { type: 'still_bonus_speed', value: 1.5 } },
                ]
            }
        ];

        // --- START OF game/profileContent.ts ---
        const PROFILE_AVATARS = [
          { id: 'avatar_default', name: 'Processo Padr√£o', unlockCondition: { type: 'default' }, description: 'Dispon√≠vel por padr√£o.' },
          { id: 'avatar_trojan', name: 'Fragmento de Trojan', unlockCondition: { type: 'stat_tracker', stat: 'totalEnemyKills', subType: 'trojan_horse', value: 25 }, description: 'Derrote 25 Trojans.' },
          { id: 'avatar_guardian', name: 'Olhar do Guardi√£o', unlockCondition: { type: 'achievement', id: 'defeat_boss_1' }, description: 'Derrote o Guardi√£o do N√∫cleo.' },
          { id: 'avatar_nightmare', name: '√çcone do Pesadelo', unlockCondition: { type: 'achievement', id: 'nightmare_win' }, description: 'Ven√ßa o jogo no Modo Pesadelo.' }
        ];

        const PROFILE_TITLES = [
          { id: 'title_survivor', name: 'Sobrevivente', unlockCondition: { type: 'default' }, description: 'Dispon√≠vel por padr√£o.' },
          { id: 'title_bug_squasher', name: 'Exterminador de Bugs', unlockCondition: { type: 'stat_tracker', stat: 'totalKills', value: 10000 }, description: 'Derrote 10.000 inimigos.' },
          { id: 'title_legend', name: 'Lenda do Sistema', unlockCondition: { type: 'achievement', id: 'survive_20_min' }, description: 'Sobreviva por 20 minutos.' },
          { id: 'title_architect', name: 'Arquiteto', unlockCondition: { type: 'achievement', id: 'unlock_all_classes' }, description: 'Desbloqueie todas as classes.' }
        ];

        const PROFILE_BANNERS = [
          { id: 'banner_grid', name: 'Grid Padr√£o', unlockCondition: { type: 'default' }, description: 'Dispon√≠vel por padr√£o.' },
          { id: 'banner_circuit', name: 'Placa de Circuito', unlockCondition: { type: 'achievement', id: 'evolve_3_weapons_session' }, description: 'Evolua 3 armas em uma partida.' },
          { id: 'banner_corruption', name: 'Corrup√ß√£o Vermelha', unlockCondition: { type: 'achievement', id: 'defeat_boss_3' }, description: 'Derrote o √Årbitro do Sistema.' }
        ];
        // --- END OF game/profileContent.ts ---


        const GAME_COLORS = {
            BACKGROUND_DARK: '#010409',
            BACKGROUND_MEDIUM: '#0d1117',
            BACKGROUND_STAGE_2: '#0A192F', 
            GRID_STAGE_2: 'rgba(45, 212, 191, 0.1)', 
            BACKGROUND_STAGE_3: '#081426',
            BACKGROUND_STAGE_4_ABYSS: '#04010a', // --- ALTERADO ---
            CIRCUIT_STAGE_4: 'rgba(80, 80, 150, 0.1)', // --- NOVO ---
            DATA_FLOW_CYAN: 'rgba(0, 255, 255, 0.7)', // --- NOVO ---
            DATA_FLOW_MAGENTA: 'rgba(255, 0, 255, 0.7)', // --- NOVO ---
            GRID_STAGE_4: 'rgba(0, 255, 255, 0.1)', // --- NOVO ---
            UNSTABLE_SECTOR_WARNING: 'rgba(255, 100, 0, 0.4)',
            UNSTABLE_SECTOR_DANGER: 'rgba(255, 0, 0, 0.7)',
            BORDER: '#30363d',
            TEXT: '#c9d1d9',
            PLAYER: '#2f81f7',
            ENEMY_DEFAULT: '#f85149',
            ENEMY_MEMORY_LEAK: '#ff9f43',
            ENEMY_SPYWARE: '#8e44ad',
            ENEMY_TROJAN: '#34495e',
            ENEMY_ROOTKIT: '#b71c1c',
            ENEMY_DDOS_BOT: '#00e5ff',
            ENEMY_GLITCH_MINION: 'rgba(220, 20, 60, 0.8)',
            MEMORY_LEAK_TRAIL: 'rgba(255, 159, 67, 0.4)',
            ENEMY_PROCESSO_CORROMPIDO: '#67e8f9',
            ENEMY_PONTEIRO_NULO: '#f472b6',
            ENEMY_SEGMENTO_FALHA: '#fbbf24',
            ENEMY_PROCESSO_ZUMBI: '#a3e635',
            ENEMY_NANITE: '#E5E7EB',
            ENEMY_HEATSINK: '#F97316',
            ENEMY_IO_CONTROLLER: '#A78BFA',
            ENEMY_VOLATILE_PROCESS: '#FACC15',
            // --- FASE 4 CORES (NOVO) ---
            ENEMY_RECURSIVE_PROCESS: '#fb923c',
            ENEMY_CHILD_PROCESS: '#fdba74',
            ENEMY_ROGUE_FIREWALL: '#eab308',
            ENEMY_LATENCY_SPIKE: '#60a5fa',
            ENEMY_PROTOCOL_ANOMALY: '#f472b6',
            SHIELD_EFFECT: 'rgba(191, 219, 254, 0.6)',
            TELEPORT_CHARGE_EFFECT: 'rgba(244, 114, 182, 0.4)',
            PROJECTILE: '#3fb950',
            PROJECTILE_SYSTEM_PURGE: '#76ff03',
            PROJECTILE_HUNTER_SWARM: '#fbc02d',
            PROJECTILE_SHARD: '#82eefd',
            PROJECTILE_CHAIN_LIGHTNING: '#FFFF00', 
            PROJECTILE_DATA_STREAM: '#FF6347', 
            PROJECTILE_ACID_VIRUS: '#a3e635', 
            PROJECTILE_ACID_SPORE: '#c084fc', 
            ACID_PUDDLE: 'rgba(100, 140, 80, 0.25)',
            FIREWALL_ORB: '#a371f7',
            FIREWALL_AEGIS_ORB: '#da70d6',
            FIREWALL_AEGIS_PULSE: 'rgba(218, 112, 214, 0.4)',
            XP_ORB: '#76ff03',
            HEALTH_PICKUP: '#FF6B81', 
            KNOWLEDGE_ORB: '#ffd700',
            DATA_VAULT: '#161b22',
            DATA_VAULT_CIRCUIT: '#ffd700',
            PARTICLE_EXPLOSION: '#ffeb3b',
            CRITICAL_HIT_TEXT: '#ffc107',
            UI_PANEL_BG: 'rgba(13, 17, 23, 0.9)',
            UI_PANEL_BG_SOLID: '#0a0d12',
            PROGRESS_BAR_BG: '#30363d',
            HEALTH_BAR_LOW: '#f85149',
            UPGRADE_CARD_BG: '#0d1117',
            UPGRADE_CARD_HOVER_BORDER: '#2f81f7',
            UPGRADE_CARD_EVOLUTION_BORDER: '#ffd700',
            TEXT_GREEN: '#28a745',
            TEXT_YELLOW: '#ffc107',
            TEXT_RED: '#dc3545',
            TEXT_XP: '#76ff03',
            TEXT_SYSTEM_CORE: '#FFD700',
            TEXT_CORRUPTED_CORE: '#d946ef',
            PLAYER_OVERDRIVE_GLOW: 'rgba(255, 255, 0, 0.7)',
            BOSS_CORE: '#6a0dad',
            BOSS_SHIELD_NODE: '#00BFFF',
            BOSS_PROJECTILE_PHASE1: '#9370DB',
            BOSS_PROJECTILE_PHASE2: '#FF4500',
            BOSS_PULSE_ATTACK: 'rgba(200, 0, 200, 0.3)', 
            BOSS_2_CORE: '#facc15',
            BOSS_2_SUB_ROUTINE: '#ec4899',
            BOSS_2_LASER: 'rgba(250, 80, 80, 0.8)',
            BOSS_2_DATA_WALL: 'rgba(100, 30, 200, 0.6)',
            BOSS_2_ENERGY_WAVE: 'rgba(250, 204, 21, 0.3)',
            BOSS_3_CORE: '#B91C1C',
            BOSS_3_RAM_SOCKET_CORRUPTED: 'rgba(220, 38, 38, 0.8)',
            BOSS_3_RAM_SOCKET_CLEANSE: 'rgba(34, 197, 94, 0.6)',
            BOSS_3_BUS_WARNING: 'rgba(250, 204, 21, 0.5)',
            BOSS_3_BUS_FIRE: 'rgba(239, 68, 68, 0.8)',
            BOSS_3_AURA: 'rgba(147, 51, 234, 0.15)',
            BOSS_3_STATIC_ZONE: 'rgba(107, 33, 168, 0.25)',
            BOSS_3_LOGIC_BOMB: '#fbbf24',
            BOSS_4_CORE: '#ec4899', // --- NOVO ---
            BOSS_4_SUB_ROUTER: '#fde047', // --- NOVO ---
            BOSS_4_DOS_WAVE: 'rgba(236, 72, 153, 0.3)', // --- NOVO ---
            BOSS_4_PORT_SCAN: 'rgba(250, 80, 80, 0.9)', // --- NOVO ---
            CORRUPTED_ZONE: 'rgba(139, 0, 0, 0.5)', 
            KERNEL_PANIC_PULSE_WARNING: 'rgba(255, 0, 0, 0.3)', 
            ENEMY_DOT_EFFECT: 'rgba(124, 252, 0, 0.6)',
            EVASION_PARTICLE: 'rgba(200, 200, 255, 0.8)',
            STATUS_SLOW_TINT: 'rgba(100, 149, 237, 0.3)', 
            STATUS_FREEZE_TINT: 'rgba(173, 216, 230, 0.6)', 
            STATUS_VULNERABILITY_AURA: 'rgba(148, 0, 211, 0.4)', 
            STATUS_FEAR_AURA: 'rgba(255, 127, 80, 0.4)', 
            DATA_CACHE: '#2f81f7',
            CORRUPTED_LIBRARY: 'rgba(220, 20, 60, 0.6)',
            DASH_COOLDOWN_FILL: '#f3f4f6',
            DASH_COOLDOWN_BG: '#4b5563',
            EFFECT_DEFRAG: 'rgba(200, 220, 255, 0.8)',
            EFFECT_DATA_LEECH: '#be29ec',
            ALLIED_MINION: '#00e5ff',
            ACHIEVEMENT_UNLOCKED_BG: '#1a2a44',
            ACHIEVEMENT_LOCKED_BG: '#161b22',
            ACHIEVEMENT_DIFFICULTY_EASY: '#1f7133',
            ACHIEVEMENT_DIFFICULTY_MEDIUM: '#866c1d',
            ACHIEVEMENT_DIFFICULTY_HARD: '#b32c2c',
            ACHIEVEMENT_DIFFICULTY_EPIC: '#6e40c9',
        };

        const STATUS_EFFECT_PARAMS = {
            [StatusEffectType.SLOW]: { baseDuration: 3000, baseMagnitude: 0.6 }, 
            [StatusEffectType.FREEZE]: { baseDuration: 1500 },
            [StatusEffectType.VULNERABILITY]: { baseDuration: 5000, baseMagnitude: 1.2 }, 
            [StatusEffectType.FEAR]: { baseDuration: 2500 },
            CHAIN_LIGHTNING: { baseMaxChains: 2, baseRange: 150, baseDamageMultiplier: 0.70 }
        };

        const DASH_STATS = {
            COOLDOWN: 4000,
            DURATION: 150,
            SPEED_MULTIPLIER: 4.5,
        };

        const INTERACTABLE_STATS = {
            SPAWN_INTERVAL_MIN: 15000,
            SPAWN_INTERVAL_MAX: 25000,
            [InteractableType.DATA_CACHE]: {
                SIZE: 24,
                DURATION: 15000, 
                BUFFS: [
                    { type: TemporaryBuffType.MOVE_SPEED, magnitude: 1.3, duration: 10000, icon: 'üèÉ' },
                    { type: TemporaryBuffType.ATTACK_SPEED, magnitude: 0.75, duration: 10000, icon: '‚ö°' },
                    { type: TemporaryBuffType.DAMAGE_AMP, magnitude: 1.25, duration: 8000, icon: 'üí•' },
                    { type: TemporaryBuffType.REGEN, magnitude: 2, duration: 12000, icon: 'üíâ' }
                ]
            },
            [InteractableType.CORRUPTED_LIBRARY]: {
                RADIUS: 100,
                DURATION: 30000,
                CLEANSE_TIME: 3000,
                DECAY_RATE: 0.5,
                DEBUFF_MAGNITUDE: 1.2,
                REWARD_XP_COUNT: 5,
                REWARD_XP_VALUE: 100,
            }
        };

        const PLAYER_INITIAL_STATS = {
            size: 40,
            baseSpeed: 240,
            baseMaxHealth: 100,
            baseXpMagnetRadius: 50,
            baseExpModifier: 1,
            baseCooldownModifier: 1,
            globalDamageFactor: 1,
            baseRegenAmount: 0,
            baseDamageReduction: 0,
            baseCritChance: 0.0, 
            baseCritDamage: 1.5,
            lastRegenTime: 0,
            overdriveActive: false,
            overdriveEndTime: 0,
            overdriveCooldownUntil: 0,
            overdriveDamageBonus: 0,
            lastMoveDirection: { x: 0, y: -1 },
            statusEffectDuration: 1.0, 
            regenAmount: 0, 
        };

        // --- START OF game/classes.ts ---
        const CLASS_DEFINITIONS = [
            {
                id: "class_executor",
                name: "Executor",
                description: "Uma classe de combate vers√°til e equilibrada, perfeita para novos jogadores e veteranos que preferem um estilo de jogo adapt√°vel.",
                iconColor: "#2f81f7",
                statModifiers: {},
                startingWeaponId: "antivirus",
                uniquePassive: {
                    id: "passive_executor_first_strike",
                    name: "Primeiro Contato",
                    description: "O primeiro ataque contra um inimigo com vida cheia causa +25% de dano.",
                },
                unlockCost: 0,
            },
            {
                id: "class_sentinel",
                name: "Sentinela",
                description: "Uma fortaleza ambulante. Focado em m√°xima sobreviv√™ncia, controle de √°rea e resist√™ncia a dano, ideal para jogadores que gostam de jogar na defensiva.",
                iconColor: "#f85149",
                statModifiers: {
                    baseMaxHealth: 25,
                    baseSpeed: -(PLAYER_INITIAL_STATS.baseSpeed * 0.10),
                },
                startingWeaponId: "firewall",
                uniquePassive: {
                    id: "passive_sentinel_retaliation",
                    name: "Protocolo de Retalia√ß√£o",
                    description: "Ao receber dano, ganha um b√¥nus de 15% de Redu√ß√£o de Dano por 3 segundos. N√£o pode ser reativado enquanto estiver ativo.",
                },
                unlockCost: 3,
            },
            {
                id: "class_assassin",
                name: "Assassino",
                description: "√Ågil e mortal. Especializa-se em movimentos r√°pidos e na elimina√ß√£o sequencial de inimigos, criando um fluxo de combate de alto risco e alta recompensa.",
                iconColor: "#76ff03",
                 statModifiers: {
                    baseSpeed: PLAYER_INITIAL_STATS.baseSpeed * 0.15,
                    baseMaxHealth: -15,
                },
                startingWeaponId: "defrag",
                uniquePassive: {
                    id: "passive_assassin_execution_flow",
                    name: "Fluxo da Execu√ß√£o",
                    description: "Ao derrotar um inimigo, voc√™ ganha +20% de velocidade de movimento e +15% de velocidade de ataque por 2 segundos. O efeito reinicia a cada abate.",
                },
                unlockCost: 3,
            },
            {
                id: "class_corruptor",
                name: "Corruptor",
                description: "Um especialista em decompor amea√ßas para extrair o m√°ximo de dados (experi√™ncia) de seus restos, acelerando sua pr√≥pria evolu√ß√£o.",
                iconColor: "#a3e635",
                 statModifiers: {
                    baseExpModifier: 0.15,
                },
                startingWeaponId: "acid_virus",
                uniquePassive: {
                    id: "passive_corruptor_data_extraction",
                    name: "Extra√ß√£o de Dados",
                    description: "Inimigos que s√£o derrotados enquanto est√£o dentro de uma Po√ßa de √Åcido concedem 10% a mais de Experi√™ncia.",
                },
                unlockCost: 5,
            },
            {
                id: "class_reaper",
                name: "Ceifador",
                description: "Um combatente de m√©dio alcance que se sustenta na ofensiva, drenando a energia vital dos processos inimigos para se manter na luta.",
                iconColor: "#be29ec",
                statModifiers: {
                    baseXpMagnetRadius: PLAYER_INITIAL_STATS.baseXpMagnetRadius * 0.75,
                },
                startingWeaponId: "data_leech",
                uniquePassive: {
                    id: "passive_reaper_process_siphon",
                    name: "Sif√£o de Processos",
                    description: "Inimigos derrotados pelo Data Leech (ou enquanto afetados por ele) t√™m 15% de chance de dropar um orbe de vida fragmentado que cura 5 HP.",
                },
                unlockCost: 5,
            },
            {
                id: "class_technomancer",
                name: "Tecnomante",
                description: "Um mestre de comando que lidera um enxame de processos convertidos, mantendo sua agilidade para reposicionamento t√°tico.",
                iconColor: "#00e5ff",
                statModifiers: {
                    baseMaxHealth: 10,
                },
                startingWeaponId: "antivirus",
                uniquePassive: {
                    id: "passive_technomancer_swarm", 
                    name: "Enxame de Processos",
                    description: "Converte inimigos em minions de assalto (30% de chance, m√°x 4). Mant√©m a habilidade de Dash padr√£o.",
                },
                unlockCost: 5,
            }
        ];
        // --- END OF game/classes.ts ---
        
        // --- START OF game/skins.ts ---
        
        let skinStateCache = {}; 
        
        function drawGlitchwareFragments(ctx, x, y, size, now) { const fragmentCount = 5; for (let i = 0; i < fragmentCount; i++) { const angle = (now / 600) + (i * (Math.PI * 2 / fragmentCount)); const orbitRadius = size / 1.8 + Math.sin(now / 300 + i * 5) * (size * 0.1); const fragX = x + Math.cos(angle) * orbitRadius + (Math.random() - 0.5) * 3; const fragY = y + Math.sin(angle) * orbitRadius + (Math.random() - 0.5) * 3; const fragSize = size / 4; if (i % 2 === 0) { ctx.fillRect(fragX - fragSize / 2, fragY - fragSize / 2, fragSize, fragSize); } else { ctx.beginPath(); ctx.moveTo(fragX, fragY - fragSize / 2); ctx.lineTo(fragX - fragSize / 2, fragY + fragSize / 2); ctx.lineTo(fragX + fragSize / 2, fragY + fragSize / 2); ctx.closePath(); ctx.fill(); } } }
        function drawHexagon(ctx, x, y, radius) { ctx.beginPath(); for (let i = 0; i < 6; i++) { ctx.lineTo(x + radius * Math.cos((Math.PI / 3) * i), y + radius * Math.sin((Math.PI / 3) * i)); } ctx.closePath(); }
        function drawGear(ctx, x, y, radius, teeth) { const s = radius * 0.2; ctx.beginPath(); for (let i = 0; i < teeth; i++) { const a = (Math.PI * 2 / teeth) * i; const a1 = a - (Math.PI / teeth) * 0.4; const a2 = a + (Math.PI / teeth) * 0.4; ctx.arc(x, y, radius - s, a1, a2, false); ctx.arc(x, y, radius, a2, a1, true); } ctx.closePath(); }
        function drawHextechCircuits(ctx, x, y, radius) { ctx.beginPath(); for (let i = 0; i < 6; i++) { const a = (Math.PI / 3) * i; ctx.moveTo(x + radius * 0.5 * Math.cos(a), y + radius * 0.5 * Math.sin(a)); ctx.lineTo(x + radius * Math.cos(a), y + radius * Math.sin(a)); const n = (Math.PI / 3) * (i + 2); ctx.lineTo(x + radius * Math.cos(n), y + radius * Math.sin(n)); } }

                        const SKIN_DEFINITIONS = [
            {
                id: 'skin_default',
                name: 'Padr√£o',
                rarity: 'Comum',
                unlockCondition: { type: 'default' },
                unlockHint: 'Dispon√≠vel por padr√£o.',
                draw: (ctx, player, options) => { 
                    ctx.save(); 
                    ctx.fillStyle = player.color || '#2f81f7'; 
                    ctx.shadowColor = player.color || '#2f81f7'; 
                    ctx.shadowBlur = 15; 
                    ctx.beginPath(); 
                    ctx.arc(player.position.x, player.position.y, player.size / 2, 0, Math.PI * 2); 
                    ctx.fill(); 
                    ctx.restore(); 
                }
            },
            {
                id: 'skin_symbiotic_cell',
                name: 'C√©lula Simbi√≥tica',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 2 },
                unlockHint: 'Custo: 2 N√∫cleos de Sistema.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y);
                    const pulse = Math.sin(time / 500) * 5; const outerRadius = size / 2 - 5 + pulse;
                    ctx.globalAlpha = 0.5;
                    const membraneGrad = ctx.createRadialGradient(0, 0, outerRadius * 0.7, 0, 0, outerRadius);
                    membraneGrad.addColorStop(0, 'rgba(74, 222, 128, 0.1)');
                    membraneGrad.addColorStop(1, 'rgba(16, 185, 129, 0.8)');
                    ctx.fillStyle = membraneGrad; ctx.beginPath(); ctx.arc(0, 0, outerRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                    const corePulse = Math.sin(time / 480) * 3; const coreRadius = size / 5 + corePulse;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGrad.addColorStop(0, '#A7F3D0'); coreGrad.addColorStop(1, '#10B981');
                    ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2); ctx.fill();
                    const particleCount = 10;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (time / 1000) + (i * (Math.PI * 2 / particleCount));
                        const dist = (size / 4) * (Math.sin(time / 700 + i) * 0.5 + 0.5);
                        const px = Math.cos(angle) * dist; const py = Math.sin(angle) * dist;
                        ctx.fillStyle = 'rgba(209, 250, 229, 0.8)'; ctx.fillRect(px - 1, py - 1, 2, 2);
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_energy_core',
                name: 'N√∫cleo de Energia',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 2 },
                unlockHint: 'Custo: 2 N√∫cleos de Sistema.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y);
                    const coreRadius = size / 4 + Math.sin(time / 400) * 3;
                    const auraGrad = ctx.createRadialGradient(0, 0, coreRadius, 0, 0, coreRadius * 2);
                    auraGrad.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
                    auraGrad.addColorStop(1, 'rgba(59, 130, 246, 0)');
                    ctx.fillStyle = auraGrad; ctx.beginPath(); ctx.arc(0, 0, coreRadius * 2, 0, Math.PI * 2); ctx.fill();
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGrad.addColorStop(0, '#FFFFFF');
                    coreGrad.addColorStop(0.8, '#93C5FD');
                    coreGrad.addColorStop(1, '#3B82F6');
                    ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                    ctx.shadowColor = '#60A5FA'; ctx.shadowBlur = 15; ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.restore();
                }
            },
            {
                id: 'skin_logic_gate',
                name: 'Porta L√≥gica',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 3 },
                unlockHint: 'Custo: 3 N√∫cleos de Sistema.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.translate(x, y); ctx.strokeStyle = '#999'; ctx.lineWidth = 4; ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.arc(0, 0, size / 3, -Math.PI / 2, Math.PI / 2);
                    ctx.lineTo(-size / 3, size / 3); ctx.lineTo(-size / 3, -size / 3); ctx.closePath(); ctx.fill(); ctx.stroke();
                    const input1 = Math.floor(now / 1000) % 2; const input2 = Math.floor(now / 700) % 2; const output = input1 && input2;
                    ctx.fillStyle = input1 ? 'lime' : 'red'; ctx.beginPath(); ctx.arc(-size / 3, -size / 6, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = input2 ? 'lime' : 'red'; ctx.beginPath(); ctx.arc(-size / 3, size / 6, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = output ? 'lime' : 'red'; ctx.beginPath(); ctx.arc(size / 2.5, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                }
            },
            {
                id: 'skin_bsod',
                name: 'Tela Azul (BSOD)',
                rarity: 'Comum',
                unlockCondition: { type: 'cost', value: 2 },
                unlockHint: 'Custo: 2 N√∫cleos de Sistema.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.fillStyle = '#0000AA'; ctx.fillRect(x - size / 2, y - size / 2, size, size);
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 2;
                    for (let i = 0; i < size; i += 4) { if (Math.random() > 0.9) { ctx.beginPath(); ctx.moveTo(x - size / 2, y - size / 2 + i); ctx.lineTo(x + size / 2, y - size / 2 + i); ctx.stroke(); }}
                    ctx.fillStyle = 'white'; ctx.font = `bold ${size * 0.15}px "Courier New", monospace`; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                    if (Math.floor(now / 500) % 2) { ctx.fillText("KERNEL_PANIC", x - size * 0.45, y); } else { ctx.fillText("0xDEADBEEF", x - size * 0.45, y); }
                    ctx.restore();
                }
            },
            // --- RARA ---
            {
                id: 'skin_qr_code',
                name: 'C√≥digo de Acesso (QR)',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'score', value: 10000 },
                unlockHint: 'Acumule 10.000 pontos em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    if (!skinStateCache.qrcode || Math.floor(now / 200) !== skinStateCache.qrcode.lastUpdate) {
                        skinStateCache.qrcode = { grid: [], lastUpdate: Math.floor(now / 200) };
                        for (let i = 0; i < 10; i++) { skinStateCache.qrcode.grid[i] = []; for (let j = 0; j < 10; j++) { skinStateCache.qrcode.grid[i][j] = Math.random() > 0.5; }}
                    }
                    ctx.translate(x, y); const pSize = size / 10;
                    for (let i = 0; i < 10; i++) { for (let j = 0; j < 10; j++) { ctx.fillStyle = skinStateCache.qrcode.grid[i][j] ? 'black' : 'white'; ctx.fillRect(-size / 2 + i * pSize, -size / 2 + j * pSize, pSize, pSize); }}
                    ctx.restore();
                }
            },
            {
                id: 'skin_quantum_cpu',
                name: 'CPU Qu√¢ntica',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'level', value: 25 },
                unlockHint: 'Alcance o N√≠vel 25 em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.translate(x, y); ctx.rotate(now / 5000); ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-size / 2, -size / 2, size, size);
                    const grad = ctx.createLinearGradient(-size / 2, -size / 2, size / 2, size / 2);
                    grad.addColorStop(0, '#333'); grad.addColorStop(0.5, '#555'); grad.addColorStop(1, '#333');
                    ctx.fillStyle = grad; ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
                    ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2; ctx.shadowColor = '#00ffcc'; ctx.shadowBlur = 15;
                    const pulse = Math.sin(now / 200) * 5;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath(); const angle = i * Math.PI / 2; ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * (size / 2 + pulse), Math.sin(angle) * (size / 2 + pulse)); ctx.stroke();
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_graphic_equalizer',
                name: 'Equalizador Gr√°fico',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'evolvedWeaponsIncludes', value: 'evolution_firewall_aegis_shield' },
                unlockHint: 'Evolua o Firewall para "Aegis Shield" em uma partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; const bars = 8; const barWidth = size / bars;
                    ctx.save(); ctx.translate(x - size/2, y - size/2);
                    for(let i=0; i<bars; i++) {
                        const height = (Math.sin(i * 0.8 + time/200) + 1)/2 * size; const hue = 120 - (height/size) * 120;
                        ctx.fillStyle = `hsl(${hue}, 100%, 15%)`; ctx.fillRect(i*barWidth, 0, barWidth-2, size);
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.fillRect(i*barWidth, size, barWidth-2, -height);
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_singularity_core',
                name: 'N√∫cleo Singular',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'timeSurvived', value: 900 },
                unlockHint: 'Sobreviva por 15 minutos em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y);
                    ctx.globalCompositeOperation = 'lighter';
                    const drawWave = (radius, color, speed, frequency, amplitude) => {
                        ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.6; ctx.rotate(time * speed); ctx.beginPath();
                        for (let i = 0; i <= 360; i++) { const angle = i * Math.PI / 180; const r = radius + Math.sin(angle * frequency + time * 0.001) * amplitude; const px = Math.cos(angle) * r; const py = Math.sin(angle) * r; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); }
                        ctx.closePath(); ctx.stroke(); ctx.restore();
                    };
                    drawWave(size * 0.30, '#0ea5e9', 0.0001, 5, size * 0.05); drawWave(size * 0.35, '#06b6d4', -0.00015, 7, size * 0.04); drawWave(size * 0.40, '#22d3ee', 0.00008, 6, size * 0.06);
                    ctx.globalCompositeOperation = 'source-over';
                    const coreRadius = size * 0.2; ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'rgba(207, 250, 254, 0.8)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }
            },
            {
                id: 'skin_origami',
                name: 'Origami',
                rarity: 'Rara',
                unlockCondition: { type: 'session_stat', stat: 'damageTakenInFirst5Minutes', value: 0 },
                unlockHint: 'Complete os primeiros 5 minutos sem sofrer dano.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const n = options.time; const x = player.position.x; const y = player.position.y; const s = player.size;
                    ctx.lineJoin = 'round'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 1.5;
                    const p = 0.5 + Math.sin(n / 1000) * 0.5; const pts = [{ x: 0, y: -s / 2 }, { x: s / 2, y: 0 }, { x: 0, y: s / 2 }, { x: -s / 2, y: 0 }];
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath(); const p1 = pts[i]; const p2 = pts[(i + 1) % 4];
                        const mX = (p1.x + p2.x) * 0.5 * p; const mY = (p1.y + p2.y) * 0.5 * p;
                        ctx.moveTo(x, y); ctx.lineTo(x + p1.x, y + p1.y); ctx.lineTo(x + mX, y + mY); ctx.lineTo(x + p2.x, y + p2.y); ctx.closePath();
                        const l = 0.7 + Math.sin(i * Math.PI / 2 + n / 500) * 0.2;
                        ctx.fillStyle = `rgba(240, 240, 255, ${l})`; ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; ctx.shadowBlur = 10;
                        ctx.fill(); ctx.shadowColor = 'transparent'; ctx.stroke();
                    }
                    ctx.restore();
                }
            },
            // --- √âPICA ---
            {
                id: 'skin_unstable_blackhole',
                name: 'Buraco Negro Inst√°vel',
                rarity: '√âpica',
                unlockCondition: { type: 'session_stat', stat: 'level', value: 40 },
                unlockHint: 'Alcance o N√≠vel 40 em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; ctx.save(); ctx.translate(x, y);
                    const coreRadius = size * 0.2;
                    for (let i = 0; i < 5; i++) {
                        ctx.strokeStyle = `rgba(139, 92, 246, ${Math.random() * 0.3})`; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath(); const startAngle = Math.random() * Math.PI * 2; const endAngle = startAngle + Math.PI * Math.random() * 0.5; const r = coreRadius + Math.random() * 15 + 10;
                        ctx.arc(0, 0, r, startAngle, endAngle); ctx.stroke();
                    }
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0, 0, coreRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.save(); ctx.rotate(time / 8000);
                    const grad = ctx.createConicGradient(0, 0, 0);
                    grad.addColorStop(0, '#f97316'); grad.addColorStop(0.25, '#ec4899'); grad.addColorStop(0.5, '#8b5cf6'); grad.addColorStop(0.75, '#facc15'); grad.addColorStop(1, '#f97316');
                    ctx.strokeStyle = grad; ctx.lineWidth = size * 0.15 + Math.sin(time / 400) * 8; ctx.globalAlpha = 0.8 + Math.sin(time/500) * 0.2; ctx.beginPath(); ctx.arc(0, 0, size * 0.4, 0, 2 * Math.PI); ctx.stroke(); ctx.restore();
                    if (Math.random() > 0.985) {
                        ctx.save(); const angle = Math.random() * Math.PI * 2; ctx.rotate(angle); const plasmaGrad = ctx.createLinearGradient(0, -coreRadius, 0, -size);
                        plasmaGrad.addColorStop(0, 'rgba(236, 72, 153, 0.8)'); plasmaGrad.addColorStop(1, 'rgba(236, 72, 153, 0)');
                        ctx.fillStyle = plasmaGrad; ctx.beginPath(); ctx.moveTo(0, -coreRadius); ctx.lineTo(-10, -size/2); ctx.lineTo(10, -size/2); ctx.closePath(); ctx.fill(); ctx.restore();
                    }
                    if (!player.particles) { player.particles = Array(100).fill({}).map(() => ({ angle: Math.random() * Math.PI * 2, radius: size/2 * (Math.random() * 0.6 + 0.4), speed: Math.random() * 2 + 1, size: Math.random() * 2 + 1, color: `hsl(${Math.random()*60 + 240}, 100%, 70%)` })); }
                    ctx.globalCompositeOperation = 'lighter';
                    player.particles.forEach(p => {
                        p.radius -= p.speed * 0.05; const px = Math.cos(p.angle) * p.radius; const py = Math.sin(p.angle) * p.radius; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(px, py, p.size, 0, 2 * Math.PI); ctx.fill(); p.angle += p.speed * 0.01;
                        if (p.radius < coreRadius) { p.radius = size/2 * (Math.random() * 0.2 + 0.9); p.angle = Math.random() * Math.PI * 2; }
                    });
                    ctx.restore();
                }
            },
            {
                id: 'skin_temporal_gear',
                name: 'Engrenagem Temporal',
                rarity: '√âpica',
                unlockCondition: { type: 'global_stat', stat: 'totalKills', value: 25000 },
                unlockHint: 'Derrote 25.000 inimigos no total.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; ctx.save(); ctx.translate(x, y);
                    ctx.fillStyle = '#1E293B'; ctx.beginPath(); ctx.arc(0, 0, size/2, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FBBF24'; ctx.lineWidth = 3; ctx.stroke();
                    const numerals = ['XII', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI'];
                    ctx.font = `${size * 0.08}px 'Press Start 2P'`; ctx.fillStyle = '#FBBF24'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    for(let i = 0; i < 12; i++){ const angle = i * Math.PI / 6; ctx.save(); ctx.rotate(angle); ctx.translate(0, -size * 0.4); ctx.rotate(-angle); ctx.fillText(numerals[i], 0, 0); ctx.restore(); }
                    const drawGear = (radius, teeth, speed, color1, color2) => {
                        const step = Math.PI * 2 / teeth; ctx.save(); ctx.rotate(time * speed);
                        ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 8; ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4;
                        const grad = ctx.createRadialGradient(0, 0, radius*0.5, 0, 0, radius);
                        grad.addColorStop(0, color1); grad.addColorStop(1, color2);
                        ctx.fillStyle = grad; ctx.beginPath();
                        for(let i=0; i<teeth * 2; i++) { const angle = i * step/2; const r = radius * (i % 2 === 0 ? 1 : 0.8); ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r); }
                        ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, radius * 0.2, 0, Math.PI * 2);
                        const holeGrad = ctx.createRadialGradient(0, 0, radius*0.1, 0, 0, radius*0.2);
                        holeGrad.addColorStop(0,'#111'); holeGrad.addColorStop(1,'#444');
                        ctx.fillStyle = holeGrad; ctx.fill(); ctx.restore();
                    };
                    drawGear(size * 0.35, 12, 0.0003, '#D1D5DB', '#6B7280'); drawGear(size * 0.2, 8, -0.0009, '#FCA5A5', '#991B1B');
                    const drawHand = (angle, length, width, color) => { ctx.save(); ctx.rotate(angle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -length); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke(); ctx.restore(); }
                    drawHand( (time / 1000) * Math.PI / 30, size * 0.4, 2, '#FBBF24'); drawHand( (time / 60000) * Math.PI / 30, size * 0.3, 4, '#FBBF24');
                    if(Math.random() > 0.9) { ctx.fillStyle = '#FDE047'; ctx.fillRect(Math.random()*size - size/2, Math.random()*size - size/2, 2, 2); }
                    ctx.restore();
                }
            },
            {
                id: 'skin_pym_particle',
                name: 'Part√≠cula Pym',
                rarity: '√âpica',
                unlockCondition: { type: 'session_stat', stat: 'killsWhileBuffed', value: 500 },
                unlockHint: 'Derrote 500 inimigos sob o efeito de um "Data Cache".',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const n = options.time; const x = player.position.x; const y = player.position.y;
                    const cD = 2000; const c = (n % cD) / cD;
                    const eC = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                    const e = eC(c); const mS = player.size * 0.8; const M_S = player.size * 1.2; const cS = mS + (M_S - mS) * e;
                    const r = [{ color: 'rgba(255, 0, 0, 0.7)', offset: 0.0, width: 0.1 }, { color: 'rgba(192, 192, 192, 0.8)', offset: 0.2, width: 0.2 }, { color: 'rgba(20, 20, 20, 1)', offset: 0.5, width: 0.3 }, { color: 'rgba(255, 0, 0, 0.9)', offset: 0.9, width: 0.1 }];
                    r.forEach(ring => {
                        const radius = cS / 2 * (1 - ring.offset); const lW = cS / 2 * ring.width;
                        ctx.beginPath(); ctx.strokeStyle = ring.color; ctx.lineWidth = lW;
                        ctx.shadowColor = ring.color === 'rgba(20, 20, 20, 1)' ? 'transparent' : ring.color; ctx.shadowBlur = 15;
                        ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.stroke();
                    });
                    ctx.shadowColor = 'transparent'; const pC = 20;
                    for (let i = 0; i < pC; i++) {
                        const pL = (n / 10 + i * 50) % 100 / 100; const a = (n / 1500) + (i * (Math.PI * 2 / pC));
                        const oR = cS * (0.5 + e * 0.3); const px = x + Math.cos(a) * oR; const py = y + Math.sin(a) * oR;
                        ctx.beginPath(); ctx.fillStyle = e < 0.5 ? 'rgba(0, 191, 255, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                        ctx.globalAlpha = 1 - pL; ctx.arc(px, py, (1 - pL) * 3, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_stark_protocol',
                name: 'Reator Arc',
                rarity: '√âpica',
                unlockCondition: { type: 'session_stat', stat: 'dataCachesCollected', value: 15 },
                unlockHint: 'Colete 15 "Data Caches" em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const { x, y } = player.position; const radius = player.size / 2; const time = options.time;
                    const redGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    redGrad.addColorStop(0, '#E00000'); redGrad.addColorStop(0.7, '#A00000'); redGrad.addColorStop(1, '#600000');
                    ctx.fillStyle = redGrad; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 30; ctx.shadowOffsetY = 15;
                    ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                    const innerGlowGrad = ctx.createRadialGradient(x, y, radius * 0.7, x, y, radius);
                    innerGlowGrad.addColorStop(0, 'rgba(255, 255, 255, 0)'); innerGlowGrad.addColorStop(1, 'rgba(255, 255, 255, 0.4)');
                    ctx.fillStyle = innerGlowGrad; ctx.fill(); ctx.strokeStyle = '#400000'; ctx.lineWidth = 6; ctx.stroke();
                    const shapeWidth = player.size * 0.65; const shapeHeight = player.size * 0.65;
                    ctx.beginPath(); ctx.moveTo(x - shapeWidth * 0.3, y - shapeHeight * 0.5);
                    ctx.lineTo(x + shapeWidth * 0.3, y - shapeHeight * 0.5); ctx.lineTo(x + shapeWidth * 0.5, y - shapeHeight * 0.2);
                    ctx.lineTo(x + shapeWidth * 0.5, y + shapeHeight * 0.2); ctx.lineTo(x + shapeWidth * 0.3, y + shapeHeight * 0.5);
                    ctx.lineTo(x - shapeWidth * 0.3, y + shapeHeight * 0.5); ctx.lineTo(x - shapeWidth * 0.5, y + shapeHeight * 0.2);
                    ctx.lineTo(x - shapeWidth * 0.5, y - shapeHeight * 0.2); ctx.closePath();
                    const goldGrad = ctx.createLinearGradient(x - shapeWidth / 2, y - shapeHeight / 2, x + shapeWidth / 2, y + shapeHeight / 2);
                    goldGrad.addColorStop(0, '#FFD700'); goldGrad.addColorStop(0.4, '#DAA520'); goldGrad.addColorStop(0.8, '#B8860B'); goldGrad.addColorStop(1, '#A0522D');
                    ctx.fillStyle = goldGrad; ctx.fill(); ctx.strokeStyle = '#CC9900'; ctx.lineWidth = 2; ctx.stroke();
                    const centerCircleRadius = player.size * 0.45 / 2;
                    const glowProgress = (Math.sin(time / 900) + 1) / 2;
                    const glowBlur1 = 30 + (glowProgress * 10); const glowBlur2 = 60 + (glowProgress * 20);
                    ctx.globalAlpha = 0.8; ctx.fillStyle = 'rgba(173, 216, 230, 0.8)'; ctx.filter = `blur(${glowBlur2}px)`;
                    ctx.beginPath(); ctx.arc(x, y, centerCircleRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.globalAlpha = 1.0; ctx.filter = `blur(${glowBlur1}px)`;
                    ctx.beginPath(); ctx.arc(x, y, centerCircleRadius, 0, 2 * Math.PI); ctx.fill(); ctx.filter = 'none';
                    const blueGrad = ctx.createRadialGradient(x, y, 0, x, y, centerCircleRadius);
                    blueGrad.addColorStop(0, '#ADD8E6'); blueGrad.addColorStop(0.3, '#87CEEB'); blueGrad.addColorStop(0.7, '#4682B4'); blueGrad.addColorStop(1, '#2F4F4F');
                    ctx.fillStyle = blueGrad; ctx.beginPath(); ctx.arc(x, y, centerCircleRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.strokeStyle = 'rgba(173, 216, 230, 0.5)'; ctx.lineWidth = 2; ctx.stroke();
                    const innerBlueRadius = centerCircleRadius * 0.6; ctx.fillStyle = '#00BFFF';
                    ctx.beginPath(); ctx.arc(x, y, innerBlueRadius, 0, 2 * Math.PI); ctx.fill();
                    const whiteCoreRadius = innerBlueRadius * 0.58;
                    const whiteGrad = ctx.createRadialGradient(x, y, 0, x, y, whiteCoreRadius);
                    whiteGrad.addColorStop(0, '#FFFFFF'); whiteGrad.addColorStop(0.6, '#E0E0E0'); whiteGrad.addColorStop(1, '#C0C0C0');
                    ctx.fillStyle = whiteGrad; ctx.beginPath(); ctx.arc(x, y, whiteCoreRadius, 0, 2 * Math.PI); ctx.fill();
                    ctx.restore();
                }
            },
            {
                id: 'skin_liberty_sentinel',
                name: 'Sentinela da Liberdade',
                rarity: '√âpica',
                unlockCondition: { type: 'global_stat', stat: 'allBossesDefeated', value: ['guardian', 'sincronizador', 'arbiter', 'hivemind_nexus'] }, // --- ALTERADO ---
                unlockHint: 'Derrote todos os chefes do jogo (Guardi√£o, Sincronizador, √Årbitro e Nexus).', // --- ALTERADO ---
                draw: (ctx, player, options) => {
                    ctx.save(); const { x, y } = player.position; const radius = player.size / 2;
                    ctx.shadowColor = '#B91C1C'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 2;
                    ctx.fillStyle = '#B91C1C'; ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.fill();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                    ctx.fillStyle = '#E5E7EB'; ctx.beginPath(); ctx.arc(x, y, radius * 0.8, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#B91C1C'; ctx.beginPath(); ctx.arc(x, y, radius * 0.6, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#2563EB'; ctx.beginPath(); ctx.arc(x, y, radius * 0.4, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#E5E7EB'; ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                        const outerX = x + radius * 0.35 * Math.cos(angle); const outerY = y + radius * 0.35 * Math.sin(angle);
                        ctx.lineTo(outerX, outerY);
                        const innerAngle = angle + Math.PI / 5;
                        const innerX = x + radius * 0.15 * Math.cos(innerAngle); const innerY = y + radius * 0.15 * Math.sin(innerAngle);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath(); ctx.fill(); ctx.restore();
                }
            },
            {
                id: 'skin_gpu',
                name: 'Shader Unit (GPU)',
                rarity: '√âpica',
                unlockCondition: { type: 'session_stat', stat: 'reachedInfiniteMode', value: true },
                unlockHint: 'Chegue ao Modo Infinito.',
                 draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size;
                    ctx.translate(x, y);
                    const grad = ctx.createLinearGradient(-size / 2, -size / 2, size / 2, size / 2);
                    const hue = (now / 20) % 360;
                    grad.addColorStop(0, `hsl(${hue}, 100%, 50%)`); grad.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 100%, 50%)`); grad.addColorStop(1, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
                    ctx.fillStyle = grad; ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.shadowColor = 'white'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.moveTo(0, -size / 2); ctx.lineTo(size / 2, size / 2); ctx.lineTo(-size / 2, size / 2); ctx.closePath();
                    ctx.fill(); ctx.stroke(); ctx.restore();
                }
            },
            // --- LEND√ÅRIA ---
            {
                id: 'skin_dragon_ball_4',
                name: 'Esfera de 4 Estrelas',
                rarity: 'Lend√°ria',
                unlockCondition: { type: 'session_stat', stat: 'healthPickupsCollected', value: 7 },
                unlockHint: 'Colete 7 orbes de vida em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const r = player.size / 2;
                    ctx.save();
                    ctx.shadowColor = '#F6AD55'; ctx.shadowBlur = 20;
                    const grad = ctx.createRadialGradient(x - r*0.2, y - r*0.3, r*0.1, x, y, r);
                    grad.addColorStop(0, '#FEEBC8'); grad.addColorStop(0.5, '#F6AD55'); grad.addColorStop(1, '#DD6B20');
                    ctx.fillStyle = grad; 
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#742A2A'; ctx.lineWidth = 1;
                    const starPositions = [ {x: -0.3, y: -0.3}, {x: 0.3, y: -0.3}, {x: -0.3, y: 0.3}, {x: 0.3, y: 0.3} ];
                    starPositions.forEach(pos => {
                        const starX = x + r * pos.x; const starY = y + r * pos.y; const starR = r * 0.15;
                        ctx.shadowColor = '#E53E3E'; ctx.shadowBlur = 10;
                        ctx.fillStyle = '#C53030';
                        ctx.beginPath();
                        for(let i=0; i<10; i++) {
                            const angle = (i/10)*Math.PI*2;
                            const radius = i%2===0 ? starR : starR*0.4;
                            ctx.lineTo(starX + Math.cos(angle)*radius, starY + Math.sin(angle)*radius);
                        }
                        ctx.closePath(); ctx.fill();
                        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.stroke();
                    });
                    ctx.restore();
                }
            },
            {
                id: 'skin_hextech',
                name: 'Hextech',
                rarity: 'Lend√°ria',
                unlockCondition: { type: 'session_stat', stat: 'evolvedWeapons', value: 3 },
                unlockHint: 'Evolua 3 armas diferentes em uma √∫nica partida.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y; const size = player.size * 1.2;
                    if (!skinStateCache.hextech) {
                        skinStateCache.hextech = {}; const p = document.createElement('canvas'); const pc = p.getContext('2d');
                        p.width = 50; p.height = 50;
                        const g = pc.createLinearGradient(0, 0, 50, 50);
                        g.addColorStop(0, '#8c7853'); g.addColorStop(0.5, '#D4AF37'); g.addColorStop(1, '#8c7853');
                        pc.fillStyle = g; pc.fillRect(0, 0, 50, 50); pc.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        for (let i = 0; i < 30; i++) { pc.beginPath(); pc.moveTo(Math.random() * 50, Math.random() * 50); pc.lineTo(Math.random() * 50, Math.random() * 50); pc.stroke(); }
                        skinStateCache.hextech.metalTexture = ctx.createPattern(p, 'repeat');
                    }
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 8;
                    ctx.fillStyle = '#4a3f2a'; drawHexagon(ctx, x, y, size / 2); ctx.fill(); ctx.shadowColor = 'transparent';
                    ctx.save(); drawHexagon(ctx, x, y, size / 2 * 0.9); ctx.clip(); ctx.fillStyle = skinStateCache.hextech.metalTexture; ctx.fillRect(x - size / 2, y - size / 2, size, size); ctx.restore();
                    ctx.save(); ctx.translate(x, y); ctx.rotate((now / 2000)); ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; drawGear(ctx, 0, 0, size * 0.35, 8); ctx.fill(); ctx.restore();
                    ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 2; ctx.shadowColor = '#00FFFF'; ctx.shadowBlur = 20; ctx.globalAlpha = 0.5 + Math.sin(now / 200) * 0.5;
                    drawHextechCircuits(ctx, x, y, size / 2 * 0.7); ctx.stroke();
                    const coreGrad = ctx.createRadialGradient(x, y, 1, x, y, size * 0.2);
                    coreGrad.addColorStop(0, 'white'); coreGrad.addColorStop(0.3, '#00FFFF'); coreGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    ctx.fillStyle = coreGrad; ctx.beginPath(); ctx.arc(x, y, size * 0.25, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                }
            },
            {
                id: 'skin_celestial_map',
                name: 'Mapa Celestial',
                rarity: 'Lend√°ria',
                unlockCondition: { type: 'global_stat', stat: 'bossKills', bossType: 'sincronizador', value: 5 },
                unlockHint: 'Derrote o Sincronizador (Chefe da Fase 2) 5 vezes no total.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x, y); ctx.strokeStyle = 'rgba(251, 191, 36, 0.6)'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(0, 0, size*0.2, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, size*0.35, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, size*0.5, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = '#FBBF24'; ctx.beginPath(); ctx.arc(0, 0, size * 0.1, 0, Math.PI*2); ctx.fill();
                    const planets = [ { r: size*0.2, s: 0.002, c: '#9AE6B4', size: 4 }, { r: size*0.35, s: -0.001, c: '#63B3ED', size: 6 }, { r: size*0.5, s: 0.0005, c: '#F56565', size: 5 } ];
                    planets.forEach(p => { const angle = time * p.s; const px = Math.cos(angle) * p.r; const py = Math.sin(angle) * p.r; ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(px, py, p.size, 0, Math.PI * 2); ctx.fill(); });
                    ctx.restore();
                }
            },
                        {
                id: 'skin_cosmic_sundial',
                name: 'Solst√≠cio C√≥smico',
                rarity: 'Lend√°ria',
                unlockCondition: { type: 'global_stat', stat: 'totalTimePlayed', value: 18000 },
                unlockHint: 'Acumule 5 horas de tempo de jogo total.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position;
                    const size = player.size * 1.4;
                    const time = options.time;

                    if (!player.sundialState) {
                        player.sundialState = {
                            nebulaRotation: 0,
                            ring1Rotation: 0,
                            ring2Rotation: 0,
                        };
                    }
                    const state = player.sundialState;

                    ctx.save();
                    ctx.translate(x, y);

                    const nebulaGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size / 2);
                    const hue = (time / 100) % 360;
                    nebulaGrad.addColorStop(0, `hsl(${hue}, 70%, 50%)`);
                    nebulaGrad.addColorStop(0.7, `hsl(${(hue + 120) % 360}, 60%, 20%)`);
                    nebulaGrad.addColorStop(1, '#020617');
                    
                    ctx.fillStyle = nebulaGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = `hsla(${(hue + 60) % 360}, 100%, 80%, 0.6)`;
                    ctx.lineWidth = 1.5;
                    ctx.shadowColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                    ctx.shadowBlur = 10;
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        const angle = i * (Math.PI*2/3) + time / 8000;
                        ctx.lineTo(Math.cos(angle) * size/2.2, Math.sin(angle) * size/2.2);
                        ctx.stroke();
                    }
                    ctx.shadowColor = 'transparent';

                    const drawRing = (radius, rotation, glyphs) => {
                        ctx.save();
                        ctx.rotate(rotation);
                        ctx.strokeStyle = '#FDE047';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        const glowIndex = Math.floor((time / 200) % glyphs);
                        for(let i=0; i<glyphs; i++) {
                            const angle = i * (Math.PI * 2 / glyphs);
                            const isGlowing = i === glowIndex;
                            ctx.fillStyle = isGlowing ? '#FFFBEB' : '#FDE047';
                            if(isGlowing) {
                                ctx.shadowColor = '#FFFBEB';
                                ctx.shadowBlur = 15;
                            }
                            ctx.fillRect(Math.cos(angle) * radius - 2, Math.sin(angle) * radius - 2, 4, 4);
                            ctx.shadowColor = 'transparent';
                        }
                        ctx.restore();
                    };
                    state.ring1Rotation += 0.0005;
                    state.ring2Rotation -= 0.0008;
                    drawRing(size * 0.4, state.ring1Rotation, 12);
                    drawRing(size * 0.3, state.ring2Rotation, 8);
                    
                    const coreRadius = size * 0.2;
                    const sunPulse = 0.95 + Math.sin(time / 200) * 0.05;
                    const sunGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius * sunPulse);
                    sunGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    sunGrad.addColorStop(0.8, 'rgba(254, 249, 195, 1)');
                    sunGrad.addColorStop(1, 'rgba(251, 146, 60, 0.8)');
                    
                    ctx.fillStyle = sunGrad;
                    ctx.shadowColor = '#FBBF24';
                    ctx.shadowBlur = 30;
                    ctx.beginPath();
                    ctx.arc(0, 0, coreRadius * sunPulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';

                    ctx.restore();
                }
            },
            // --- M√çTICA ---
            {
                id: 'skin_antimatter_reactor',
                name: 'Reator de Antimat√©ria',
                rarity: 'M√≠tica',
                unlockCondition: { type: 'combined', conditions: [{ type: 'session_event', event: 'defeat_boss', params: { bossType: 'hivemind_nexus' } }, { type: 'session_stat', stat: 'dashUsed', value: false } ]}, // --- ALTERADO ---
                unlockHint: 'Derrote o Nexus da Colmeia sem usar a habilidade de Dash.', // --- ALTERADO ---
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time; ctx.save();
                    const rings = [ { r: size * 0.5, w: 4, s: 0.001, c: '#9CA3AF' }, { r: size * 0.4, w: 2, s: -0.002, c: '#FBBF24' }, { r: size * 0.3, w: 3, s: 0.003, c: '#9CA3AF' } ];
                    rings.forEach(ring => { ctx.strokeStyle = ring.c; ctx.lineWidth = ring.w; ctx.beginPath(); ctx.arc(x, y, ring.r, time * ring.s, time * ring.s + Math.PI * 1.5); ctx.stroke(); });
                    ctx.fillStyle = '#A78BFA';
                    for(let i=0; i<30; i++) {
                        const angle = (i/30)*Math.PI*2 + time/1000; const dist = size/2 * (1 - ((time/500 + i*10)%1));
                        ctx.globalAlpha = 1 - (dist / (size/2)); ctx.fillRect(x + Math.cos(angle)*dist - 1, y + Math.sin(angle)*dist - 1, 2, 2);
                    }
                    const coreRadius = size * 0.25; ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(x, y, coreRadius, 0, Math.PI*2); ctx.fill();
                    ctx.save(); ctx.globalCompositeOperation = 'lighter';
                    for(let i=0; i<3; i++){ if(Math.random() > 0.8) {
                        ctx.strokeStyle = `rgba(167, 139, 250, ${Math.random()*0.8})`; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath(); ctx.moveTo(x,y); const r_angle = Math.random() * Math.PI * 2; ctx.lineTo(x + Math.cos(r_angle)*coreRadius, y + Math.sin(r_angle)*coreRadius); ctx.stroke();
                    }}
                    ctx.restore(); ctx.restore();
                }
            },
            {
                id: 'skin_glitchware',
                name: 'Glitchware',
                rarity: 'M√≠tica',
                unlockCondition: { type: 'combined', conditions: [
                    { type: 'session_stat', stat: 'reachedInfiniteMode', value: true },
                    { type: 'session_stat', stat: 'dashUsed', value: false },
                    { type: 'session_stat', stat: 'evolvedWeapons', value: 0 }
                ]},
                unlockHint: 'Chegue ao Modo Infinito sem usar Dash e sem evoluir armas.',
                draw: (ctx, player, options) => {
                    ctx.save();
                    const now = options.time; const x = player.position.x; const y = player.position.y;
                    ctx.save(); ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.7)'; drawGlitchwareFragments(ctx, x + 2, y, player.size, now);
                    ctx.fillStyle = 'rgba(255, 0, 150, 0.7)'; drawGlitchwareFragments(ctx, x - 2, y, player.size, now);
                    ctx.restore();
                    ctx.fillStyle = '#FF00FF'; ctx.shadowColor = '#FF00FF'; ctx.shadowBlur = 20;
                    ctx.beginPath(); const coreSize = (player.size / 4) * (1 + Math.sin(now / 150) * 0.1);
                    ctx.arc(x, y, coreSize, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                }
            },
            {
                id: 'skin_nanite_swarm',
                name: 'Enxame Nanotecnol√≥gico',
                rarity: 'M√≠tica',
                unlockCondition: { type: 'session_event', event: 'winWithClass', classId: 'class_technomancer' },
                unlockHint: 'Ven√ßa o jogo (derrote o Nexus) com a classe Tecnomante.', // --- ALTERADO ---
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size; const time = options.time;
                    ctx.save(); ctx.translate(x,y); const naniteCount = 40;
                    for(let i=0; i < naniteCount; i++) {
                        const angle = (time / 2000) + (i / naniteCount) * Math.PI * 2;
                        const orbitRadius = size/3 + Math.sin(time/500 + i*5) * size * 0.15;
                        const naniteX = Math.cos(angle) * orbitRadius; const naniteY = Math.sin(angle) * orbitRadius;
                        const naniteSize = size * 0.05 * (0.8 + Math.sin(time/100 + i)*0.2);
                        const hue = (180 + Math.sin(time/1000 + i) * 30) % 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.shadowColor = `hsl(${hue}, 100%, 50%)`; ctx.shadowBlur = 5;
                        ctx.beginPath(); ctx.moveTo(naniteX, naniteY - naniteSize); ctx.lineTo(naniteX - naniteSize, naniteY + naniteSize); ctx.lineTo(naniteX + naniteSize, naniteY + naniteSize);
                        ctx.closePath(); ctx.fill();
                    }
                    ctx.restore();
                }
            },
            {
                id: 'skin_bionic_sanfoneiro',
                name: 'Sanfoneiro Bi√¥nico',
                rarity: 'M√≠tica',
                unlockCondition: { type: 'global_stat', stat: 'totalHealthPickupsCollected', value: 150 },
                unlockHint: 'Colete 150 orbes de vida no total (Dispon√≠vel at√© 30 de junho de 2025).',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position;
                    const size = player.size;
                    const time = options.time;

                    ctx.save();
                    ctx.translate(x, y);

                    const bodyBob = Math.sin(time / 400) * 4;
                    const bodySway = Math.sin(time / 800) * 0.05;
                    ctx.translate(0, bodyBob);
                    ctx.rotate(bodySway);

                    const accordionPull = (Math.sin(time / 500) + 1) / 2;

                    const hoverGlow = 0.5 + (Math.sin(time / 350) + 1) * 0.15;
                    const hoverGradient = ctx.createRadialGradient(0, size * 0.4, 5, 0, size * 0.4, size * 0.3);
                    hoverGradient.addColorStop(0, `rgba(220, 20, 60, ${hoverGlow})`);
                    hoverGradient.addColorStop(1, 'rgba(220, 20, 60, 0)');
                    ctx.fillStyle = hoverGradient;
                    ctx.fillRect(-size*0.4, size*0.2, size*0.8, size*0.4);
                    
                    ctx.fillStyle = '#424242';
                    ctx.beginPath();
                    ctx.ellipse(0, size * 0.3, size * 0.25, size * 0.08, 0, 0, Math.PI * 2);
                    ctx.fill();

                    const torsoGradient = ctx.createLinearGradient(0, -size*0.5, 0, size*0.5);
                    torsoGradient.addColorStop(0, '#BDBDBD');
                    torsoGradient.addColorStop(0.5, '#8D8D8D');
                    torsoGradient.addColorStop(1, '#616161');
                    ctx.fillStyle = torsoGradient;
                    ctx.strokeStyle = '#424242';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(-size*0.22, -size*0.1, size*0.44, size*0.4, 15);
                    ctx.fill();
                    ctx.stroke();
                    
                    const corePulse = 0.8 + (Math.sin(time/200) + 1) * 0.1;
                    ctx.fillStyle = `rgba(255, 80, 80, ${corePulse})`;
                    ctx.shadowColor = 'red';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.roundRect(-size*0.06, size*0.02, size*0.12, size*0.1, 5);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';

                    ctx.save();
                    ctx.rotate(Math.sin(time / 850) * 0.06);
                    
                    ctx.fillStyle = '#616161';
                    ctx.fillRect(-size*0.06, -size*0.2, size*0.12, size*0.12);
                    ctx.fillStyle = torsoGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size*0.2, -size*0.4, size*0.4, size*0.25, 10);
                    ctx.fill();
                    ctx.stroke();
                    const visorGlow = 0.7 + (Math.sin(time / 250) + 1) * 0.15;
                    ctx.fillStyle = `rgba(255, 0, 0, ${visorGlow})`;
                    ctx.shadowColor = 'red'; ctx.shadowBlur = 20;
                    ctx.fillRect(-size*0.16, -size*0.35, size*0.32, size*0.08);
                    ctx.shadowColor = 'transparent';

                    ctx.save();
                    ctx.translate(0, -size * 0.4);
                    ctx.fillStyle = '#E2C275'; ctx.strokeStyle = '#B59458'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.ellipse(0, 0, size * 0.35, size * 0.12, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#D2B468';
                    ctx.beginPath(); ctx.ellipse(0, -size * 0.08, size * 0.2, size * 0.1, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#BF3B3B'; ctx.fillRect(-size*0.1, -size*0.12, size*0.05, size*0.03);
                    ctx.restore();

                    ctx.restore();

                    const accordionCenterY = size * 0.2;
                    const bellowsWidth = size * 0.16 + accordionPull * (size * 0.67);
                    const leftEnd = -bellowsWidth / 2 - (size * 0.21);
                    const rightEnd = bellowsWidth / 2 + (size * 0.21);
                    
                    ctx.fillStyle = '#424242';
                    ctx.beginPath(); ctx.arc(-size*0.22, -size*0.05, size*0.1, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.22, -size*0.05, size*0.1, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#757575';
                    ctx.lineWidth = size * 0.12; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-size * 0.22, -size*0.05); ctx.lineTo(leftEnd, accordionCenterY); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(size * 0.22, -size*0.05); ctx.lineTo(rightEnd, accordionCenterY); ctx.stroke();

                    const bellowsHeight = size * 0.5;
                    ctx.save();
                    ctx.translate(0, accordionCenterY);
                    const folds = 10; const foldWidth = bellowsWidth / folds;
                    const bellowsDark = '#B22222', bellowsLight = '#DC143C', bellowsEdge = '#400000';
                    for(let i = 0; i < folds; i++) {
                        const currentX = -bellowsWidth/2 + i * foldWidth;
                        ctx.beginPath();
                        ctx.moveTo(currentX, -bellowsHeight/2); ctx.lineTo(currentX + foldWidth, -bellowsHeight/2 + size*0.06);
                        ctx.lineTo(currentX + foldWidth, bellowsHeight/2 - size*0.06); ctx.lineTo(currentX, bellowsHeight/2); ctx.closePath();
                        ctx.fillStyle = (i % 2 === 0) ? bellowsLight : bellowsDark; ctx.fill();
                        ctx.strokeStyle = bellowsEdge; ctx.lineWidth = 1.5; ctx.stroke();
                    }
                    ctx.restore();

                    ctx.save();
                    ctx.translate(leftEnd, accordionCenterY);
                    ctx.fillStyle = '#A21111'; ctx.strokeStyle = '#400000'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.roundRect(-size*0.16, -bellowsHeight/2 - size*0.08, size*0.33, bellowsHeight+size*0.16, size*0.06); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#333';
                    for(let i=0; i<3; i++) {
                        for(let j=0; j<5; j++) {
                            ctx.beginPath();
                            ctx.arc(-size*0.06 + i*(size*0.06), -bellowsHeight/2 + size*0.04 + j*(size*0.1), size*0.025, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                    ctx.restore();

                    ctx.save();
                    ctx.translate(rightEnd, accordionCenterY);
                    ctx.fillStyle = '#A21111'; ctx.strokeStyle = '#400000'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.roundRect(-size*0.16, -bellowsHeight/2 - size*0.08, size*0.33, bellowsHeight+size*0.16, size*0.06); ctx.fill(); ctx.stroke();
                    
                    const numKeys = 7;
                    const totalKeyAreaHeight = bellowsHeight + size * 0.14; 
                    const singleKeySlotHeight = totalKeyAreaHeight / numKeys;
                    const keyHeight = singleKeySlotHeight * 0.85; 
                    const keyWidth = size * 0.2;
                    const keyXOffset = -keyWidth / 2;
                    const startY = -bellowsHeight / 2 - size * 0.07; 

                    for(let i = 0; i < numKeys; i++) {
                        const keyY = startY + (i * singleKeySlotHeight);
                        const isGlowing = (Math.floor(time / 200 + i * 3) % 15 === 0);
                        
                        if (isGlowing) {
                            ctx.save();
                            ctx.fillStyle = '#FFFF00';
                            ctx.shadowColor = '#FFFF00';
                            ctx.shadowBlur = 15;
                            ctx.fillRect(keyXOffset, keyY, keyWidth, keyHeight);
                            ctx.restore();
                        } else {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(keyXOffset, keyY, keyWidth, keyHeight);
                        }
                    }
                    ctx.restore();

                    ctx.restore();
                }
            },
            {
                id: 'skin_arc_mechanical_observer',
                name: 'Observador Arc-Mec√¢nico',
                rarity: 'M√≠tica',
                unlockCondition: { type: 'cost_corrupted', value: 9 },
                unlockHint: 'Custo: 9 N√∫cleos Corrompidos.',
                draw: (ctx, player, options) => {
                    const { x, y } = player.position; const size = player.size * 1.1; const time = options.time;
                    const deltaTime = time - (player.lastTimeObs || time); player.lastTimeObs = time;

                    if (!player.observerState) {
                        player.observerState = {
                            rings: [
                                { angle: 0, speed: 0.0001, radius: size * 0.5, runes: 12, width: 3 },
                                { angle: Math.PI, speed: -0.00015, radius: size * 0.4, runes: 8, width: 4 },
                                { angle: Math.PI / 2, speed: 0.0002, radius: size * 0.3, runes: 6, width: 2.5 }
                            ]
                        };
                    }
                    const state = player.observerState;
                    
                    ctx.save(); ctx.translate(x, y);
                    
                    // --- CORRE√á√ÉO APLICADA AQUI ---
                    const fontSize = size * 0.12; 
                    ctx.font = `bold ${fontSize}px "VT323"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // --- FIM DA CORRE√á√ÉO ---

                    state.rings.forEach((ring, ringIdx) => {
                        ring.angle += ring.speed * deltaTime;
                        ctx.save(); ctx.rotate(ring.angle);
                        const ringGrad = ctx.createLinearGradient(-ring.radius, -ring.radius, ring.radius, ring.radius);
                        ringGrad.addColorStop(0, '#f9fafb'); ringGrad.addColorStop(0.5, '#9ca3af'); ringGrad.addColorStop(1, '#6b7280');
                        ctx.strokeStyle = ringGrad; ctx.lineWidth = ring.width; ctx.shadowColor = '#e0f2fe'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.arc(0, 0, ring.radius, 0, Math.PI * 2); ctx.stroke();
                        
                        for(let i=0; i<ring.runes; i++) {
                            const runeAngle = i * (Math.PI*2/ring.runes);
                            const currentAngleInWorld = (ring.angle + runeAngle) % (Math.PI*2);
                            const alignment = Math.min(Math.abs(currentAngleInWorld % (Math.PI/2)), Math.abs((currentAngleInWorld % (Math.PI/2)) - Math.PI/2));
                            const isAligned = alignment < 0.08;
                            const runeHue = (time / 15 + i * (360 / ring.runes) + ringIdx * 60) % 360;
                            const runeColor = `hsl(${runeHue}, 100%, 60%)`;
                            
                            ctx.save(); ctx.rotate(runeAngle); ctx.translate(ring.radius, 0); ctx.rotate(-ring.angle - runeAngle);
                            ctx.globalAlpha = isAligned ? 1 : 0.7; ctx.fillStyle = runeColor;
                            if(isAligned) { ctx.shadowColor = runeColor; ctx.shadowBlur = 30; } 
                            else { ctx.shadowColor = runeColor; ctx.shadowBlur = 10; }
                            ctx.fillText('‚ùñ', 0, 0); // Desenhado no centro
                            ctx.restore();
                        }
                        ctx.restore();
                    });
                    
                    ctx.shadowColor = 'transparent';
                    const eyeR = size * 0.25; const openFactor = 0.5 + Math.sin(time/1000) * 0.5;
                    
                    ctx.save(); ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath(); ctx.arc(0, 0, eyeR, 0, Math.PI * 2); ctx.clip();
                    for(let i=0; i<6; i++) {
                        const angle = i * Math.PI/3 + time*0.0005; const hue = (i*60 + (time/10))%360;
                        const grad = ctx.createLinearGradient(0,0, Math.cos(angle)*eyeR, Math.sin(angle)*eyeR);
                        grad.addColorStop(0, `hsla(${hue}, 100%, 60%, 0)`); grad.addColorStop(openFactor, `hsla(${hue}, 100%, 60%, 0.8)`); grad.addColorStop(1, `hsla(${hue}, 100%, 60%, 0)`);
                        ctx.strokeStyle = grad; ctx.lineWidth = eyeR;
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angle)*eyeR, Math.sin(angle)*eyeR); ctx.stroke();
                    }
                    ctx.restore();
                    
                    ctx.strokeStyle = 'rgba(224, 231, 255, 0.7)'; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.arc(0, 0, eyeR, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }
            },
        ];
        // --- END OF game/skins.ts ---

                // --- START OF game/CrisolPatterns.ts ---
        const CRISOL_PLAYER_STATS = {
            size: 40,
            speed: 320,
            lives: 3,
        };

        const CRISOL_ARENA = {
            width: 800,
            height: 800,
            get x() { return (CANVAS_WIDTH - this.width) / 2; },
            get y() { return (CANVAS_HEIGHT - this.height) / 2; },
            get centerX() { return this.x + this.width / 2; },
            get centerY() { return this.y + this.height / 2; },
        };

        const CRISOL_PROJECTILE_TYPES = {
            CLASSIC: { size: 12, color: '#e74c3c' },
            SLOW: { size: 14, color: '#3498db' },
            FAST: { size: 8, color: '#f1c40f' },
            RHYTHM: { size: 16, color: '#9b59b6' },
            WALL: { size: 10, color: '#7f8c8d', isStatic: true, life: 4000 },
            HOMING: { size: 10, color: '#2ecc71', isHoming: true, homingStrength: 0.03, lifetime: 6000 },
            BEAM_WARNING: { color: 'rgba(255, 255, 0, 0.3)'},
            BEAM: { color: '#f1c40f' },
        };

        const CRISOL_CHAMBERS = [
            // ========================= C√ÇMARA 01: A Geometria do Fluxo (Revisada) =========================
            {
                id: 'chamber_01',
                name: 'C√¢mara 01: A Geometria do Fluxo',
                reward: { systemCores: 8, corruptedKernels: 0 },
                sequences: [
                    // Minuto 1: Linhas e Espa√ßos (Ensina desvio linear)
                    { duration: 60000, attacks: [
                        { type: 'line_random', from: 'top', count: 8, speed: 180, speedVariation: 0.1, startTime: 2000, interval: 2500, projectile: 'CLASSIC' },
                        { type: 'line_random', from: 'bottom', count: 8, speed: 180, speedVariation: 0.1, startTime: 10000, interval: 2500, projectile: 'CLASSIC' },
                        { type: 'drifting_line', from: 'left', spacing: 120, speed: 150, driftSpeed: 20, alternate: false, startTime: 35000, interval: 5000, projectile: 'SLOW' },
                    ]},

                    // Minuto 2 (1-2 min): Ecos Cin√©ticos (Introdu√ß√£o ao Ricochete)
                    { duration: 60000, attacks: [
                        // Come√ßa com poucos proj√©teis para o jogador entender a mec√¢nica
                        { type: 'ricochet', count: 8, speed: 170, startTime: 1000, interval: 6000, projectile: 'FAST' },
                        // Aumenta a quantidade na metade do tempo
                        { type: 'ricochet', count: 4, speed: 180, startTime: 30000, interval: 5000, projectile: 'FAST' },
                        // Adiciona um pulso lento para criar press√£o e for√ßar movimento, sem sobrecarregar
                        { type: 'pulse', count: 8, speed: 130, startTime: 15000, interval: 8000, projectile: 'SLOW' },
                    ]},

                    // Minuto 3: A Dan√ßa dos Segmentos (Teste de controle de espa√ßo e "pastoreio")
                    { duration: 60000, attacks: [
                        // Segmentos de proj√©teis que se movem como uma unidade, for√ßando o jogador a criar espa√ßo.
                        { type: 'segment_swarm', numSegments: 10, length: 7, speed: 200, startTime: 1000, interval: 5000, projectile: 'RHYTHM' },
                        // Segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 4000, interval: 3000, projectile: 'FAST' },
                        // Mais segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 12000, interval: 3000, projectile: 'FAST' },
                        // Mais segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 24000, interval: 3000, projectile: 'FAST' },
                        // Mais segmentos que cortam a tela, limitando as rotas de fuga.
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 48000, interval: 3000, projectile: 'FAST' },
                    ]},
                    
                    // Minuto 4: O Labirinto de Ecos (Teste de mem√≥ria de curto prazo e precis√£o)
                    { duration: 60000, attacks: [
                        // Pulsos de proj√©teis emanam de um ponto que se move pela arena, criando ondas assim√©tricas.
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 100, startTime: 1000, interval: 3500, projectile: 'SLOW' },
                        // Proj√©teis teleguiados impedem que o jogador fique parado ou encontre um ponto cego facilmente.
                        { type: 'homing', count: 2, speed: 170, startTime: 2500, interval: 5000, projectile: 'HOMING' },
                        // Pulsos de proj√©teis emanam de um ponto que se move pela arena, criando ondas assim√©tricas.
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 100, startTime: 10000, interval: 3500, projectile: 'SLOW' },
                        // Pulsos de proj√©teis emanam de um ponto que se move pela arena, criando ondas assim√©tricas.
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 100, startTime: 35000, interval: 3500, projectile: 'SLOW' },
                        // Proj√©teis teleguiados impedem que o jogador fique parado ou encontre um ponto cego facilmente.
                        { type: 'homing', count: 2, speed: 170, startTime: 45000, interval: 5000, projectile: 'HOMING' },
                    ]},

                    // Minuto 5: O Pulso Assim√©trico (Teste de adapta√ß√£o a padr√µes n√£o-centrados)
                    { duration: 60000, attacks: [ 
                        {type: 'spiral',
                numArms: 4,
                projectilesPerArm: 10,
                rotationSpeed: 0.1,
                speed: 135,
                startTime: 10000,
                interval: 8000, // <--- 2. FREQU√äNCIA: Esta linha diz "Execute este ataque a cada 8.000 ms (8 segundos)".
                projectile: 'RHYTHM'},
                        { type: 'wave', from: 'left', count: 6, speed: 200, amplitude: 100, frequency: 0.008, startTime: 2500, interval: 6000, projectile: 'RHYTHM' },
                        { type: 'wave', from: 'right', count: 6, speed: 215, amplitude: 100, frequency: 0.012, startTime: 30000, interval: 6000, projectile: 'RHYTHM' }
                    ]},
                    
                    // Minuto 6: Fus√£o
                    { duration: 60000, attacks: [
                        //ATK do min1
                        { type: 'line_random', from: 'top', count: 8, speed: 180, speedVariation: 0.1, startTime: 2000, interval: 2500, projectile: 'CLASSIC' },
                        //ATK do min2
                        { type: 'ricochet', count: 8, speed: 170, startTime: 10000, interval: 6000, projectile: 'FAST' },
                        //ATK do min3
                        { type: 'segment_cutter', length: 20, speed: 350, startTime: 20000, interval: 3000, projectile: 'FAST' },
                        //ATK do min4
                        { type: 'wandering_pulse', count: 12, speed: 150, wanderSpeed: 30000, startTime: 35000, interval: 3500, projectile: 'SLOW' },
                        //ATK do min5
                        { type: 'wave', from: 'left', count: 6, speed: 200, amplitude: 40000, frequency: 0.008, startTime: 2500, interval: 6000, projectile: 'RHYTHM' },
                    ]},
                ]
            },
            // ========================= C√ÇMARA 02: RITMO =========================
            {
                id: 'chamber_02',
                name: 'C√¢mara 02: O Cora√ß√£o da M√°quina',
                reward: { systemCores: 6, corruptedKernels: 1 },
                sequences: [
                    // Minuto 1: Ondas Senoidais
                    { duration: 60000, attacks: [ { type: 'wave', from: 'left', count: 20, speed: 200, amplitude: 60, frequency: 0.01, startTime: 2000, interval: 6000, projectile: 'RHYTHM' }] },
                    // Minuto 2: Ondas Cruzadas
                    { duration: 60000, attacks: [ { type: 'wave', from: 'left', count: 15, speed: 210, amplitude: 70, frequency: 0.01, startTime: 0, interval: 5000, projectile: 'RHYTHM' }, { type: 'wave', from: 'top', count: 12, speed: 210, amplitude: 70, frequency: 0.01, startTime: 2500, interval: 5000, projectile: 'RHYTHM' }] },
                    // Minuto 3: Paredes Dan√ßantes
                    { duration: 60000, attacks: [ { type: 'dancing_walls', gapSize: 350, speed: 100, startTime: 1000, interval: 7000, projectile: 'CLASSIC' }] },
                    // Minuto 4: Batida do Monitor (Pulso)
                    { duration: 60000, attacks: [ { type: 'beat_attack', attackType: 'pulse', count: 16, speed: 180, startTime: 3000, interval: 4000, projectile: 'RHYTHM' }] },
                    // Minuto 5: Ondas e Paredes
                    { duration: 60000, attacks: [ { type: 'wave', from: 'right', count: 15, speed: 220, amplitude: 80, frequency: 0.012, startTime: 0, interval: 6000, projectile: 'RHYTHM' }, { type: 'dancing_walls', gapSize: 300, speed: 120, startTime: 3000, interval: 8000, projectile: 'CLASSIC' }] },
                    // Minuto 6: Sincopado (Ondas na batida)
                    { duration: 60000, attacks: [ { type: 'beat_attack', attackType: 'wave', from:'top', count:10, speed: 250, amplitude: 50, frequency: 0.01, startTime: 1000, interval: 3000, projectile: 'RHYTHM' }, { type: 'wave', from: 'left', count: 15, speed: 200, amplitude: 100, frequency: 0.008, startTime: 2500, interval: 6000, projectile: 'RHYTHM' }] },
                ]
            },
            // ========================= C√ÇMARA 03: LABIRINTO =========================
            {
                id: 'chamber_03',
                name: 'C√¢mara 03: Arquitetura Hostil',
                reward: { systemCores: 7, corruptedKernels: 2 },
                sequences: [
                    // Minuto 1: Matriz de Cristal Simples
                    { duration: 60000, attacks: [ { type: 'crystal_matrix', rows: 4, cols: 4, speed: 250, holdTime: 3500, startTime: 3000, interval: 8000, projectile: 'WALL' }] },
                    // Minuto 2: Feixes de Varredura
                    { duration: 60000, attacks: [ { type: 'sweep_beam', from: 'left', speed: 80, startTime: 2000, interval: 5000, projectile: 'BEAM' }] },
                    // Minuto 3: Pris√£o de Contra√ß√£o
                    { duration: 60000, attacks: [ { type: 'shrinking_prison', speed: 200, holdTime: 2500, startTime: 4000, interval: 9000, projectile: 'CLASSIC' }] },
                    // Minuto 4: Feixes + Pulsos
                    { duration: 60000, attacks: [ { type: 'sweep_beam', from: 'top', speed: 90, startTime: 1000, interval: 6000, projectile: 'BEAM' }, { type: 'pulse', count: 8, speed: 150, startTime: 3500, interval: 6000, projectile: 'SLOW' }] },
                    // Minuto 5: Matriz + Feixes
                    { duration: 60000, attacks: [ { type: 'crystal_matrix', rows: 5, cols: 5, speed: 280, holdTime: 3000, startTime: 1000, interval: 8000, projectile: 'WALL' }, { type: 'sweep_beam', from: 'right', speed: 90, startTime: 5000, interval: 8000, projectile: 'BEAM' }] },
                    // Minuto 6: Pris√£o + Matriz
                    { duration: 60000, attacks: [ { type: 'shrinking_prison', speed: 220, holdTime: 2000, startTime: 1000, interval: 9000, projectile: 'CLASSIC' }, { type: 'crystal_matrix', rows: 3, cols: 3, speed: 300, holdTime: 2500, startTime: 5000, interval: 9000, projectile: 'WALL' }] },
                ]
            },
            // ========================= C√ÇMARA 04: REA√á√ÉO =========================
            {
                id: 'chamber_04',
                name: 'C√¢mara 04: O Jogo da Mente',
                reward: { systemCores: 8, corruptedKernels: 3 },
                sequences: [
                    // Minuto 1: Proj√©teis Camale√£o
                    { duration: 60000, attacks: [ { type: 'chameleon', projectile: 'HOMING', count: 2, speed: 120, startTime: 2000, interval: 4000 }, { type: 'chameleon', projectile: 'FAST', count: 5, speed: 350, startTime: 2000, interval: 4000 } ] },
                    // Minuto 2: Marca√ß√£o e Ataque
                    { duration: 60000, attacks: [ { type: 'target_player', count: 12, speed: 300, delay: 1500, startTime: 1000, interval: 3500, projectile: 'FAST' }] },
                    // Minuto 3: Ataques de Borda Falsos
                    { duration: 60000, attacks: [ { type: 'fake_out', trueFrom: 'top', falseFrom: 'bottom', count: 8, speed: 280, startTime: 2000, interval: 4000, projectile: 'CLASSIC' }] },
                    // Minuto 4: Camale√µes + Marca√ß√£o
                    { duration: 60000, attacks: [ { type: 'chameleon', projectile: 'HOMING', count: 3, speed: 130, startTime: 1000, interval: 4500 }, { type: 'target_player', count: 8, speed: 320, delay: 1200, startTime: 3000, interval: 4500, projectile: 'FAST' }] },
                    // Minuto 5: Marca√ß√£o + Borda Falsa
                    { duration: 60000, attacks: [ { type: 'target_player', count: 10, speed: 350, delay: 1000, startTime: 0, interval: 4000, projectile: 'FAST' }, { type: 'fake_out', trueFrom: 'right', falseFrom: 'left', count: 6, speed: 300, startTime: 2000, interval: 4000, projectile: 'CLASSIC' }] },
                    // Minuto 6: Todos Juntos
                    { duration: 60000, attacks: [ { type: 'chameleon', projectile: 'HOMING', count: 2, speed: 140, startTime: 0, interval: 5000 }, { type: 'target_player', count: 6, speed: 380, delay: 900, startTime: 1500, interval: 5000, projectile: 'FAST' }, { type: 'fake_out', trueFrom: 'bottom', falseFrom: 'top', count: 5, speed: 320, startTime: 3500, interval: 5000, projectile: 'CLASSIC' }] },
                ]
            },
            // ========================= C√ÇMARA 05: SINFONIA =========================
            {
                id: 'chamber_05',
                name: 'C√¢mara 05: A Prova Final',
                reward: { systemCores: 10, corruptedKernels: 5 },
                sequences: [
                    // Minuto 1: Geometria + Ritmo
                    { duration: 60000, attacks: [ { type: 'line', from: 'top', count: 8, speed: 250, startTime: 1000, interval: 4000, projectile: 'CLASSIC' }, { type: 'wave', from: 'left', count: 15, speed: 220, amplitude: 60, frequency: 0.01, startTime: 3000, interval: 5000, projectile: 'RHYTHM' }] },
                    // Minuto 2: Ritmo + Labirinto
                    { duration: 60000, attacks: [ { type: 'beat_attack', attackType: 'pulse', count: 12, speed: 180, startTime: 1000, interval: 4000, projectile: 'RHYTHM' }, { type: 'sweep_beam', from: 'bottom', speed: 80, startTime: 3000, interval: 6000, projectile: 'BEAM' }] },
                    // Minuto 3: Labirinto + Rea√ß√£o
                    { duration: 60000, attacks: [ { type: 'crystal_matrix', rows: 4, cols: 4, speed: 300, holdTime: 2500, startTime: 1000, interval: 7000, projectile: 'WALL' }, { type: 'chameleon', projectile: 'HOMING', count: 2, speed: 130, startTime: 4000, interval: 7000 } ] },
                    // Minuto 4: Rea√ß√£o + Geometria
                    { duration: 60000, attacks: [ { type: 'target_player', count: 10, speed: 350, delay: 1200, startTime: 0, interval: 3500, projectile: 'FAST' }, { type: 'ricochet', count: 4, speed: 180, startTime: 1500, interval: 3500, projectile: 'FAST' } ] },
                    // Minuto 5: Rota√ß√£o de Temas
                    { duration: 60000, attacks: [ { type: 'theme_rotation', themes: ['GEOMETRY', 'RHYTHM'], duration: 10000, startTime: 0, interval: 10000 } ] },
                    // Minuto 6: Caos Controlado
                    { duration: 60000, attacks: [ { type: 'theme_rotation', themes: ['LABYRINTH', 'REACTION'], duration: 8000, startTime: 0, interval: 8000 } ] },
                ]
            }
        ];
        // --- END OF game/CrisolPatterns.ts ---

        // --- START OF hooks/useCrisolEngine.ts ---
        const useCrisolEngine = (onGameOver) => {
            const { useState, useCallback, useRef } = React;

            const createInitialState = () => ({
                player: {
                    position: { x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY + 300 },
                    ...CRISOL_PLAYER_STATS,
                    lastMoveDirection: { x:0, y:-1 }, lastHitTime: 0,
                },
                projectiles: [],
                visualEffects: [],
                gameTime: 0,
                sequenceTime: 0,
                sequenceIndex: 0,
                isPausedBetweenSequences: true,
                pauseEndTime: 0,
                mode: null,
                chamberId: null,
                keys: { w: false, a: false, s: false, d: false, ' ': false },
                activeAttacks: {},
                isPaused: false,
            });

            const [gameState, setGameState] = useState(createInitialState);
            const chamberDataRef = useRef(null);
            
            const startChamber = useCallback((chamberId) => {
                const chamber = CRISOL_CHAMBERS.find(c => c.id === chamberId);
                if (!chamber) return;
                chamberDataRef.current = chamber;
                setGameState({
                    ...createInitialState(),
                    mode: 'chamber',
                    chamberId: chamberId,
                    isPausedBetweenSequences: true,
                    pauseEndTime: Date.now() + 3000,
                });
            }, [onGameOver]);

            const startInfinite = useCallback(() => {
                console.warn("Infinite Mode not implemented yet.");
            }, []);
            
            const handleKeys = useCallback((key, isDown) => {
                setGameState(prev => ({ ...prev, keys: { ...prev.keys, [key.toLowerCase()]: isDown } }));
            }, []);

            const pauseGame = useCallback(() => {
                setGameState(prev => ({ ...prev, isPaused: true }));
            }, []);

            const resumeGame = useCallback(() => {
                setGameState(prev => ({ ...prev, isPaused: false }));
            }, []);
            
            const spawnProjectiles = useCallback((attack, projType, now, playerPos, callCount = 0) => {
                const newProjectiles = [];
                const newEffects = [];
                const speed = attack.speed * (1 + (Math.random() - 0.5) * (attack.speedVariation || 0));

                switch(attack.type) {
                    case 'line':
                        for(let i=0; i < attack.count; i++) {
                            let pos, vel;
                            const from = attack.from === 'all' ? ['top', 'bottom', 'left', 'right'][i % 4] : attack.from;
                            const spacingX = CRISOL_ARENA.width / (attack.count + 1);
                            const spacingY = CRISOL_ARENA.height / (attack.count + 1);
                             if(attack.gap) {
                                const gapStart = CRISOL_ARENA.height * attack.gap.start;
                                const gapEnd = gapStart + CRISOL_ARENA.height * attack.gap.size;
                                const yPos = CRISOL_ARENA.y + i * (CRISOL_ARENA.height / (attack.count-1));
                                if (yPos > gapStart && yPos < gapEnd) continue;
                            }
                            if(from === 'top') { pos = { x: CRISOL_ARENA.x + spacingX * (i + 1), y: CRISOL_ARENA.y - 20 }; vel = { x: 0, y: speed }; } 
                            else if(from === 'bottom') { pos = { x: CRISOL_ARENA.x + spacingX * (i + 1), y: CRISOL_ARENA.y + CRISOL_ARENA.height + 20 }; vel = { x: 0, y: -speed }; } 
                            else if(from === 'left') { pos = { x: CRISOL_ARENA.x - 20, y: CRISOL_ARENA.y + (attack.gap ? i * (CRISOL_ARENA.height / (attack.count-1)) : spacingY * (i+1)) }; vel = { x: speed, y: 0 }; } 
                            else if(from === 'right') { pos = { x: CRISOL_ARENA.x + CRISOL_ARENA.width + 20, y: CRISOL_ARENA.y + (attack.gap ? i * (CRISOL_ARENA.height / (attack.count-1)) : spacingY * (i+1)) }; vel = { x: -speed, y: 0 }; }
                            if(pos) newProjectiles.push({ id: `p-${now}-line-${i}`, position: pos, velocity: vel, ...projType });
                        }
                        break;
                    case 'line_random':
                         for(let i = 0; i < attack.count; i++) {
                            let pos, vel;
                            const from = attack.from === 'all' ? ['top', 'bottom', 'left', 'right'][i % 4] : attack.from;
                            if (from === 'top') { pos = { x: CRISOL_ARENA.x + Math.random() * CRISOL_ARENA.width, y: CRISOL_ARENA.y - 20 }; vel = { x: 0, y: speed }; } 
                            else if (from === 'bottom') { pos = { x: CRISOL_ARENA.x + Math.random() * CRISOL_ARENA.width, y: CRISOL_ARENA.y + CRISOL_ARENA.height + 20 }; vel = { x: 0, y: -speed }; } 
                            else if (from === 'left') { pos = { x: CRISOL_ARENA.x - 20, y: CRISOL_ARENA.y + Math.random() * CRISOL_ARENA.height }; vel = { x: speed, y: 0 }; } 
                            else if (from === 'right') { pos = { x: CRISOL_ARENA.x + CRISOL_ARENA.width + 20, y: CRISOL_ARENA.y + Math.random() * CRISOL_ARENA.height }; vel = { x: -speed, y: 0 }; }
                            if(pos) newProjectiles.push({ id: `p-${now}-randline-${i}`, position: pos, velocity: vel, ...projType });
                        }
                        break;
                    case 'drifting_line':
                         const driftDirection = attack.alternate ? (callCount % 2 === 0 ? 1 : -1) : 1;
                        const driftSpeed = (attack.driftSpeed || 0) * driftDirection;
                        const spacing = attack.spacing || 60;
                        if (attack.from === 'top' || attack.from === 'bottom') {
                            const startY = attack.from === 'top' ? CRISOL_ARENA.y - 20 : CRISOL_ARENA.y + CRISOL_ARENA.height + 20;
                            const mainSpeed = attack.from === 'top' ? speed : -speed;
                            for (let currentX = CRISOL_ARENA.x; currentX <= CRISOL_ARENA.x + CRISOL_ARENA.width; currentX += spacing) {
                                newProjectiles.push({ id: `p-${now}-dvert-${currentX}`, position: { x: currentX, y: startY }, velocity: { x: driftSpeed, y: mainSpeed }, ...projType });
                            }
                        } else {
                            const startX = attack.from === 'left' ? CRISOL_ARENA.x - 20 : CRISOL_ARENA.x + CRISOL_ARENA.width + 20;
                            const mainSpeed = attack.from === 'left' ? speed : -speed;
                             for (let currentY = CRISOL_ARENA.y; currentY <= CRISOL_ARENA.y + CRISOL_ARENA.height; currentY += spacing) {
                                newProjectiles.push({ id: `p-${now}-dhoriz-${currentY}`, position: { x: startX, y: currentY }, velocity: { x: mainSpeed, y: driftSpeed }, ...projType });
                            }
                        }
                        break;
                    case 'pulse':
                        for (let i = 0; i < attack.count; i++) {
                            const angle = (i / attack.count) * Math.PI * 2;
                            const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            newProjectiles.push({ id: `p-${now}-pulse-${i}`, position: {x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY}, velocity: vel, ...projType });
                        }
                        break;
                    case 'spiral':
                        const armSpacing = (Math.PI * 2) / attack.numArms;
                        for (let i = 0; i < attack.projectilesPerArm; i++) {
                            setTimeout(() => {
                                setGameState(prev => {
                                    if (prev.isPaused || prev.isPausedBetweenSequences) return prev;
                                    const newProj = [];
                                    const rotation = i * attack.rotationSpeed;
                                    for (let j = 0; j < attack.numArms; j++) {
                                        const angle = j * armSpacing + rotation;
                                        const vel = { x: Math.cos(angle) * attack.speed, y: Math.sin(angle) * attack.speed };
                                        newProj.push({ id: `p-spiral-${now}-${i}-${j}`, position: {x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY}, velocity: vel, ...projType });
                                    }
                                    return { ...prev, projectiles: [...prev.projectiles, ...newProj] };
                                });
                            }, i * 50);
                        }
                        break;
                    case 'ricochet':
                         for (let i = 0; i < attack.count; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            newProjectiles.push({ id: `p-${now}-rico-${i}`, position: {x: CRISOL_ARENA.centerX, y: CRISOL_ARENA.centerY}, velocity: vel, ...projType, bounces: attack.bounces || 4 });
                         }
                        break;
                    case 'wave':
                         for (let i = 0; i < attack.count; i++) {
                             let pos, vel;
                             if(attack.from === 'left' || attack.from === 'right') {
                                pos = { x: attack.from === 'left' ? CRISOL_ARENA.x - 20 : CRISOL_ARENA.x + CRISOL_ARENA.width + 20, y: CRISOL_ARENA.y + (CRISOL_ARENA.height / attack.count) * i };
                                vel = { x: (attack.from === 'left' ? 1 : -1) * speed, y: 0 };
                             } else {
                                pos = { x: CRISOL_ARENA.x + (CRISOL_ARENA.width / attack.count) * i, y: attack.from === 'top' ? CRISOL_ARENA.y - 20 : CRISOL_ARENA.y + CRISOL_ARENA.height + 20 };
                                vel = { x: 0, y: (attack.from === 'top' ? 1 : -1) * speed };
                             }
                             newProjectiles.push({ id: `p-${now}-wave-${i}`, position: pos, velocity: vel, ...projType, wave: { amplitude: attack.amplitude, frequency: attack.frequency, initialPos: {...pos} } });
                         }
                        break;
                    case 'shrinking_prison':
                        const prisonPadding = 80;
                        const prison = { x: Math.max(CRISOL_ARENA.x + prisonPadding, playerPos.x - 200), y: Math.max(CRISOL_ARENA.y + prisonPadding, playerPos.y - 200), width: 400, height: 400, };
                        const gapSize = 100;
                        const gapSide = Math.floor(Math.random() * 4);
                        const spawnWallSegment = (p, v) => newProjectiles.push({ id: `p-prison-${p.x}-${p.y}-${now}`, position: p, velocity: v, ...projType, life: attack.holdTime + 1000 });
                        for (let x = prison.x; x <= prison.x + prison.width; x += projType.size * 1.5) {
                            if (gapSide !== 0 || x < prison.x + prison.width/2 - gapSize/2 || x > prison.x + prison.width/2 + gapSize/2) spawnWallSegment({x, y: prison.y}, {x:0, y:speed});
                            if (gapSide !== 2 || x < prison.x + prison.width/2 - gapSize/2 || x > prison.x + prison.width/2 + gapSize/2) spawnWallSegment({x, y: prison.y + prison.height}, {x:0, y:-speed});
                        }
                        for (let y = prison.y; y <= prison.y + prison.height; y += projType.size * 1.5) {
                            if (gapSide !== 3 || y < prison.y + prison.height/2 - gapSize/2 || y > prison.y + prison.height/2 + gapSize/2) spawnWallSegment({x: prison.x, y}, {x:speed, y:0});
                            if (gapSide !== 1 || y < prison.y + prison.height/2 - gapSize/2 || y > prison.y + prison.height/2 + gapSize/2) spawnWallSegment({x: prison.x + prison.width, y}, {x:-speed, y:0});
                        }
                        break;
                    case 'crystal_matrix':
                        const { rows: cRows, cols: cCols } = attack;
                        const cellWidth = CRISOL_ARENA.width / cCols;
                        const cellHeight = CRISOL_ARENA.height / cRows;
                        for(let r=0; r<cRows; r++){ for(let c=0; c<cCols; c++){ if(Math.random() > 0.35) {
                            const pos = { x: CRISOL_ARENA.x + c * cellWidth + cellWidth/2, y: CRISOL_ARENA.y + r * cellHeight + cellHeight/2 };
                            newProjectiles.push({ id: `p-crystal-${now}-${r}-${c}`, position: pos, velocity: {x:0, y:0}, ...projType, life: attack.holdTime, isStatic: true });
                        }}}
                        break;
                    case 'sweep_beam':
                        const beamWidth = 40;
                        const isHorizontal = attack.from === 'top' || attack.from === 'bottom';
                        newEffects.push({ id: `beam-${now}`, type: 'sweep_beam', from: attack.from, speed: attack.speed, width: beamWidth, startTime: now, duration: (isHorizontal ? CRISOL_ARENA.height / attack.speed : CRISOL_ARENA.width / attack.speed) * 1000 + 500, ...CRISOL_PROJECTILE_TYPES.BEAM, });
                        break;
                    case 'homing':
                        for (let i = 0; i < attack.count; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const spawnDist = 450;
                            const pos = { x: CRISOL_ARENA.centerX + Math.cos(angle) * spawnDist, y: CRISOL_ARENA.centerY + Math.sin(angle) * spawnDist };
                            newProjectiles.push({ id: `p-homing-${now}-${i}`, position: pos, velocity: {x:0, y:0}, ...projType, speed: attack.speed });
                        }
                        break;
                    case 'snipe':
                        newEffects.push({ id: `snipe-warn-${now}`, type: 'line_warning', start: {x: playerPos.x, y: CRISOL_ARENA.y}, end: {x: playerPos.x, y: CRISOL_ARENA.y + CRISOL_ARENA.height}, life: attack.delay });
                        newEffects.push({ id: `snipe-warn-h-${now}`, type: 'line_warning', start: {x: CRISOL_ARENA.x, y: playerPos.y}, end: {x: CRISOL_ARENA.x + CRISOL_ARENA.width, y: playerPos.y}, life: attack.delay });
                        setTimeout(() => {
                            setGameState(prev => {
                                if (prev.isPaused || prev.isPausedBetweenSequences) return prev;
                                const lastKnownPlayerPos = playerPos;
                                const newProj = [];
                                newProj.push({ id: `p-snipe-v-${now}`, position: {x: lastKnownPlayerPos.x, y: CRISOL_ARENA.y - 20}, velocity: {x: 0, y: attack.speed}, ...projType });
                                newProj.push({ id: `p-snipe-h-${now}`, position: {x: CRISOL_ARENA.x - 20, y: lastKnownPlayerPos.y}, velocity: {x: attack.speed, y: 0}, ...projType });
                                return { ...prev, projectiles: [...prev.projectiles, ...newProj] };
                            });
                        }, attack.delay);
                        break;

                    // --- NOVOS CASES PARA ATAQUES DE DESVIO PURO (REFORMULA√á√ÉO) ---
                    case 'segment_swarm':
                        for(let i=0; i < attack.numSegments; i++) {
                            const angleToPlayer = Math.atan2(playerPos.y - CRISOL_ARENA.centerY, playerPos.x - CRISOL_ARENA.centerX) + (Math.random() - 0.5) * 2;
                            const spawnRadius = 500;
                            const basePos = { x: CRISOL_ARENA.centerX + Math.cos(angleToPlayer) * spawnRadius, y: CRISOL_ARENA.centerY + Math.sin(angleToPlayer) * spawnRadius };
                            const dir = normalizeVector({ x: playerPos.x - basePos.x, y: playerPos.y - basePos.y });
                            const perpDir = { x: -dir.y, y: dir.x };
                            for(let j=0; j < attack.length; j++) {
                                const offset = (j - Math.floor(attack.length / 2)) * (projType.size * 1.5);
                                newProjectiles.push({ id: `p-segswarm-${now}-${i}-${j}`, position: { x: basePos.x + perpDir.x * offset, y: basePos.y + perpDir.y * offset }, velocity: { x: dir.x * speed, y: dir.y * speed }, ...projType });
                            }
                        }
                        break;
                    case 'segment_cutter':
                        const isHorizontalCutter = Math.random() > 0.5;
                        const startEdgeCutter = isHorizontalCutter ? (Math.random() > 0.5 ? CRISOL_ARENA.x - 20 : CRISOL_ARENA.x + CRISOL_ARENA.width + 20) : (Math.random() > 0.5 ? CRISOL_ARENA.y - 20 : CRISOL_ARENA.y + CRISOL_ARENA.height + 20);
                        const startCrossCutter = isHorizontalCutter ? Math.random() * CRISOL_ARENA.height + CRISOL_ARENA.y : Math.random() * CRISOL_ARENA.width + CRISOL_ARENA.x;
                        const velCutter = isHorizontalCutter ? { x: startEdgeCutter < CRISOL_ARENA.centerX ? speed : -speed, y: 0 } : { x: 0, y: startEdgeCutter < CRISOL_ARENA.centerY ? speed : -speed };
                        for(let i=0; i < attack.length; i++) {
                            const pos = isHorizontalCutter ? { x: startEdgeCutter, y: startCrossCutter + (i - Math.floor(attack.length / 2)) * (projType.size * 1.5) } : { x: startCrossCutter + (i - Math.floor(attack.length / 2)) * (projType.size * 1.5), y: startEdgeCutter };
                            newProjectiles.push({ id: `p-segcut-${now}-${i}`, position: pos, velocity: velCutter, ...projType });
                        }
                        break;
                    case 'echo_maze':
                        const { rows: mazeRows, cols: mazeCols, warningTime: mazeWarningTime, projectileLifetime: mazeLifetime } = attack;
                        const mazeCellWidth = CRISOL_ARENA.width / mazeCols;
                        const mazeCellHeight = CRISOL_ARENA.height / mazeRows;
                        const mazeGrid = Array(mazeRows).fill(null).map(() => Array(mazeCols).fill(true));
                        let mazeCurrent = { r: Math.floor(Math.random() * mazeRows), c: Math.floor(Math.random() * mazeCols) };
                        const mazeStack = [mazeCurrent];
                        mazeGrid[mazeCurrent.r][mazeCurrent.c] = false;
                        while(mazeStack.length > 0) {
                            mazeCurrent = mazeStack[mazeStack.length - 1];
                            const neighbors = [];
                            const {r, c} = mazeCurrent;
                            if (r > 1 && mazeGrid[r-2][c]) neighbors.push({r: r-2, c: c, wall: {r: r-1, c: c}});
                            if (r < mazeRows - 2 && mazeGrid[r+2][c]) neighbors.push({r: r+2, c: c, wall: {r: r+1, c: c}});
                            if (c > 1 && mazeGrid[r][c-2]) neighbors.push({r: r, c: c-2, wall: {r: r, c: c-1}});
                            if (c < mazeCols - 2 && mazeGrid[r][c+2]) neighbors.push({r: r, c: c+2, wall: {r: r, c: c+1}});
                            if (neighbors.length > 0) { const next = neighbors[Math.floor(Math.random() * neighbors.length)]; mazeGrid[next.wall.r][next.wall.c] = false; mazeGrid[next.r][next.c] = false; mazeStack.push({r: next.r, c: next.c}); } 
                            else { mazeStack.pop(); }
                        }
                        for(let r=0; r<mazeRows; r++) { for(let c=0; c<mazeCols; c++) { if (mazeGrid[r][c]) {
                            newEffects.push({ id: `maze-warn-${now}-${r}-${c}`, type: 'zone_warning', rect: { x: CRISOL_ARENA.x + c * mazeCellWidth, y: CRISOL_ARENA.y + r * mazeCellHeight, width: mazeCellWidth, height: mazeCellHeight }, life: mazeWarningTime, color: 'rgba(255, 100, 0, 0.4)' });
                        }}}
                        setTimeout(() => { setGameState(prev => { if (prev.isPaused || prev.isPausedBetweenSequences) return prev; const newProj = [];
                            for(let r=0; r<mazeRows; r++) { for(let c=0; c<mazeCols; c++) { if (mazeGrid[r][c]) {
                                newProj.push({ id: `p-maze-${now}-${r}-${c}`, position: { x: CRISOL_ARENA.x + c * mazeCellWidth + mazeCellWidth/2, y: CRISOL_ARENA.y + r * mazeCellHeight + mazeCellHeight/2 }, velocity: {x:0, y:0}, ...projType, life: mazeLifetime, isStatic: true });
                            }}} return { ...prev, projectiles: [...prev.projectiles, ...newProj] }; });
                        }, mazeWarningTime);
                        break;
                    case 'wandering_pulse':
                        const emitterPos = { x: CRISOL_ARENA.x + Math.random() * CRISOL_ARENA.width, y: CRISOL_ARENA.y + Math.random() * CRISOL_ARENA.height };
                        newEffects.push({ id: `emitter-${now}`, type: 'emitter_marker', position: emitterPos, life: 3000, color: 'rgba(255, 255, 0, 0.8)' });
                        for (let i = 0; i < attack.count; i++) {
                            const angle = (i / attack.count) * Math.PI * 2;
                            const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            newProjectiles.push({ id: `p-wandering-${now}-${i}`, position: emitterPos, velocity: vel, ...projType });
                        }
                        break;
                    case 'matrix_corruption':
                        const { rows: mRows, cols: mCols, speed: mSpeed, turnDelay } = attack;
                        const xStep = CRISOL_ARENA.width / (mCols + 1);
                        for(let r=0; r<mRows; r++) {
                            const vel = { x: 0, y: mSpeed };
                            newProjectiles.push({ id: `p-matrix-${now}-${r}`, position: { x: CRISOL_ARENA.x + (r + 1) * xStep, y: CRISOL_ARENA.y - 20 }, velocity: vel, ...projType, color: '#f39c12', special: { type: 'matrix_corruption', turnDelay: now + turnDelay }, baseSpeed: mSpeed });
                        }
                        break;
                }
                return { newProjectiles, newEffects };
            }, [setGameState]);

            //gametick come√ßa aqui

            const gameTick = useCallback((deltaTime) => {
                setGameState(prev => {
                    if (!prev.mode || prev.isPaused) return prev;
                    const newState = JSON.parse(JSON.stringify(prev));
                    const now = Date.now();
                    const { player, projectiles, keys, visualEffects } = newState;

                    if (newState.isPausedBetweenSequences) {
                        if (now >= newState.pauseEndTime) newState.isPausedBetweenSequences = false;
                        return newState;
                    }
                    
                    if (keys[' '] && !player.isDashing && now > player.dashCooldownUntil) {
                        player.isDashing = true; player.dashEndTime = now + DASH_STATS.DURATION; player.dashCooldownUntil = now + DASH_STATS.COOLDOWN * 0.8;
                        const moveDir = normalizeVector({ x: (keys.d ? 1:0) - (keys.a ? 1:0), y: (keys.s ? 1:0) - (keys.w ? 1:0) });
                        player.dashDirection = (moveDir.x === 0 && moveDir.y === 0) ? player.lastMoveDirection : moveDir;
                        SoundManager.play('playerDash');
                    }
                    if (player.isDashing) {
                        if (now > player.dashEndTime) player.isDashing = false;
                        else {
                            player.position.x += player.dashDirection.x * player.speed * DASH_STATS.SPEED_MULTIPLIER * deltaTime;
                            player.position.y += player.dashDirection.y * player.speed * DASH_STATS.SPEED_MULTIPLIER * deltaTime;
                        }
                    } else if (keys.w || keys.a || keys.s || keys.d) {
                        const norm = normalizeVector({x: (keys.d ? 1:0) - (keys.a ? 1:0), y: (keys.s ? 1:0) - (keys.w ? 1:0)});
                        player.lastMoveDirection = norm;
                        player.position.x += norm.x * player.speed * deltaTime;
                        player.position.y += norm.y * player.speed * deltaTime;
                    }
                    player.position.x = Math.max(CRISOL_ARENA.x + player.size / 2, Math.min(CRISOL_ARENA.x + CRISOL_ARENA.width - player.size / 2, player.position.x));
                    player.position.y = Math.max(CRISOL_ARENA.y + player.size / 2, Math.min(CRISOL_ARENA.y + CRISOL_ARENA.height - player.size / 2, player.position.y));

                    if (newState.mode === 'chamber') {
                        newState.gameTime += deltaTime;
                        newState.sequenceTime += deltaTime * 1000;
                        const currentSequence = chamberDataRef.current.sequences[newState.sequenceIndex];
                        
                        if (currentSequence) {
                            currentSequence.attacks.forEach((attack, index) => {
                                const attackState = newState.activeAttacks[index] || { lastSpawnTime: 0, callCount: 0 };
                                if (newState.sequenceTime >= attack.startTime && now - attackState.lastSpawnTime > attack.interval) {
                                    const projType = CRISOL_PROJECTILE_TYPES[attack.projectile];
                                    const { newProjectiles, newEffects } = spawnProjectiles(attack, projType, now, player.position, attackState.callCount);
                                    projectiles.push(...newProjectiles);
                                    visualEffects.push(...newEffects);
                                    newState.activeAttacks[index] = { lastSpawnTime: now, callCount: attackState.callCount + 1 };
                                }
                            });
                        }

                        projectiles.forEach(p => { 
                            if (!p.isStatic) {
                                if (p.isHoming) {
                                    const dirToPlayer = normalizeVector({ x: player.position.x - p.position.x, y: player.position.y - p.position.y });
                                    const homingForce = p.homingStrength || 0.03;
                                    p.velocity.x = p.velocity.x * (1 - homingForce) + (dirToPlayer.x * p.speed * homingForce);
                                    p.velocity.y = p.velocity.y * (1 - homingForce) + (dirToPlayer.y * p.speed * homingForce);
                                    const currentSpeed = Math.sqrt(p.velocity.x**2 + p.velocity.y**2);
                                    if (currentSpeed > p.speed) { p.velocity.x = (p.velocity.x / currentSpeed) * p.speed; p.velocity.y = (p.velocity.y / currentSpeed) * p.speed; }
                                }
                                if (p.special?.type === 'matrix_corruption' && now > p.special.turnDelay) {
                                    const originalSpeed = p.baseSpeed;
                                    const oldVelX = p.velocity.x;
                                    p.velocity.x = 0;
                                    p.velocity.y = (oldVelX !== 0 ? Math.sign(oldVelX) : 1) * originalSpeed; // Vira para baixo ou para cima
                                    p.color = '#e74c3c';
                                    p.special = null;
                                }
                                p.position.x += p.velocity.x * deltaTime;
                                p.position.y += p.velocity.y * deltaTime;
                            }
                            if (p.life) p.life -= deltaTime * 1000;
                            if (p.lifetime) p.lifetime -= deltaTime * 1000;
                            if (p.bounces > 0) {
                               if ((p.position.x <= CRISOL_ARENA.x && p.velocity.x < 0) || (p.position.x >= CRISOL_ARENA.x + CRISOL_ARENA.width && p.velocity.x > 0)) { p.velocity.x *= -1; p.bounces--; }
                               if ((p.position.y <= CRISOL_ARENA.y && p.velocity.y < 0) || (p.position.y >= CRISOL_ARENA.y + CRISOL_ARENA.height && p.velocity.y > 0)) { p.velocity.y *= -1; p.bounces--; }
                            }
                            if (p.wave) {
                               if(p.velocity.x !== 0) { p.position.y = p.wave.initialPos.y + Math.sin((p.position.x - p.wave.initialPos.x) * p.wave.frequency) * p.wave.amplitude; }
                               else { p.position.x = p.wave.initialPos.x + Math.sin((p.position.y - p.wave.initialPos.y) * p.wave.frequency) * p.wave.amplitude; }
                            }
                        });
                        
                        newState.projectiles = projectiles.filter(p => {
                            const padding = p.size / 2 + 5; 
                            if (p.position.x < CRISOL_ARENA.x - padding && p.velocity.x < 0) return false;
                            if (p.position.x > CRISOL_ARENA.x + CRISOL_ARENA.width + padding && p.velocity.x > 0) return false;
                            if (p.position.y < CRISOL_ARENA.y - padding && p.velocity.y < 0) return false;
                            if (p.position.y > CRISOL_ARENA.y + CRISOL_ARENA.height + padding && p.velocity.y > 0) return false;
                            if (p.life && p.life <= 0) return false;
                            if (p.lifetime && p.lifetime <= 0) return false;
                            return true;
                        });
                        
                        newState.visualEffects.forEach(e => e.life -= deltaTime * 1000);
                        newState.visualEffects = visualEffects.filter(e => e.life > 0);

                        if (!player.isDashing && now - player.lastHitTime > 500) {
                            for (const p of projectiles) {
                                if (calculateDistance(p.position, player.position) < p.size/2 + player.size/2) {
                                    SoundManager.play('playerHit');
                                    player.lives--;
                                    player.lastHitTime = now;
                                    if (player.lives <= 0) { onGameOver({ victory: false, chamberId: newState.chamberId }); }
                                    break;
                                }
                            }
                        }

                        if (currentSequence && newState.sequenceTime >= currentSequence.duration) {
                            newState.sequenceIndex++;
                            newState.sequenceTime = 0;
                            player.lives = CRISOL_PLAYER_STATS.lives;
                            
                            if (newState.sequenceIndex >= chamberDataRef.current.sequences.length) {
                                onGameOver({ victory: true, chamberId: newState.chamberId });
                            } else {
                                newState.isPausedBetweenSequences = true;
                                newState.pauseEndTime = now + 3000;
                                newState.projectiles = [];
                                newState.visualEffects = [];
                                newState.activeAttacks = {};
                            }
                        }
                    }
                    return newState;
                });
            }, [onGameOver, spawnProjectiles]);
            
            return { gameState, handleKeys, startChamber, startInfinite, gameTick, pauseGame, resumeGame };
        };
        // --- END OF hooks/useCrisolEngine.ts ---

        // --- START OF hooks/useChat.ts ---
        const useChat = (username, userId) => {
            const [messages, setMessages] = React.useState([]);
            const [error, setError] = React.useState(null);

            // Fun√ß√£o para buscar as mensagens iniciais
            const fetchInitialMessages = React.useCallback(async () => {
                try {
                    const { data, error } = await supabase
                        .from('chat_messages')
                        .select('*')
                        .order('created_at', { ascending: false })
                        .limit(50);

                    if (error) throw error;
                    // Invertemos para que as mais antigas fiquem em cima
                    setMessages(data.reverse());
                } catch (err) {
                    console.error("Erro ao buscar mensagens do chat:", err);
                    setError("N√£o foi poss√≠vel carregar o hist√≥rico do chat.");
                }
            }, []);

            // Configura a subscri√ß√£o em tempo real
            React.useEffect(() => {
                fetchInitialMessages();

                const channel = supabase.channel('public:chat_messages')
                    .on(
                        'postgres_changes',
                        { event: 'INSERT', schema: 'public', table: 'chat_messages' },
                        (payload) => {
                            setMessages(currentMessages => [...currentMessages, payload.new]);
                        }
                    )
                    .subscribe((status, err) => {
                        if (err) {
                            console.error("Erro na subscri√ß√£o do chat:", err);
                            setError("Desconectado do chat.");
                        }
                    });
                
                // Limpeza ao desmontar o componente
                return () => {
                    supabase.removeChannel(channel);
                };
            }, [fetchInitialMessages]);

            // Fun√ß√£o para enviar uma nova mensagem
            const sendMessage = async (content) => {
                if (!content.trim()) return;

                const { error } = await supabase
                    .from('chat_messages')
                    .insert({ content: content.trim(), username, user_id: userId });

                if (error) {
                    console.error("Erro ao enviar mensagem:", error);
                    setError("Falha ao enviar mensagem.");
                }
            };

            return { messages, sendMessage, error };
        };
        // --- END OF hooks/useChat.ts ---

        // --- NOVO: Fun√ß√µes de Desenho para Inimigos da Fase 4 ---
        function drawRecursiveProcess(ctx, enemy, time) {
            const pulse = Math.sin(time / 400) * 0.1;
            const size = enemy.size * (1 + pulse);
            ctx.save();
            ctx.translate(enemy.position.x, enemy.position.y);
            // Orbitais
            for (let i = 0; i < 3; i++) {
                const angle = (time / 800) + (i * (Math.PI * 2 / 3));
                const orbitRadius = size * 0.8;
                ctx.fillStyle = 'rgba(251, 146, 60, 0.5)';
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * orbitRadius, Math.sin(angle) * orbitRadius, size * 0.15, 0, Math.PI * 2);
                ctx.fill();
            }
            // N√∫cleo
            ctx.fillStyle = enemy.color;
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(0, -size / 2);
            for (let i = 1; i < 6; i++) {
                const angle = i * (Math.PI * 2 / 6);
                ctx.lineTo(size/2 * Math.cos(angle - Math.PI/2), size/2 * Math.sin(angle - Math.PI/2));
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawChildProcess(ctx, enemy, time) {
            ctx.save();
            ctx.translate(enemy.position.x, enemy.position.y);
            // Rastro de glitch
            if (!enemy.trail) enemy.trail = [];
            enemy.trail.push({x: 0, y: 0});
            if (enemy.trail.length > 5) enemy.trail.shift();
            enemy.trail.forEach((p, i) => {
                ctx.globalAlpha = (i / enemy.trail.length) * 0.5;
                ctx.fillStyle = GAME_COLORS.DATA_FLOW_MAGENTA;
                ctx.fillRect(p.x - enemy.size/2 + (Math.random()-0.5)*4, p.y - enemy.size/2 + (Math.random()-0.5)*4, enemy.size, enemy.size);
            });
            // Corpo principal
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = enemy.color;
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 10;
            ctx.fillRect(-enemy.size/2 + (Math.random()-0.5)*2, -enemy.size/2 + (Math.random()-0.5)*2, enemy.size, enemy.size);
            ctx.restore();
        }
        
        function drawRogueFirewall(ctx, enemy, time) {
            const segments = 6;
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.save();
            ctx.translate(enemy.position.x, enemy.position.y);
            for (let i = 0; i < segments; i++) {
                if (Math.random() > healthPercent * 0.8) continue; // Segmentos falham com dano
                const angle = (i * (Math.PI * 2 / segments)) + time/5000;
                const nextAngle = ((i + 1) * (Math.PI * 2 / segments)) + time/5000;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(enemy.size * Math.cos(angle), enemy.size * Math.sin(angle));
                ctx.lineTo(enemy.size * Math.cos(nextAngle), enemy.size * Math.sin(nextAngle));
                ctx.closePath();
                ctx.fillStyle = `rgba(234, 179, 8, ${0.4 + Math.sin(angle + time/200)*0.2})`;
                ctx.fill();
            }
            ctx.strokeStyle = enemy.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.size * 0.3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        // --- FIM DAS FUN√á√ïES DE DESENHO ---

        const ENEMY_DEFAULT_STATS = {
            size: 15, baseSpeed: 75, health: 17, damage: 10, expValue: 30, type: EnemyType.DEFAULT, color: GAME_COLORS.ENEMY_DEFAULT, isConvertible: true
        };
        const ENEMY_MEMORY_LEAK_STATS = {
            size: 18, baseSpeed: 65, health: 30, damage: 12, expValue: 40, type: EnemyType.MEMORY_LEAK, color: GAME_COLORS.ENEMY_MEMORY_LEAK,
            trailDropInterval: 200, trailDamage: 2, trailLifetime: 3000, trailSize: 8, isConvertible: true,
        };
        const ENEMY_SPYWARE_STATS = {
            size: 14, baseSpeed: 90, health: 25, damage: 8, expValue: 35, type: EnemyType.SPYWARE, color: GAME_COLORS.ENEMY_SPYWARE,
            invisibilityDuration: 3000, visibilityDuration: 3000, isConvertible: true,
        };
        const ENEMY_TROJAN_HORSE_STATS = {
            size: 35, baseSpeed: 40, health: 120, damage: 20, expValue: 75, type: EnemyType.TROJAN_HORSE, color: GAME_COLORS.ENEMY_TROJAN,
            fragmentsToSpawn: 3, isConvertible: false,
        };
        const ENEMY_MALWARE_FRAGMENT_STATS = {
            size: 10, baseSpeed: 80, health: 10, damage: 5, expValue: 5, type: EnemyType.MALWARE_FRAGMENT, color: GAME_COLORS.ENEMY_DEFAULT, isConvertible: false,
        };
        const ENEMY_ROOTKIT_STATS = {
            size: 20, baseSpeed: 100, health: 85, damage: 25, expValue: 100, type: EnemyType.ROOTKIT, color: GAME_COLORS.ENEMY_ROOTKIT, isConvertible: false,
        };
        const ENEMY_DDOS_BOT_STATS = {
            size: 12, baseSpeed: 150, health: 16, damage: 7, expValue: 20, type: EnemyType.DDOS_BOT, color: GAME_COLORS.ENEMY_DDOS_BOT,
            swarmCount: 3, isConvertible: true,
        };
        const GLITCH_MINION_STATS = {
            size: 10, baseSpeed: 130, health: 20, damage: 8, expValue: 8, type: EnemyType.GLITCH_MINION, color: GAME_COLORS.ENEMY_GLITCH_MINION, isConvertible: false
        };

        const ENEMY_PROCESSO_CORROMPIDO_STATS = {
            size: 16, baseSpeed: 110, health: 28, damage: 12, expValue: 45, type: EnemyType.PROCESSO_CORROMPIDO, color: GAME_COLORS.ENEMY_PROCESSO_CORROMPIDO, isConvertible: true
        };
        const ENEMY_PONTEIRO_NULO_STATS = {
            size: 18, baseSpeed: 70, health: 45, damage: 18, expValue: 70, type: EnemyType.PONTEIRO_NULO, color: GAME_COLORS.ENEMY_PONTEIRO_NULO,
            teleportChargeTime: 1500, teleportCooldown: 4000, isConvertible: true
        };
        const ENEMY_SEGMENTO_FALHA_STATS = {
            size: 28, baseSpeed: 50, health: 130, damage: 22, expValue: 120, type: EnemyType.SEGMENTO_FALHA, color: GAME_COLORS.ENEMY_SEGMENTO_FALHA,
            shieldDuration: 3000, shieldCooldown: 5000, shieldDamageReduction: 0.8, isConvertible: false
        };
        const ENEMY_PROCESSO_ZUMBI_STATS = {
            size: 22, baseSpeed: 45, health: 160, damage: 15, expValue: 100, type: EnemyType.PROCESSO_ZUMBI, color: GAME_COLORS.ENEMY_PROCESSO_ZUMBI,
            reviveChance: 0.40, reviveTime: 3000, reviveHealthFactor: 0.5, isConvertible: false
        };

        const ENEMY_NANITE_STATS = {
            size: 12, baseSpeed: 120, health: 50, damage: 15, expValue: 60, type: EnemyType.NANITE, color: GAME_COLORS.ENEMY_NANITE, isConvertible: true
        };
        const ENEMY_HEATSINK_STATS = {
            size: 30, baseSpeed: 30, health: 160, damage: 20, expValue: 90, type: EnemyType.HEATSINK, color: GAME_COLORS.ENEMY_HEATSINK, pulseInterval: 2500, isConvertible: false
        };
        const ENEMY_IO_CONTROLLER_STATS = {
            size: 20, baseSpeed: 60, health: 90, damage: 18, expValue: 80, type: EnemyType.IO_CONTROLLER, color: GAME_COLORS.ENEMY_IO_CONTROLLER, fireRate: 3000, projectileSpeed: 200, projectileSize: 8, spread: 20, isConvertible: false
        };
        const ENEMY_VOLATILE_PROCESS_STATS = {
            size: 50, baseSpeed: 80, health: 190, damage: 0, expValue: 100, type: EnemyType.VOLATILE_PROCESS, color: GAME_COLORS.ENEMY_VOLATILE_PROCESS, fuseTime: 8000, explosionDamage: 60, explosionRadius: 100, isConvertible: false
        };

        // --- FASE 4 INIMIGOS (NOVO) ---
        const ENEMY_RECURSIVE_PROCESS_STATS = {
            size: 22, baseSpeed: 80, health: 120, damage: 25, expValue: 0, // XP √© dado pelos filhos
            type: EnemyType.RECURSIVE_PROCESS, color: GAME_COLORS.ENEMY_RECURSIVE_PROCESS, isConvertible: true
        };
        const ENEMY_CHILD_PROCESS_STATS = {
            size: 12, baseSpeed: 190, health: 35, damage: 12, expValue: 40, // Cada filho d√° XP
            type: EnemyType.CHILD_PROCESS, color: GAME_COLORS.ENEMY_CHILD_PROCESS, isConvertible: false
        };
        const ENEMY_ROGUE_FIREWALL_STATS = {
            size: 60, baseSpeed: 40, health: 300, damage: 25, expValue: 150, 
            type: EnemyType.ROGUE_FIREWALL, color: GAME_COLORS.ENEMY_ROGUE_FIREWALL, isConvertible: false, projectileBlockHealth: 100
        };
        const ENEMY_LATENCY_SPIKE_STATS = {
            size: 25, baseSpeed: 70, health: 150, damage: 10, expValue: 120, 
            type: EnemyType.LATENCY_SPIKE, color: GAME_COLORS.ENEMY_LATENCY_SPIKE, isConvertible: false, slowAuraRadius: 180, slowMagnitude: 0.4
        };
        const ENEMY_PROTOCOL_ANOMALY_STATS = {
            size: 28, baseSpeed: 90, health: 250, damage: 30, expValue: 200, 
            type: EnemyType.PROTOCOL_ANOMALY, color: GAME_COLORS.ENEMY_PROTOCOL_ANOMALY, isConvertible: false, protocolSwitchInterval: 8000
        };

        const ENEMY_SPAWN_TIMES = {
            [EnemyType.MEMORY_LEAK]: 60,
            [EnemyType.SPYWARE]: 120,
            [EnemyType.TROJAN_HORSE]: 180,
            [EnemyType.ROOTKIT]: 240,
            [EnemyType.DDOS_BOT]: 300,
        };
        
        const BOSS_TRIGGER_TIME = 420;
        const BOSS_2_TRIGGER_TIME = 780;
        const BOSS_3_TRIGGER_TIME = 1140;
        const BOSS_4_TRIGGER_TIME = 1500; // --- NOVO --- (25 minutos)

        const BOSS_WARNING_DURATION = 4500;

        const BOSS_PHASE_HEALTH_THRESHOLDS = {
            PHASE_2: 0.70,
            PHASE_3: 0.35,
        };

        const BOSS_STATS = {
            size: 60, coreSize: 25, maxHealth: 5000, damage: 30, speed: 135,
            projectilePhase1Speed: 150, projectilePhase1Size: 30, projectilePhase1Damage: 20, projectilePhase1FireRate: 1500,
            projectilePhase2Speed: 200, projectilePhase2Size: 10, projectilePhase2Damage: 15, projectilePhase2FireRate: 1200, projectilePhase2BurstCount: 3, projectilePhase2BurstInterval: 100,
            pulseAttackCooldown: 5000, pulseAttackRadius: 180, pulseAttackForce: 300,
            corruptedZoneInterval: 5000, corruptedZoneRadius: 90, corruptedZoneDuration: 4000, corruptedZoneDamage: 5, corruptedZoneDamageInterval: 250, 
            glitchMinionSpawnInterval: 7000, glitchMinionSpawnCount: 6,
            dataStreamBarrageInterval: 3000, dataStreamProjectileCount: 12, dataStreamProjectileSize: 7, dataStreamProjectileSpeed: 280, dataStreamProjectileDamage: 10,
            kernelPanicPulseChargeTime: 2500, kernelPanicPulseRadius: 300, kernelPanicPulseDamage: 50, kernelPanicPulseCooldown: 10000, 
        };

        const BOSS_SHIELD_NODE_STATS = {
            count: 3, size: 20, orbitRadius: 100, orbitSpeed: 0.02, maxHealth: 250, color: GAME_COLORS.BOSS_SHIELD_NODE,
        };
        
        const BOSS_2_STATS = {
            size: 70, maxHealth: 9000, damage: 40, 
            phase1EnergyWaveInterval: 4000, phase1EnergyWaveDamage: 15, phase1EnergyWaveRadius: 250,
            phase2HealthThreshold: 1.0, 
            phase3HealthThreshold: 0.40,
            laserChargeTime: 1200, laserFireDuration: 1800, laserDamage: 25, laserWidth: 30, laserRotationSpeed: 0.02, laserCooldown: 8000,
            dataWallSpawnInterval: 6000, dataWallSpeed: 130, dataWallDamage: 20, dataWallWidth: 40, dataWallGap: 200,
            phase3MinionSpawnInterval: 4000, phase3MinionSpawnCount: 10,
            phase2NovaRate: 4000,
            phase2NovaProjectileCount: 20,
            phase2NovaProjectileSpeed: 200,
            phase2NovaProjectileSize: 8,
            phase2NovaProjectileDamage: 12,
        };

        const BOSS_2_SUB_ROUTINE_STATS = {
            count: 4, size: 25, orbitRadius: 200, orbitSpeed: 0.015, maxHealth: 750,
            projectileSpeed: 250, projectileSize: 10, projectileDamage: 15, projectileFireRate: 2000,
        };

        const RAM_SOCKET_STATS = {
            count: 4, size: 60, cleanseTime: 4000,
        };
        
        const BOSS_3_STATS = {
            size: 80,
            maxHealth: 15000,
            phase2HealthThreshold: 0.70,
            phase3HealthThreshold: 0.30,
            vulnerabilityDuration: 9000, 

            dataSmasherRate: 3600,
            dataSmasherRadius: 70,
            dataSmasherDamage: 30,
            dataSmasherWarnTime: 1500,
            corruptionWaveRate: 4000,
            corruptionWaveWidth: 130,
            corruptionWaveSpeed: 300,
            corruptionWaveDamage: 25,

            hostileTakeoverRate: 4500,
            busWarnTime: 2000,
            busFireDuration: 1000,
            busDamage: 30,
            phase2CorruptedPuddleRate: 5000,
            phase2CorruptedPuddleRadius: 110,
            phase2CorruptedPuddleDuration: 3000,
            phase2CorruptedPuddleDamage: 4,
            phase2CorruptedPuddleDamageInterval: 250,
            staticZoneRate: 6000,
            staticZoneCount: 7,
            staticZoneRadius: 100,
            staticZoneDuration: 5000,

            phase3BusOverloadRate: 3000,
            phase3VolatileMemoryRate: 4000,
            phase3VolatilePuddleDuration: 5000,
            phase3VolatilePuddleDamage: 10,
            phase3FinalJudgementRate: 6000,
            phase3AuraInitialRadius: 50,
            phase3AuraExpandRate: 10,
            phase3AuraDamage: 1.5,
            phase3AuraDamageTick: 250,
        };

        // --- CHEFE 4 (NOVO) ---
        const BOSS_4_STATS = {
            size: 90, maxHealth: 25000,
            subRouterCount: 4,
            subRouterHealth: 2000,
            dosWaveRate: 4500,
            dosWaveDamage: 30,
            phase2HealthThreshold: 0.65,
            portScanRate: 6000,
            portScanLaserCount: 3,
            portScanDamage: 25,
            packetFloodRate: 5000,
            quarantineRate: 8000,
            quarantineDamage: 20,
            phase3HealthThreshold: 0.30,
            arenaShrinkRate: 5,
            ghostBossSpawnRate: 12000,
        };

        const HEALTH_PICKUP_STATS = {
            size: 20, healAmount: 30, spawnIntervalMin: 20000, spawnIntervalMax: 30000, 
        };

        const ANTIVIRUS_SCAN_STATS = {
            fireRate: 1200, projectileSpeed: 300, damage: 10, projectileSize: 8,
            systemPurgeProjectilesPerShot: 3, systemPurgeSpreadAngle: 15 * (Math.PI / 180), systemPurgeDamageBonus: 15, systemPurgeSizeMultiplier: 1.2,
            hunterSwarmProjectileSpeed: 220, hunterSwarmDamage: 8, hunterSwarmSizeMultiplier: 1.1, hunterSwarmDotDamagePerTick: 3, hunterSwarmDotDuration: 3000, hunterSwarmDotTickInterval: 500, hunterSwarmSeekForce: 0.1, 
        };

        const FIREWALL_STATS = {
            initialOrbs: 1, radius: 80, angleSpeed: 0.125, orbSize: 18.5, damage: 9, hitCooldown: 500, 
            shardBaseDamage: 8, shardBaseFrequency: 3000, shardSpeed: 400, shardSize: 5, shardLifetime: 750, 
            aegisOrbSizeMultiplier: 1.8, aegisContactDamageBonus: 20, aegisPulseDamage: 10, aegisPulseRadius: 40, aegisPulseFrequency: 1500, aegisShardDamageBonus: 2,
        };
        
        const ACID_VIRUS_STATS = {
            cooldown: 2800,
            projectileSpeed: 350,
            projectileSize: 10,
            puddleRadius: 70,
            puddleDuration: 3000,
            puddleDamagePerTick: 4,
            puddleTickRate: 250,
            pandemicSporeChance: 0.75,
            pandemicSporeSpeed: 200,
            pandemicSporeSize: 8,
        };
        
        const DEFRAG_STATS = {
            cooldown: 1000,
            damage: 16,
            range: 75,
            arc: 110 * (Math.PI / 180),
            spinDamageMultiplier: 1.5,
            spinRangeMultiplier: 1.2,
            comboHitsForSpin: 3,
        };

        const DATA_LEECH_STATS = {
            damagePerTick: 3.5, tickRate: 100, range: 250,
            stillDamageMultiplierMax: 2.5, stillDamageRampUpTime: 2000,
            chainDamageMultiplier: 0.5,
            siphonHealChance: 0.10,
            siphonHealAmount: 3,
        };
        
        const SUB_PROCESS_MINION_STATS = {
            size: 14,
            speed: 180,
            baseHealth: 40,
            healthPerLevel: 5.5,
            baseDamage: 12,
            damagePerLevel: 2.25,
            conversionChance: 0.30,
            maxMinions: 4,
            orbitRadius: 45,
            commandSwitchCooldown: 500, 
            attackCooldown: 1000,
            damageTakenCooldown: 500,
        };

        const UI_BAR_HEIGHT = 88; 
        const INITIAL_EXP_TO_NEXT_LEVEL = 100;
        const EXP_LEVEL_MULTIPLIER = 1.175;
        const ENEMY_SPAWN_INITIAL_DELAY = 3000; 
        const ENEMY_SPAWN_MIN_INTERVAL = 300; 
        const ENEMY_SPAWN_INTERVAL_DECREMENT_FACTOR = 5; 
        const SYSTEM_CORES_PER_BOSS_DEFEAT = 1;
        const SYSTEM_CORES_PER_BOSS_2_DEFEAT = 3;
        const SYSTEM_CORES_PER_BOSS_3_DEFEAT = 5;
        const SYSTEM_CORES_PER_BOSS_4_DEFEAT = 10; // --- NOVO ---
        const DATA_VAULT_TRIGGER_TIME = 300;
        const DATA_VAULT_2_TRIGGER_TIME = 600;
        const DATA_VAULT_3_TRIGGER_TIME = 960;
        const DATA_VAULT_KILL_REQUIREMENT = 75;
        
        // --- START OF achievements.ts ---
        const ACHIEVEMENTS_CONFIG = [
            // --- Conquistas de Progress√£o (F√°ceis) ---
            { id: 'survive_5_min', name: 'Primeiros Ciclos', description: 'Sobreviva por 5 minutos em uma √∫nica partida.', unlockHint: 'Sobreviva por 5 minutos.', icon: '‚è±Ô∏è', difficulty: 'F√°cil', trigger: { type: 'session_event', event: 'survive_time', value: 300 }, reward: { type: 'permanent_buff', statAffected: 'expModifier', bonus: 0.01, rewardDescription: '+1% Ganho de XP' } },
            { id: 'reach_level_10', name: 'Otimiza√ß√£o Inicial', description: 'Alcance o n√≠vel 10 em uma √∫nica partida.', unlockHint: 'Alcance o n√≠vel 10.', icon: '‚≠ê', difficulty: 'F√°cil', trigger: { type: 'session_event', event: 'reach_level', value: 10 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 5, rewardDescription: '+5 HP M√°ximo' } },
            { id: 'kill_1000_total', name: 'Limpador de Cache', description: 'Derrote 1.000 inimigos no total.', unlockHint: 'Derrote 1.000 inimigos no total.', icon: 'üßπ', difficulty: 'F√°cil', trigger: { type: 'stat_tracker', stat: 'totalKills', value: 1000 }, reward: { type: 'permanent_buff', statAffected: 'speed', bonus: 2, rewardDescription: '+2 Velocidade' } },
            { id: 'evolve_first_weapon', name: 'Processo Aprimorado', description: 'Evolua uma arma pela primeira vez.', unlockHint: 'Evolua uma arma pela primeira vez.', icon: 'üöÄ', difficulty: 'F√°cil', trigger: { type: 'session_event', event: 'evolve_weapon' }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.01, rewardDescription: '-1% Recarga de Armas' } },
            { id: 'magnetic_attraction', name: 'Atra√ß√£o Magn√©tica', description: 'Colete 5.000 orbes de experi√™ncia no total.', unlockHint: 'Colete 5.000 orbes de XP no total.', icon: 'üß≤', difficulty: 'F√°cil', trigger: { type: 'stat_tracker', stat: 'totalXpOrbsCollected', value: 5000 }, reward: { type: 'permanent_buff', statAffected: 'xpMagnetRadius', bonus: 0.03, rewardDescription: '+3% Alcance de Coleta' } },
            { id: 'dash_master', name: 'Mestre do Dash', description: 'Use a habilidade de Dash 250 vezes no total.', unlockHint: 'Use o Dash 250 vezes no total.', icon: '‚Ü™Ô∏è', difficulty: 'F√°cil', trigger: { type: 'stat_tracker', stat: 'totalDashes', value: 250 }, reward: { type: 'permanent_buff', statAffected: 'dashCooldown', bonus: -0.05, rewardDescription: '-5% Recarga do Dash' } },

            // --- Conquistas de Dedica√ß√£o (M√©dias) ---
            { id: 'defeat_boss_1', name: 'Guardi√£o Neutralizado', description: 'Derrote o Guardi√£o da Fase 1.', unlockHint: 'Derrote o Guardi√£o da Fase 1.', icon: 'üõ°Ô∏è', difficulty: 'M√©dia', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'guardian' } }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.02, rewardDescription: '+2% Dano Global' } },
            { id: 'defeat_boss_2', name: 'Sincronia Quebrada', description: 'Derrote o Sincronizador (Chefe da Fase 2).', unlockHint: 'Derrote o Chefe da Fase 2.', icon: 'üëæ', difficulty: 'M√©dia', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'sincronizador' } }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 10, rewardDescription: '+10 HP M√°ximo' } },
            { id: 'kill_10000_total', name: 'Exterminador de Bugs', description: 'Derrote 10.000 inimigos no total.', unlockHint: 'Derrote 10.000 inimigos no total.', icon: 'üí•', difficulty: 'M√©dia', trigger: { type: 'stat_tracker', stat: 'totalKills', value: 10000 }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.03, rewardDescription: '+3% Dano Global' } },
            { id: 'survive_11_min', name: 'Maratona de Dados', description: 'Sobreviva por 11 minutos (at√© o segundo chefe).', unlockHint: 'Sobreviva por 11 minutos.', icon: 'üèÉ‚Äç‚ôÇÔ∏è', difficulty: 'M√©dia', trigger: { type: 'session_event', event: 'survive_time', value: 660 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 10, rewardDescription: '+10 HP M√°ximo' } },
            { id: 'evolve_3_weapons_session', name: 'Arsenal Completo', description: 'Evolua 3 armas diferentes em uma √∫nica partida.', unlockHint: 'Evolua 3 armas em uma partida.', icon: '‚öîÔ∏è', difficulty: 'M√©dia', trigger: { type: 'session_event', event: 'evolve_weapon_count', value: 3 }, reward: { type: 'permanent_buff', statAffected: 'expModifier', bonus: 0.03, rewardDescription: '+3% Ganho de XP' } },
            { id: 'unlock_technomancer', name: 'Tecnomante Online', description: 'Desbloqueie a classe Tecnomante.', unlockHint: 'Desbloqueie a classe Tecnomante.', icon: 'üõ†Ô∏è', difficulty: 'M√©dia', trigger: { type: 'stat_tracker', stat: 'classesUnlockedIncludes', value: 'class_technomancer' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.03, rewardDescription: '+3% Dano Global' } },
            { id: 'sentinel_survive_10_min', name: 'Fortaleza Impenetr√°vel', description: 'Sobreviva por 10 minutos com a classe Sentinela.', unlockHint: 'Sobreviva 10 min como Sentinela.', icon: 'üè∞', difficulty: 'M√©dia', trigger: { type: 'session_event', event: 'survive_time_as_class', value: 600, classId: 'class_sentinel' }, reward: { type: 'permanent_buff', statAffected: 'damageReduction', bonus: 0.01, rewardDescription: '+1% Resist√™ncia a Dano' } },
            { id: 'cleanse_20_libraries', name: 'Ca√ßador de Bibliotecas', description: 'Limpe um total de 100 Bibliotecas Corrompidas em todas as suas partidas.', unlockHint: 'Limpe 100 Bibliotecas Corrompidas no total.', icon: 'üìö‚ú®', difficulty: 'M√©dia', trigger: { type: 'stat_tracker', stat: 'totalCorruptedLibrariesCleansed', value: 100 }, reward: { type: 'permanent_buff', statAffected: 'statusEffectDuration', bonus: 0.03, rewardDescription: '+3% Dura√ß√£o de Efeitos' } },

            // --- Conquistas de Habilidade (Dif√≠ceis) ---
            { id: 'defeat_boss_3', name: '√Årbitro Desativado', description: 'Derrote o √Årbitro do Sistema (Chefe da Fase 3).', unlockHint: 'Derrote o Chefe da Fase 3.', icon: '‚öñÔ∏è', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'arbiter' } }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 15, rewardDescription: '+15 HP M√°ximo' } },
            { id: 'reach_infinite_mode', name: 'Loop Infinito', description: 'Entre no Modo Infinito ap√≥s derrotar o Nexus da Colmeia.', unlockHint: 'Derrote o chefe final para entrar no Modo Infinito.', icon: '‚ôæÔ∏è', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'reached_infinite' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.05, rewardDescription: '+5% Dano Global' } },
            { id: 'survive_20_min', name: 'Lenda do Sistema', description: 'Sobreviva por 20 minutos em uma √∫nica partida.', unlockHint: 'Sobreviva por 20 minutos.', icon: 'üëë', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'survive_time', value: 1200 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 20, rewardDescription: '+20 HP M√°ximo' } },
            { id: 'unlock_all_classes', name: 'Cole√ß√£o de Arquiteturas', description: 'Desbloqueie todas as Classes.', unlockHint: 'Desbloqueie todas as classes.', icon: 'üìö', difficulty: 'Dif√≠cil', trigger: { type: 'stat_tracker', stat: 'classesUnlocked', value: CLASS_DEFINITIONS.length }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.02, rewardDescription: '-2% Recarga de Armas' } },
            { id: 'perfect_sync', name: 'Mira Perfeita', description: 'Derrote o Sincronizador sem sofrer dano DURANTE a luta.', unlockHint: 'Derrote o Sincronizador sem dano.', icon: 'üéØ', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'defeat_boss_no_damage', params: { bossType: 'sincronizador' } }, reward: { type: 'permanent_buff', statAffected: 'speed', bonus: 10, rewardDescription: '+10 Velocidade' } },
            { id: 'reach_level_50', name: 'N√≠vel M√°ximo', description: 'Alcance o n√≠vel 50 em uma √∫nica partida.', unlockHint: 'Alcance o n√≠vel 50.', icon: 'üíØ', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'reach_level', value: 50 }, reward: { type: 'permanent_buff', statAffected: 'expModifier', bonus: 0.05, rewardDescription: '+5% Ganho de XP' } },
            { id: 'evolve_quantum_optimizer', name: 'Otimiza√ß√£o Final', description: 'Evolua com sucesso a arma Desfragmentador para sua forma final "Otimizador Qu√¢ntico".', unlockHint: 'Evolua o Desfragmentador para Otimizador Qu√¢ntico.', icon: 'üí´', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'evolve_specific_weapon', value: 'evolution_defrag_quantum_optimizer' }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.02, rewardDescription: '-2% Recarga de Armas' } },
            { id: 'nightmare_survive_10_min', name: 'Resist√™ncia ao Pesadelo', description: 'Sobreviva por 10 minutos em uma √∫nica partida no Modo Pesadelo.', unlockHint: 'Sobreviva por 10 minutos no Modo Pesadelo.', icon: 'üò®', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'survive_time_in_nightmare', value: 600 }, reward: { type: 'permanent_buff', statAffected: 'damageReduction', bonus: 0.01, rewardDescription: '+1% Redu√ß√£o de Dano' } },
            { id: 'nightmare_defeat_boss_1', name: 'Guardi√£o do Pesadelo', description: 'Derrote o Guardi√£o da Fase 1 em uma partida no Modo Pesadelo.', unlockHint: 'Derrote o Guardi√£o no Modo Pesadelo.', icon: 'üõ°Ô∏è‚Äçüî•', difficulty: 'Dif√≠cil', trigger: { type: 'session_event', event: 'defeat_boss_in_nightmare', params: { bossType: 'guardian' } }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.05, rewardDescription: '+5% Dano Global' } },
            { id: 'collect_10_corrupted_kernels', name: 'Colecionador Corrompido', description: 'Acumule um total de 10 N√∫cleos Corrompidos ao longo de todas as suas partidas.', unlockHint: 'Acumule 10 N√∫cleos Corrompidos no total.', icon: 'üíú', difficulty: 'Dif√≠cil', trigger: { type: 'stat_tracker', stat: 'totalCorruptedKernelsEarned', value: 10 }, reward: { type: 'permanent_buff', statAffected: 'initialRerolls', bonus: 1, rewardDescription: '+1 Reroll Inicial' } },

            // --- Conquistas √âpicas (ALTERADAS E NOVAS) ---
            { id: 'defeat_boss_4', name: 'Mente Desconectada', description: 'Derrote o Nexus da Colmeia (Chefe da Fase 4).', unlockHint: 'Derrote o Chefe da Fase 4.', icon: 'üß†', difficulty: '√âpica', trigger: { type: 'session_event', event: 'defeat_boss', params: { bossType: 'hivemind_nexus' } }, reward: { type: 'permanent_buff', statAffected: 'critDamage', bonus: 0.20, rewardDescription: '+20% Dano Cr√≠tico' } },
            { id: 'nightmare_win', name: 'Conquistador do Pesadelo', description: 'Derrote o chefe final, o Nexus da Colmeia, em uma partida no Modo Pesadelo.', unlockHint: 'Derrote o Nexus da Colmeia no Modo Pesadelo.', icon: 'üòà', difficulty: '√âpica', trigger: { type: 'session_event', event: 'defeat_boss_in_nightmare', params: { bossType: 'hivemind_nexus' } }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 0.04, rewardDescription: '+4% HP M√°ximo' } },
            { id: 'win_one_weapon', name: 'Monocultura', description: 'Derrote o Nexus da Colmeia sem adquirir nenhuma arma adicional al√©m da inicial da sua classe.', unlockHint: 'Ven√ßa o jogo (derrote o Nexus) usando apenas sua arma inicial.', icon: '‚òùÔ∏è', difficulty: '√âpica', trigger: { type: 'session_event', event: 'win_with_one_weapon' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.08, rewardDescription: '+8% Dano Global' } },
            { id: 'unlock_all_evolutions', name: 'Perfeccionista', description: 'Realize com sucesso cada uma das evolu√ß√µes de armas listadas no Guia de Evolu√ß√µes pelo menos uma vez.', unlockHint: 'Desbloqueie todas as evolu√ß√µes de armas do Guia.', icon: 'üéì', difficulty: '√âpica', trigger: { type: 'stat_tracker', stat: 'allEvolutionsUnlocked' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.04, rewardDescription: '+4% Dano Global' } },
            { id: 'immovable_object', name: 'Torre Im√≥vel', description: 'Sobreviva por 4 minutos sem mover seu personagem.', unlockHint: 'Sobreviva por 4 min sem se mover.', icon: 'üóº', difficulty: '√âpica', trigger: { type: 'session_event', event: 'survive_time_no_move', value: 240 }, reward: { type: 'permanent_buff', statAffected: 'maxHealth', bonus: 20, rewardDescription: '+20 HP M√°ximo' } },
            { id: 'master_decompiler', name: 'Mestre Decompiler', description: 'Complete a an√°lise (Tier 4) de todos os inimigos no Decompiler.', unlockHint: 'Complete o Decompiler.', icon: 'üî¨', difficulty: '√âpica', trigger: { type: 'stat_tracker', stat: 'decompiler_complete' }, reward: { type: 'permanent_buff', statAffected: 'initialRerolls', bonus: 1, rewardDescription: '+1 Reroll Inicial' } },
            { id: 'judgment_dodged', name: 'Julgamento Evitado', description: 'Derrote o √Årbitro sem sofrer dano DURANTE a luta.', unlockHint: 'Derrote o √Årbitro sem dano.', icon: 'üî®', difficulty: '√âpica', trigger: { type: 'session_event', event: 'defeat_boss_no_damage', params: { bossType: 'arbiter' } }, reward: { type: 'permanent_buff', statAffected: 'cooldownModifier', bonus: -0.03, rewardDescription: '-3% Recarga de Armas' } },
            { id: 'complete_all_achievements', name: 'Mestre do Sistema', description: 'Complete todas as outras conquistas.', unlockHint: 'Desbloqueie todas as outras conquistas.', icon: 'üåü', difficulty: '√âpica', trigger: { type: 'unlock_all' }, reward: { type: 'permanent_buff', statAffected: 'globalDamageFactor', bonus: 0.10, rewardDescription: '+10% Dano Global (Final)' } }
        ];
        // --- END OF achievements.ts ---

        const BESTIARY_DATA = [
            { name: "Bug Comum", type: EnemyType.DEFAULT, description: "Unidade b√°sica de corrup√ß√£o. Persegue o processo principal incansavelmente.", visual: { color: GAME_COLORS.ENEMY_DEFAULT, size: ENEMY_DEFAULT_STATS.size } },
            { name: "Memory Leak", type: EnemyType.MEMORY_LEAK, description: "Rasteja, deixando um rastro de dados corrompidos que causam dano.", visual: { color: GAME_COLORS.ENEMY_MEMORY_LEAK, size: ENEMY_MEMORY_LEAK_STATS.size } },
            { name: "Spyware", type: EnemyType.SPYWARE, description: "Fica invis√≠vel periodicamente para emboscar.", visual: { color: GAME_COLORS.ENEMY_SPYWARE, size: ENEMY_SPYWARE_STATS.size } },
            { name: "Trojan Horse", type: EnemyType.TROJAN_HORSE, description: "Resistente. Ao ser destru√≠do, libera Malware Fragments perigosos.", visual: { color: GAME_COLORS.ENEMY_TROJAN, size: ENEMY_TROJAN_HORSE_STATS.size } },
            { name: "Malware Fragment", type: EnemyType.MALWARE_FRAGMENT, description: "Pequeno e r√°pido, um fragmento liberado por Trojans.", visual: { color: GAME_COLORS.ENEMY_DEFAULT, size: ENEMY_MALWARE_FRAGMENT_STATS.size } },
            { name: "Rootkit", type: EnemyType.ROOTKIT, description: "Inimigo de elite: r√°pido, resistente e causa dano massivo.", visual: { color: GAME_COLORS.ENEMY_ROOTKIT, size: ENEMY_ROOTKIT_STATS.size } },
            { name: "DDoS Bot", type: EnemyType.DDOS_BOT, description: "Aparece em enxames, sobrecarregando o sistema com n√∫meros.", visual: { color: GAME_COLORS.ENEMY_DDOS_BOT, size: ENEMY_DDOS_BOT_STATS.size } },
            { name: "Glitch Minion", type: EnemyType.GLITCH_MINION, description: "Fragmento inst√°vel invocado pelo Guardi√£o. R√°pido e err√°tico.", visual: { color: GAME_COLORS.ENEMY_GLITCH_MINION, size: GLITCH_MINION_STATS.size } },
            { name: "[Fase 2] Processo Corrompido", type: EnemyType.PROCESSO_CORROMPIDO, description: "Uma amea√ßa angular e veloz que habita as parti√ß√µes mais profundas do sistema.", visual: { color: GAME_COLORS.ENEMY_PROCESSO_CORROMPIDO, size: ENEMY_PROCESSO_CORROMPIDO_STATS.size } },
            { name: "[Fase 2] Ponteiro Nulo", type: EnemyType.PONTEIRO_NULO, description: "Desaparece e reaparece em locais inesperados, atacando de surpresa.", visual: { color: GAME_COLORS.ENEMY_PONTEIRO_NULO, size: ENEMY_PONTEIRO_NULO_STATS.size } },
            { name: "[Fase 2] Segmento de Falha", type: EnemyType.SEGMENTO_FALHA, description: "Extremamente resistente, ativa um escudo que nega a maior parte do dano recebido.", visual: { color: GAME_COLORS.ENEMY_SEGMENTO_FALHA, size: ENEMY_SEGMENTO_FALHA_STATS.size } },
            { name: "[Fase 2] Processo Zumbi", type: EnemyType.PROCESSO_ZUMBI, description: "Lento e dur√°vel. Possui uma chance de se reanimar com metade da vida ap√≥s ser destru√≠do.", visual: { color: GAME_COLORS.ENEMY_PROCESSO_ZUMBI, size: ENEMY_PROCESSO_ZUMBI_STATS.size } },
            { name: "[Fase 3] Nanite de Reparo", type: EnemyType.NANITE, description: "Move-se em um padr√£o ondulado imprevis√≠vel, dif√≠cil de atingir.", visual: { color: GAME_COLORS.ENEMY_NANITE, size: ENEMY_NANITE_STATS.size } },
            { name: "[Fase 3] Dissipador de Calor", type: EnemyType.HEATSINK, description: "Lento e resistente. Emite pulsos de calor que destroem proj√©teis pr√≥ximos.", visual: { color: GAME_COLORS.ENEMY_HEATSINK, size: ENEMY_HEATSINK_STATS.size } },
            { name: "[Fase 3] Controlador I/O", type: EnemyType.IO_CONTROLLER, description: "Dispara uma rajada de proj√©teis em cone, controlando o fluxo de dados.", visual: { color: GAME_COLORS.ENEMY_IO_CONTROLLER, size: ENEMY_IO_CONTROLLER_STATS.size } },
            { name: "[Fase 3] Processo Vol√°til", type: EnemyType.VOLATILE_PROCESS, description: "Persegue o jogador e se autodestr√≥i em uma grande explos√£o ap√≥s um curto per√≠odo.", visual: { color: GAME_COLORS.ENEMY_VOLATILE_PROCESS, size: ENEMY_VOLATILE_PROCESS_STATS.size } },
            // --- FASE 4 (NOVO) ---
            { name: "[Fase 4] Processo Recursivo", type: EnemyType.RECURSIVE_PROCESS, description: "Processo est√°vel que, ao ser destru√≠do, se divide em duas inst√¢ncias filhas, mais r√°pidas.", visual: { color: GAME_COLORS.ENEMY_RECURSIVE_PROCESS, size: ENEMY_RECURSIVE_PROCESS_STATS.size } },
            { name: "[Fase 4] Processo Filho", type: EnemyType.CHILD_PROCESS, description: "Inst√¢ncia inst√°vel e r√°pida, gerada pela destrui√ß√£o de um Processo Recursivo.", visual: { color: GAME_COLORS.ENEMY_CHILD_PROCESS, size: ENEMY_CHILD_PROCESS_STATS.size } },
            { name: "[Fase 4] Firewall Desonesto", type: EnemyType.ROGUE_FIREWALL, description: "Lento e resistente, bloqueia proj√©teis do jogador com sua pr√≥pria vida.", visual: { color: GAME_COLORS.ENEMY_ROGUE_FIREWALL, size: ENEMY_ROGUE_FIREWALL_STATS.size } },
            { name: "[Fase 4] Pico de Lat√™ncia", type: EnemyType.LATENCY_SPIKE, description: "N√£o ataca, mas projeta uma grande aura de lentid√£o ao seu redor.", visual: { color: GAME_COLORS.ENEMY_LATENCY_SPIKE, size: ENEMY_LATENCY_SPIKE_STATS.size } },
            { name: "[Fase 4] Anomalia de Protocolo", type: EnemyType.PROTOCOL_ANOMALY, description: "Alterna entre um modo lento e resistente e um modo r√°pido que dispara proj√©teis.", visual: { color: GAME_COLORS.ENEMY_PROTOCOL_ANOMALY, size: ENEMY_PROTOCOL_ANOMALY_STATS.size } },
        ];

        // --- TALENT TREE CONFIG ---
        const TALENT_TREE_CONFIG = [
            // --- N√ìS CENTRAIS (LINHA 1) ---
            { id: 'core_defense_unlock', title: 'Protocolos Defensivos', icon: 'üõ°Ô∏è', description: 'Desbloqueia o ramo de Defesa.', maxLevel: 1, costPerLevel: [1], x: 20, y: 5, branch: 'defense' },
            { id: 'core_offense_unlock', title: 'Protocolos Ofensivos', icon: 'üí•', description: 'Desbloqueia o ramo de Ofensa.', maxLevel: 1, costPerLevel: [1], x: 50, y: 5, branch: 'offense' },
            { id: 'core_utility_unlock', title: 'Protocolos de Utilidade', icon: '‚öôÔ∏è', description: 'Desbloqueia o ramo de Utilidade.', maxLevel: 1, costPerLevel: [1], x: 80, y: 5, branch: 'utility' },

            // --- RAMO DE DEFESA ---
            { id: 'perm_hp_boost', title: 'Integridade do Casco', icon: '‚ù§Ô∏è', description: (level) => `+${level * 12} HP m√°ximo inicial.`, maxLevel: 5, costPerLevel: [1, 1, 2, 2, 3], statAffected: 'maxHealth', bonusPerLevel: 12, type: 'additive', requires: ['core_defense_unlock'], x: 10, y: 35, branch: 'defense' },
            { id: 'perm_damage_reduction', title: 'Blindagem de Nanocarbono', icon: 'üß±', description: (level) => `+${(level * 1.2).toFixed(1)}% de Redu√ß√£o de Dano.`, maxLevel: 5, costPerLevel: [2, 2, 3, 3, 4], statAffected: 'damageReduction', bonusPerLevel: 0.012, type: 'multiplicative_add', requires: ['core_defense_unlock'], x: 30, y: 35, branch: 'defense' },
            { id: 'perm_regen', title: 'Reparo Autom√°tico', icon: 'üíâ', description: (level) => `Regenera +${(level * 0.25).toFixed(2)} HP por segundo.`, maxLevel: 5, costPerLevel: [3, 3, 4, 4, 5], statAffected: 'regenAmount', bonusPerLevel: 0.25, type: 'additive', requires: ['perm_hp_boost', 'perm_damage_reduction'], x: 20, y: 65, branch: 'defense' },
            { id: 'perm_dash_invuln', title: 'Matriz de Fase', icon: 'üëª', description: (level) => `Aumenta a dura√ß√£o da invencibilidade do Dash em ${level * 10}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'dashDuration', bonusPerLevel: 0.10, type: 'multiplicative_add', requires: ['perm_regen'], x: 10, y: 95, branch: 'defense' },
            { id: 'perm_last_stand', title: '√öltimo Recurso', icon: 'üí´', description: (level) => `Ao receber dano fatal, sobrevive com 1 HP e fica invenc√≠vel por ${1 + level * 0.6}s. (1x por partida)`, maxLevel: 3, costPerLevel: [5, 6, 7], statAffected: 'lastStandCharges', bonusPerLevel: 1, type: 'additive', requires: ['perm_regen'], x: 30, y: 95, branch: 'defense' },
            { id: 'capstone_defense', title: 'Protocolo de Redund√¢ncia', icon: 'üíæ', description: 'Aumenta permanentemente a Redu√ß√£o de Dano em +5% e a Regenera√ß√£o de HP em +1.5 HP/s.', maxLevel: 1, costPerLevel: [10], statAffected: 'redundancyProtocol', bonusPerLevel: 1, type: 'flag', requires: ['perm_dash_invuln', 'perm_last_stand'], x: 20, y: 125, branch: 'defense' },

            // --- RAMO DE OFENSA ---
            { id: 'perm_global_damage', title: 'Otimizador de Dano', icon: 'üî•', description: (level) => `Aumenta todo o dano em ${(level * 2.5).toFixed(1)}%.`, maxLevel: 5, costPerLevel: [1, 2, 2, 3, 3], statAffected: 'globalDamageFactor', bonusPerLevel: 0.025, type: 'multiplicative_add', requires: ['core_offense_unlock'], x: 50, y: 35, branch: 'offense' },
            { id: 'perm_cooldown_modifier', title: 'Redutor de Lat√™ncia', icon: '‚ö°', description: (level) => `Reduz recarga de armas em ${(level * 1.8).toFixed(1)}%.`, maxLevel: 4, costPerLevel: [2, 3, 4, 5], statAffected: 'cooldownModifier', bonusPerLevel: 0.018, type: 'multiplicative_subtract', requires: ['perm_global_damage'], x: 40, y: 65, branch: 'offense' },
            { id: 'perm_projectile_speed', title: 'Acelerador Magn√©tico', icon: '‚û°Ô∏è', description: (level) => `Aumenta a velocidade dos proj√©teis em ${level * 6}%.`, maxLevel: 4, costPerLevel: [2, 3, 3, 4], statAffected: 'projectileSpeed', bonusPerLevel: 0.06, type: 'multiplicative_add', requires: ['perm_global_damage'], x: 60, y: 65, branch: 'offense' },
            { id: 'perm_crit_chance', title: 'An√°lise Preditiva', icon: 'üéØ', description: (level) => `Ganha +${(level * 1.5).toFixed(1)}% de Chance de Acerto Cr√≠tico.`, maxLevel: 5, costPerLevel: [3, 4, 5, 6, 7], statAffected: 'critChance', bonusPerLevel: 0.015, type: 'additive', requires: ['perm_cooldown_modifier', 'perm_projectile_speed'], x: 50, y: 95, branch: 'offense' },
            { id: 'capstone_offense', title: 'Aniquila√ß√£o', icon: 'üí£', description: (level) => `Aumenta o Dano Cr√≠tico em 60% e acertos cr√≠ticos causam uma pequena explos√£o.`, maxLevel: 1, costPerLevel: [10], statAffected: 'critDamage', bonusPerLevel: 0.6, type: 'additive', requires: ['perm_crit_chance'], x: 50, y: 125, branch: 'offense' },

            // --- RAMO DE UTILIDADE ---
            { id: 'perm_xp_modifier', title: 'Compress√£o de Dados', icon: '‚ú®', description: (level) => `Aumenta ganho de XP em ${level * 4}%.`, maxLevel: 5, costPerLevel: [1, 1, 2, 2, 3], statAffected: 'expModifier', bonusPerLevel: 0.04, type: 'multiplicative_add', requires: ['core_utility_unlock'], x: 70, y: 35, branch: 'utility' },
            { id: 'perm_speed_boost', title: 'Otimiza√ß√£o de Clock', icon: 'üèÉ', description: (level) => `Aumenta velocidade de movimento em ${(level * 2.5).toFixed(1)}%.`, maxLevel: 5, costPerLevel: [1, 2, 2, 3, 3], statAffected: 'speed', bonusPerLevel: 0.025, type: 'multiplicative_add', requires: ['core_utility_unlock'], x: 90, y: 35, branch: 'utility' },
            { id: 'perm_magnet_radius', title: 'Campo de Atra√ß√£o', icon: 'üß≤', description: (level) => `Aumenta o alcance de coleta em ${level * 10}%.`, maxLevel: 5, costPerLevel: [2, 2, 3, 3, 4], statAffected: 'xpMagnetRadius', bonusPerLevel: 0.10, type: 'multiplicative_add', requires: ['perm_xp_modifier', 'perm_speed_boost'], x: 80, y: 65, branch: 'utility' },
            { id: 'perm_rerolls', title: 'Algoritmo de Sorte', icon: 'üé≤', description: (level) => `Come√ßa cada partida com +${level} Reroll.`, maxLevel: 3, costPerLevel: [4, 5, 6], statAffected: 'initialRerolls', bonusPerLevel: 1, type: 'additive', requires: ['perm_magnet_radius'], x: 70, y: 95, branch: 'utility' },
            { id: 'perm_status_effect_duration', title: 'Intensificador de Efeitos', icon: 'üåÄ', description: (level) => `Aumenta a dura√ß√£o dos efeitos de status em ${level * 6}%.`, maxLevel: 4, costPerLevel: [3, 4, 4, 5], statAffected: 'statusEffectDuration', bonusPerLevel: 0.06, type: 'multiplicative_add', requires: ['perm_magnet_radius'], x: 90, y: 95, branch: 'utility' },
            { id: 'capstone_utility', title: 'Processamento Paralelo', icon: '‚ôªÔ∏è', description: 'Ao subir de n√≠vel, tem 25% de chance de receber uma op√ß√£o de upgrade adicional.', maxLevel: 1, costPerLevel: [10], statAffected: 'extraUpgradeChoice', bonusPerLevel: 0.25, type: 'flag', requires: ['perm_rerolls', 'perm_status_effect_duration'], x: 80, y: 125, branch: 'utility' },
            
            // --- TALENTO SUPREMO ---
            { id: 'perm_ultimate_synergy', title: 'Sinergia do Kernel', icon: 'üåü', description: 'Desbloqueia o poder total do n√∫cleo. Aumenta todos os danos, HP e velocidade em 8%.', maxLevel: 1, costPerLevel: [20], statAffected: 'ultimate', bonusPerLevel: 0.08, type: 'multiplicative_add', requires: ['capstone_defense', 'capstone_offense', 'capstone_utility'], x: 50, y: 155, branch: 'ultimate' },

            // --- NOVO N√ì CENTRAL CORROMPIDO ---
            { id: 'corrupted_core_unlock', title: 'Kernel Corrompido', icon: 'üí†', description: 'Absorve a corrup√ß√£o para desbloquear poderes proibidos e a parte final da √°rvore.', maxLevel: 1, costPerLevel: [1], requires: ['perm_ultimate_synergy'], x: 50, y: 190, branch: 'corrupted_ultimate', isCorrupted: true },

            // --- RAMO CORROMPIDO DE DEFESA ---
            { id: 'corr_hp_multiplier', title: 'Redund√¢ncia de Casco', icon: '‚ù§Ô∏è‚Äçü©π', description: (level) => `Aumenta a efic√°cia de TODOS os b√¥nus de HP M√°ximo em +${10 * level}%.`, maxLevel: 3, costPerLevel: [2, 3, 4], statAffected: 'hpBonusMultiplier', bonusPerLevel: 0.10, type: 'additive', requires: ['corrupted_core_unlock'], x: 20, y: 220, branch: 'corrupted_defense', isCorrupted: true },
            { id: 'corr_dot_reduction', title: 'Matriz Defletora', icon: 'üõ°Ô∏è', description: (level) => `Sua Redu√ß√£o de Dano agora tamb√©m se aplica a ${15 + 10 * level}% do dano cont√≠nuo (DoT).`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'dotDamageReduction', bonusPerLevel: 0.10, type: 'additive', requires: ['corr_hp_multiplier'], x: 10, y: 250, branch: 'corrupted_defense', isCorrupted: true },
            { 
                id: 'corr_dash_improvement', 
                title: 'Imaterialidade Aprimorada', 
                description: (level) => `Reduz a recarga do Dash em 10% e aumenta a invencibilidade em +5% por n√≠vel. (Total: -${level * 10}%, +${level * 5}%)`, 
                maxLevel: 3, 
                costPerLevel: [4, 5, 6], 
                statAffected: 'dashCooldownAndDuration', 
                bonusPerLevel: { cooldown: 0.10, duration: 0.05 }, 
                requires: ['corr_hp_multiplier'], 
                x: 30, y: 250, branch: 'corrupted_defense', isCorrupted: true 
            },
            { id: 'corr_capstone_defense', title: 'Vontade Inquebr√°vel', icon: 'üíé', description: 'Seu "√öltimo Recurso" agora deixa voc√™ com 25% da vida m√°xima. A invencibilidade tamb√©m dobra sua velocidade.', maxLevel: 1, costPerLevel: [10], statAffected: 'lastStandUpgrade', bonusPerLevel: 1, type: 'flag', requires: ['corr_dot_reduction', 'corr_dash_improvement'], x: 20, y: 280, branch: 'corrupted_defense', isCorrupted: true },

            // --- RAMO CORROMPIDO DE OFENSA ---
            { id: 'corr_base_damage', title: 'Satura√ß√£o de Dano', icon: 'üí•', description: (level) => `Aumenta o dano base de todas as suas armas em +${8 * level}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'baseDamage', bonusPerLevel: 0.08, type: 'multiplicative_add', requires: ['corrupted_core_unlock'], x: 50, y: 220, branch: 'corrupted_offense', isCorrupted: true },
            { id: 'corr_projectile_mastery', title: 'Acelera√ß√£o de Proj√©teis', icon: 'üöÄ', description: (level) => `Aumenta a velocidade e o alcance de todos os proj√©teis em +${10 * level}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'projectileRange', bonusPerLevel: 0.10, type: 'multiplicative_add', requires: ['corr_base_damage'], x: 40, y: 250, branch: 'corrupted_offense', isCorrupted: true },
            { id: 'corr_crit_damage', title: 'An√°lise de Vulnerabilidade', icon: 'üéØ', description: (level) => `B√¥nus de Dano Cr√≠tico aumentado em +${25 * level}%.`, maxLevel: 3, costPerLevel: [4, 5, 6], statAffected: 'critDamage', bonusPerLevel: 0.25, type: 'additive', requires: ['corr_base_damage'], x: 60, y: 250, branch: 'corrupted_offense', isCorrupted: true },
            { id: 'corr_capstone_offense', title: 'F√∫ria Infinita', icon: 'üî•', description: 'A cada 150 inimigos derrotados na partida, ganhe +1% de Dano e Vel. de Ataque (acumulativo, reseta no fim da partida).', maxLevel: 1, costPerLevel: [12], statAffected: 'infiniteFury', bonusPerLevel: 1, type: 'flag', requires: ['corr_projectile_mastery', 'corr_crit_damage'], x: 50, y: 280, branch: 'corrupted_offense', isCorrupted: true },

            // --- RAMO CORROMPIDO DE UTILIDADE ---
            { id: 'corr_magnet_radius', title: 'Coleta Magn√©tica Superior', icon: 'üß≤', description: (level) => `Aumenta permanentemente o seu raio de coleta de orbes em +${15 + level * 5}%.`, maxLevel: 3, costPerLevel: [2, 3, 4], statAffected: 'xpMagnetRadius', bonusPerLevel: 0.15, requires: ['corrupted_core_unlock'], x: 80, y: 220, branch: 'corrupted_utility', isCorrupted: true },
            { id: 'corr_status_duration', title: 'Persist√™ncia de Efeitos', icon: '‚è≥', description: (level) => `Aumenta a dura√ß√£o de todos os efeitos de status que voc√™ aplica em +${20 * level}%.`, maxLevel: 3, costPerLevel: [3, 4, 5], statAffected: 'statusEffectDuration', bonusPerLevel: 0.20, type: 'multiplicative_add', requires: ['corr_magnet_radius'], x: 70, y: 250, branch: 'corrupted_utility', isCorrupted: true },
            { id: 'corr_exp_boost', title: 'Efici√™ncia de Cache', icon: '‚ú®', description: (level) => `Aumenta o ganho de experi√™ncia de todas as fontes em +${5 * level}%.`, maxLevel: 3, costPerLevel: [4, 5, 6], statAffected: 'expModifier', bonusPerLevel: 0.05, type: 'multiplicative_add', requires: ['corr_magnet_radius'], x: 90, y: 250, branch: 'corrupted_utility', isCorrupted: true },
            { id: 'corr_capstone_utility', title: 'Reescrita de Protocolo', icon: '‚ôªÔ∏è', description: 'Ganha +1 Reroll inicial e uma op√ß√£o de upgrade adicional a cada n√≠vel.', maxLevel: 1, costPerLevel: [15], statAffected: 'protocolRewrite', bonusPerLevel: 1, type: 'flag', requires: ['corr_status_duration', 'corr_exp_boost'], x: 80, y: 280, branch: 'corrupted_utility', isCorrupted: true },

            // --- CAPSTONE FINAL CORROMPIDO ---
            { id: 'corr_ultimate_singularity', title: 'Singularidade do Kernel', icon: 'üåü', description: 'Dom√≠nio absoluto. Aumenta permanentemente todos os danos, HP e velocidade em +12%.', maxLevel: 1, costPerLevel: [20], statAffected: 'ultimateCorrupted', bonusPerLevel: 0.12, type: 'multiplicative_add', requires: ['corr_capstone_defense', 'corr_capstone_offense', 'corr_capstone_utility'], x: 50, y: 310, branch: 'corrupted_ultimate', isCorrupted: true },
        ];

        // --- START OF NEW MODIFIER DEFINITIONS ---
        const MODIFIER_DEFINITIONS = [
            // === BUFFS PARA O JOGADOR (CUSTAM PONTOS - valor negativo) ===
            { id: 'mod_buff_start_level', name: 'Inicializa√ß√£o Acelerada', command: 'init --boost', description: 'Comece a partida com +1 n√≠vel e um upgrade gratuito.', points: -3, effects: [{ stat: 'initialLevel', operation: 'add', value: 1 }, { stat: 'initialFreeUpgrades', operation: 'add', value: 1 }] },
            { id: 'mod_buff_regen', name: 'Protocolo de Nanoreparos', command: 'enable --autorepair', description: 'Concede +0.3 HP de regenera√ß√£o passiva por segundo.', points: -4, effects: [{ stat: 'regenAmount', operation: 'add', value: 0.3 }] },
            { id: 'mod_buff_damage', name: 'Otimizador de Sa√≠da', command: 'set_dmg --amp 0.12', description: 'Aumenta todo o dano causado em +12%.', points: -5, effects: [{ stat: 'globalDamageFactor', operation: 'multiply', value: 1.12 }] },
            { id: 'mod_buff_speed', name: 'Overclock de Mobilidade', command: 'set_speed --factor 1.10', description: 'Aumenta a velocidade de movimento em +10%.', points: -3, effects: [{ stat: 'speed', operation: 'multiply', value: 1.10 }] },
            { id: 'mod_buff_health', name: 'Casco Refor√ßado', command: 'patch --integrity', description: 'Aumenta a vida m√°xima inicial em +20%.', points: -4, effects: [{ stat: 'maxHealth', operation: 'multiply', value: 1.20 }] },
            { id: 'mod_buff_crit', name: 'An√°lise de Fraqueza', command: 'load --crit_matrix', description: 'Aumenta a chance de acerto cr√≠tico em +8%.', points: -4, effects: [{ stat: 'critChance', operation: 'add', value: 0.08 }] },
            { id: 'mod_buff_xp', name: 'Dados Privilegiados', command: 'set_xp --mod 0.15', description: 'Ganha 15% a mais de experi√™ncia de todas as fontes.', points: -3, effects: [{ stat: 'expModifier', operation: 'add', value: 0.15 }] },
            { id: 'mod_buff_magnet', name: 'Campo de Atra√ß√£o', command: 'extend --magnet', description: 'Aumenta o raio de coleta de orbes em +35%.', points: -2, effects: [{ stat: 'xpMagnetRadius', operation: 'multiply', value: 1.35 }] },
            { id: 'mod_buff_reroll', name: 'Recursos Iniciais', command: 'grant --resources', description: 'Comece com +1 Reroll e +1 Op√ß√£o de Upgrade a cada n√≠vel.', points: -2, effects: [{ stat: 'initialRerolls', operation: 'add', value: 1 }, { stat: 'extraUpgradeChoices', operation: 'add', value: 1 }] },
            { id: 'mod_buff_less_boss_hp', name: 'Ponto Fraco Exposto', command: 'scan --boss_vuln', description: 'Chefes t√™m 15% a menos de vida.', points: -4, effects: [{ stat: 'bossHealthMultiplier', operation: 'multiply', value: 0.85 }] },

            // === DEBUFFS PARA O JOGADOR (CONCEDEM PONTOS - valor positivo) ===
            { id: 'mod_debuff_enemy_speed', name: 'Processos Acelerados', command: 'threat_mod --speed 1.15', description: 'Todos os inimigos s√£o 15% mais r√°pidos.', points: 4, effects: [{ stat: 'enemySpeedMultiplier', operation: 'multiply', value: 1.15 }] },
            { id: 'mod_debuff_enemy_hp', name: 'Blindagem Inimiga', command: 'threat_mod --hp 1.20', description: 'Todos os inimigos t√™m 20% a mais de vida.', points: 3, effects: [{ stat: 'enemyHealthMultiplier', operation: 'multiply', value: 1.20 }] },
            { id: 'mod_debuff_less_xp', name: 'Corrup√ß√£o de Dados', command: 'filter_xp --level 0.85', description: 'Voc√™ ganha 15% a menos de experi√™ncia.', points: 3, effects: [{ stat: 'expModifier', operation: 'add', value: -0.15 }] },
            { id: 'mod_debuff_player_slow', name: 'Sistema Lento', command: 'throttle --self', description: 'Sua velocidade de movimento √© reduzida em -10%.', points: 5, effects: [{ stat: 'speed', operation: 'multiply', value: 0.90 }] },
            { id: 'mod_debuff_less_health_pickups', name: 'Recursos Escassos', command: 'set_drops --rare', description: 'A chance de Orbes de Vida aparecerem √© reduzida em 40%.', points: 2, effects: [{ stat: 'healthPickupSpawnRateMultiplier', operation: 'multiply', value: 0.60 }] },
            { id: 'mod_debuff_more_elites', name: 'Evolu√ß√£o Agressiva', command: 'promote --elites 0.10', description: 'Inimigos t√™m 10% de chance de se tornarem uma variante Elite (vida e dano dobrados).', points: 3, effects: [{ stat: 'eliteChance', operation: 'set', value: 0.10 }] },
            { id: 'mod_debuff_no_invincibility', name: 'Vulnerabilidade Exposta', command: 'patch --no_iframes', description: 'Remove os frames de invencibilidade ap√≥s sofrer dano.', points: 5, effects: [{ stat: 'damageCooldown', operation: 'set', value: 50 }] },
            { id: 'mod_debuff_boss_rush', name: 'Confronto Direto', command: 'trigger --boss_rush', description: 'Os Chefes aparecem 60 segundos mais cedo.', points: 2, effects: [{ stat: 'bossTimerModifier', operation: 'add', value: -60 }] },
            { id: 'mod_debuff_enemy_damage', name: 'Armamento Aprimorado', command: 'threat_mod --dmg 1.20', description: 'Inimigos causam 20% a mais de dano.', points: 4, effects: [{ stat: 'enemyDamageMultiplier', operation: 'multiply', value: 1.20 }] },
            { id: 'mod_debuff_expensive_upgrades', name: 'Crise de Processamento', command: 'set_cost --high', description: 'Voc√™ precisa de 25% a mais de XP para subir de n√≠vel.', points: 4, effects: [{ stat: 'expToNextLevelMultiplier', operation: 'multiply', value: 1.25 }] },
        ];
        // --- END OF NEW MODIFIER DEFINITIONS ---

        const getEnemySpawnPosition = () => {
            const side = Math.floor(Math.random() * 4);
            let x = 0, y = 0;
            const padding = 30; 
            if (side === 0) { x = Math.random() * CANVAS_WIDTH; y = -padding; } 
            else if (side === 1) { x = CANVAS_WIDTH + padding; y = Math.random() * CANVAS_HEIGHT; } 
            else if (side === 2) { x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT + padding; } 
            else { x = -padding; y = Math.random() * CANVAS_HEIGHT; } 
            return { x, y };
        };

        const getRandomCanvasPosition = (padding = 50) => {
            return {
                x: padding + Math.random() * (CANVAS_WIDTH - padding * 2),
                y: padding + Math.random() * (CANVAS_HEIGHT - padding * 2),
            };
        };
        // --- END OF constants.ts ---

        // --- START OF utils/helpers.ts ---
        const formatTime = (totalSeconds) => {
            if (typeof totalSeconds !== 'number' || isNaN(totalSeconds)) totalSeconds = 0;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };

        const calculateDistance = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const dx = pos1.x - pos2.x;
            const dy = pos1.y - pos2.y;
            return Math.sqrt(dx * dx + dy * dy);
        };

        // >>> ADICIONE ESTA FUN√á√ÉO AQUI <<<
        const calculateDistanceSq = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const dx = pos1.x - pos2.x;
            const dy = pos1.y - pos2.y;
            return dx * dx + dy * dy; // A √∫nica mudan√ßa √© remover Math.sqrt()
        };

        const normalizeVector = (pos) => {
            const magnitude = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
            if (magnitude === 0) return { x: 0, y: 0 };
            return { x: pos.x / magnitude, y: pos.y / magnitude };
        };
        // --- END OF utils/helpers.ts ---

        // --- START OF utils/ProfileManager.ts ---
        const PROFILE_KEY = 'os_survivors_user_profile';

        function getOrCreateProfile() {
            try {
                const storedProfile = localStorage.getItem(PROFILE_KEY);
                if (storedProfile) {
                    const parsedProfile = JSON.parse(storedProfile);
                    // Garante que o perfil tem todos os campos esperados
                    const defaultProfile = getNewProfileStructure();
                    return { ...defaultProfile, ...parsedProfile };
                }
            } catch (e) {
                console.error("Failed to parse user profile, creating a new one.", e);
            }
            
            const newProfile = getNewProfileStructure();
            saveProfile(newProfile);
            return newProfile;
        }

        function getNewProfileStructure() {
            return {
                userId: crypto.randomUUID(),
                username: `Processo_${Math.random().toString(16).substr(2, 4).toUpperCase()}`,
                bio: "Defendendo o Kernel, um processo de cada vez.",
                createdAt: new Date().toISOString(),
                equippedAvatarId: 'avatar_default',
                equippedTitleId: 'title_survivor',
                equippedBannerId: 'banner_grid',
                featuredAchievementIds: [],
                featuredStatKeys: [],
            };
        }

        function saveProfile(profile) {
            localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
        }
        // --- END OF utils/ProfileManager.ts ---

        // --- START OF game/upgrades.ts ---
                const UPGRADE_POOL = [
            // --- ARMAS NOVAS ---
            {
                id: 'weapon_antivirus', title: 'Instalar Antiv√≠rus', description: 'Dispara automaticamente no inimigo mais pr√≥ximo.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'antivirus')) {
                        weapons.push({ id: 'antivirus', level: 1, lastShotTime: 0, isEvolved: false });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            {
                id: 'weapon_firewall', title: 'Instalar Firewall', description: 'Cria um escudo orbital que causa dano.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'firewall')) {
                        weapons.push({
                            id: 'firewall', level: 1, orbs: FIREWALL_STATS.initialOrbs, currentAngle: 0,
                            lastShardTimes: {}, orbHitCooldowns: {}, isEvolved: false
                        });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            {
                id: 'weapon_acid_virus', title: 'Instalar V√≠rus √Åcido', description: 'Dispara um proj√©til que cria uma po√ßa de dados corrosivos no impacto, causando dano cont√≠nuo aos inimigos.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'acid_virus')) {
                         weapons.push({ id: 'acid_virus', level: 1, lastShotTime: 0, isEvolved: false });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
             {
                id: 'weapon_defrag', title: 'Instalar Desfragmentador', description: 'Ataque em arco de curto alcance que atinge m√∫ltiplos alvos.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'defrag')) {
                         weapons.push({ id: 'defrag', level: 1, lastShotTime: 0, isEvolved: false, comboCounter: 0 });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
             {
                id: 'weapon_data_leech', title: 'Instalar Data Leech', description: 'Raio cont√≠nuo no inimigo mais pr√≥ximo. Causa mais dano ao ficar parado.',
                level: 0, maxLevel: 1, type: 'weapon_new',
                apply: (player, weapons) => {
                    if (!weapons.find(w => w.id === 'data_leech')) {
                         weapons.push({ 
                             id: 'data_leech', level: 1, lastTickTime: 0, targetId: null,
                             stillTime: 0, lastPlayerPos: {x: player.position.x, y: player.position.y},
                             isEvolved: false,
                             isCriticallySurging: false,
                             critSurgeEndTime: 0,
                             lastCritCheckTime: 0,
                        });
                    } return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            // --- UPGRADES ANTIVIRUS ---
            {
                id: 'antivirus_rate', title: 'Antiv√≠rus: Overclock', description: 'Aumenta a cad√™ncia de tiro em 15%.',
                level: 0, maxLevel: 5, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w }) 
            },
            {
                id: 'antivirus_damage', title: 'Antiv√≠rus: DB Update', description: 'Aumenta o dano do proj√©til em 8.',
                level: 0, maxLevel: 5, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'antivirus_pierce', title: 'Antiv√≠rus: Heur√≠stica Penetrante', description: 'Proj√©teis atravessam +1 inimigo.',
                level: 0, maxLevel: 3, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'antivirus_cryo_rounds', title: 'Antiv√≠rus: Crio-Muni√ß√£o', 
                description: (level) => level < 4 
                    ? `Proj√©teis t√™m ${20 + level * 5}% de chance de aplicar LENTID√ÉO.`
                    : `Proj√©teis agora t√™m 15% de chance de CONGELAR inimigos por ${STATUS_EFFECT_PARAMS[StatusEffectType.FREEZE].baseDuration / 1000}s.`,
                level: 0, maxLevel: 4, requires: 'weapon_antivirus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w }) 
            },
            // --- UPGRADES FIREWALL ---
            {
                id: 'firewall_orbs', title: 'Firewall: Multi-Core', description: 'Adiciona +1 escudo orbital.',
                level: 0, maxLevel: 4, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (player, weapons) => {
                    const firewall = weapons.find(w => w.id === 'firewall');
                    if (firewall && firewall.orbs !== undefined) firewall.orbs++;
                    return { updatedPlayer: player, updatedWeapons: weapons };
                }
            },
            {
                id: 'firewall_damage', title: 'Firewall: Heur√≠stica Avan√ßada', description: 'Aumenta o dano do escudo em 8.',
                level: 0, maxLevel: 5, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'firewall_shards', title: 'Firewall: Fragmentos de Dados', description: 'Escudos disparam fragmentos (+dano/freq).',
                level: 0, maxLevel: 3, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
             {
                id: 'firewall_vulnerability_matrix', title: 'Firewall: Matriz de Vulnerabilidade', description: (level) => `Escudos aplicam VULNERABILIDADE por ${STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseDuration/1000}s (inimigos recebem +${Math.round(((STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseMagnitude + (level-1)*0.05)-1)*100)}% dano).`,
                level: 0, maxLevel: 3, requires: 'weapon_firewall', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            // --- UPGRADES V√çRUS √ÅCIDO ---
            {
                id: 'acid_virus_potency', title: 'V√≠rus √Åcido: Potencializar Corros√£o', description: 'Aumenta o dano da po√ßa de √°cido em 3 por tick.',
                level: 0, maxLevel: 5, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'acid_virus_spread', title: 'V√≠rus √Åcido: Agente Expansivo', description: 'Aumenta a √°rea de efeito da po√ßa em 15%.',
                level: 0, maxLevel: 4, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'acid_virus_duration', title: 'V√≠rus √Åcido: Estabilizador Qu√≠mico', description: 'Aumenta a dura√ß√£o da po√ßa de √°cido em 1 segundo.',
                level: 0, maxLevel: 4, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'acid_virus_viscosity', title: 'V√≠rus √Åcido: Aumento de Viscosidade', description: 'Inimigos dentro da po√ßa t√™m sua velocidade de movimento reduzida (LENTID√ÉO).',
                level: 0, maxLevel: 1, requires: 'weapon_acid_virus', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            // --- UPGRADES DEFRAGMENTADOR ---
            {
                id: 'defrag_damage', title: 'Defrag: Otimizar Sincronia', description: 'Aumenta o dano do ataque em 12.',
                level: 0, maxLevel: 5, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'defrag_cooldown', title: 'Defrag: Acelerar Leitura', description: 'Reduz a recarga do ataque em 12%.',
                level: 0, maxLevel: 4, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'defrag_range', title: 'Defrag: Ampliar Setor', description: 'Aumenta o alcance de todos os ataques em 15%.',
                level: 0, maxLevel: 4, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'defrag_fragments', title: 'Defrag: Fragmentos Otimizados', description: 'O ataque girat√≥rio agora dispara 6 fragmentos perfurantes em todas as dire√ß√µes.',
                level: 0, maxLevel: 3, requires: 'weapon_defrag', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
             // --- UPGRADES DATA LEECH ---
            {
                id: 'leech_damage', title: 'Data Leech: Aumentar Largura de Banda', description: 'Aumenta o dano base em 7.5 por segundo.',
                level: 0, maxLevel: 5, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'leech_range', title: 'Data Leech: Otimizar Conex√£o', description: 'Aumenta o alcance do raio em 20%.',
                level: 0, maxLevel: 4, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'leech_slow', title: 'Data Leech: Corromper Dados', description: 'Raio aplica LENTID√ÉO no alvo prim√°rio.',
                level: 0, maxLevel: 1, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            {
                id: 'leech_chain', title: 'Data Leech: Conex√µes M√∫ltiplas', description: 'O raio atinge +1 alvo pr√≥ximo com 50% do dano.',
                level: 0, maxLevel: 3, requires: 'weapon_data_leech', type: 'weapon_upgrade',
                apply: (p, w) => ({ updatedPlayer: p, updatedWeapons: w })
            },
            // --- UPGRADES PASSIVOS ---
            {
                id: 'player_speed', title: 'Otimiza√ß√£o de Clock', description: 'Aumenta sua velocidade em 10%.',
                level: 0, maxLevel: 5, type: 'player_passive',
                apply: (player, weapons) => { player.speed *= 1.1; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_health', title: 'Parti√ß√£o de Backup', description: 'Aumenta sua vida m√°xima em 25.',
                level: 0, maxLevel: 5, type: 'player_passive',
                apply: (player, weapons) => { player.maxHealth += 25; player.health += 25; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_magnet', title: 'Coletor de Dados', description: 'Atrai experi√™ncia e vida de uma √°rea maior.',
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { player.xpMagnetRadius += 50; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_exp_boost', title: 'Cache L3', description: 'Ganha 10% a mais de experi√™ncia.',
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { player.expModifier += 0.1; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_cooldown', title: 'Overclock Global', description: 'Reduz a recarga de todas as armas em 8%.',
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { player.cooldownModifier *= 0.92; return { updatedPlayer: player, updatedWeapons: weapons }; }
            },
            {
                id: 'player_regen', title: 'N√∫cleo Regenerativo', 
                description: (level) => `Regenera +${(level * 2.5).toFixed(1)} HP a cada 5 segundos.`,
                level: 0, maxLevel: 4, type: 'player_passive',
                apply: (player, weapons) => { 
                    player.regenAmount = (player.regenAmount || 0) + 0.5;
                    return { updatedPlayer: player, updatedWeapons: weapons }; 
                } 
            },
            {
                id: 'player_overdrive', title: 'Sistema de Sobrecarga', 
                description: (level) => `Abaixo de 25% HP: Invencibilidade e +${15 + level * 5}% Dano por 5s. (Cooldown: 30s)`,
                level: 0, maxLevel: 3, type: 'player_passive',
                apply: (player, weapons) => { return { updatedPlayer: player, updatedWeapons: weapons }; } 
            },
            {
                id: 'passive_fear_protocol', title: 'Protocolo de P√¢nico Induzido', description: (level) => `Ao receber dano, ${15 + level * 5}% de chance de causar MEDO em inimigos pr√≥ximos por ${STATUS_EFFECT_PARAMS[StatusEffectType.FEAR].baseDuration/1000}s.`,
                level: 0, maxLevel: 3, type: 'player_passive',
                apply: (p,w) => ({updatedPlayer: p, updatedWeapons: w})
            }
        ];
        // --- END OF game/upgrades.ts ---

        // --- START OF game/evolutions.ts ---
        const WEAPON_EVOLUTIONS = [
            {
                evolutionId: "evolution_antivirus_system_purge",
                name: "System Purge Protocol",
                description: "Antivirus dispara uma devastadora rajada de 3 proj√©teis teleguiados com dano e tamanho aumentados.",
                baseWeaponId: "antivirus",
                requiredUpgradeIds: [
                    { id: "antivirus_damage", level: 5 },
                    { id: "antivirus_rate", level: 5 }
                ],
                catalystPassiveId: "player_cooldown",
                evolvedWeaponProperties: {
                    newId: "antivirus_system_purge",
                }
            },
            {
                evolutionId: "evolution_firewall_aegis_shield",
                name: "Aegis Shield",
                description: "Escudos do Firewall ficam maiores, causam mais dano de contato e pulsam uma onda de dano periodicamente. Fragmentos s√£o aprimorados.",
                baseWeaponId: "firewall",
                requiredUpgradeIds: [
                    { id: "firewall_orbs", level: 4 },
                    { id: "firewall_damage", level: 5 }
                ],
                catalystPassiveId: "player_health",
                evolvedWeaponProperties: {
                    newId: "firewall_aegis_shield",
                }
            },
            {
                evolutionId: "evolution_acid_virus_pandemic",
                name: "Pandemia Corrosiva",
                description: "Po√ßas de √°cido aplicam VULNERABILIDADE. Inimigos derrotados dentro da po√ßa explodem, lan√ßando um esporo teleguiado que cria uma nova po√ßa de √°cido, espalhando a infec√ß√£o.",
                baseWeaponId: "acid_virus",
                requiredUpgradeIds: [
                    { id: "acid_virus_potency", level: 5 },
                    { id: "acid_virus_spread", level: 4 },
                    { id: "acid_virus_duration", level: 4 },
                    { id: "acid_virus_viscosity", level: 1 }
                ],
                catalystPassiveId: "player_overdrive",
                evolvedWeaponProperties: {
                    newId: "acid_virus_pandemic",
                }
            },
            {
                evolutionId: "evolution_antivirus_hunter_swarm",
                name: "Hunter-Seeker Swarm",
                description: "Proj√©teis do Antivirus se tornam m√≠sseis teleguiados mais lentos que aplicam dano cont√≠nuo (DoT).",
                baseWeaponId: "antivirus",
                requiredUpgradeIds: [
                    { id: "antivirus_pierce", level: 3 },
                    { id: "antivirus_damage", level: 5 } 
                ],
                catalystPassiveId: "player_magnet", 
                evolvedWeaponProperties: {
                    newId: "antivirus_hunter_swarm",
                }
            },
            {
                evolutionId: "evolution_antivirus_tesla_coil",
                name: "Antivirus: Protocolo Tesla",
                description: "Proj√©teis do Antivirus agora ricocheteiam entre inimigos pr√≥ximos, causando dano el√©trico em cadeia. Dano reduzido por salto.",
                baseWeaponId: "antivirus",
                requiredUpgradeIds: [
                    { id: "antivirus_cryo_rounds", level: 4 }, 
                    { id: "antivirus_rate", level: 5 }
                ],
                catalystPassiveId: "player_speed", 
                evolvedWeaponProperties: {
                    newId: "antivirus_tesla_coil",
                }
            },
            {
                evolutionId: "evolution_defrag_quantum_optimizer",
                name: "Otimizador Qu√¢ntico",
                description: "O ciclo de combo √© removido. TODOS os ataques s√£o giros de 360¬∞ que disparam Fragmentos Otimizados. Cad√™ncia e dano aumentados.",
                baseWeaponId: "defrag",
                requiredUpgradeIds: [
                    { id: "defrag_damage", level: 5 },
                    { id: "defrag_range", level: 4 },
                    { id: "defrag_fragments", level: 3 }
                ],
                catalystPassiveId: "player_speed",
                evolvedWeaponProperties: {
                    newId: "defrag_quantum_optimizer",
                }
            },
            {
                evolutionId: "evolution_leech_siphon_chain",
                name: "Corrente de Sif√£o",
                description: "Aumenta o n√∫mero de alvos em +4. Inimigos derrotados pelo raio t√™m 25% de chance de gerar um orbe que cura 5 HP.",
                baseWeaponId: "data_leech",
                requiredUpgradeIds: [
                    { id: "leech_chain", level: 3 },
                    { id: "leech_range", level: 4 }
                ],
                catalystPassiveId: "player_magnet",
                evolvedWeaponProperties: {
                    newId: "leech_siphon_chain",
                }
            }
        ];
        // --- END OF game/evolutions.ts ---

        // --- START OF hooks/useGameEngine.ts ---
const { useState: useGameEngineState, useCallback: useGameEngineCallback, useRef: useGameEngineRef, useEffect: useGameEngineEffect } = React;

const createPlayer = (permanentBuffs = {}, achievementBuffs = {}, selectedSkinId, modifierIds = []) => {
    // ESTA FUN√á√ÉO PERMANECE ID√äNTICA. N√£o precisa de Immer pois ela cria um objeto novo do zero.
    const selectedClass = CLASS_DEFINITIONS.find(c => c.id === permanentBuffs.selectedClassId) || CLASS_DEFINITIONS[0];

    let currentSpeed = PLAYER_INITIAL_STATS.baseSpeed;
    let currentMaxHealth = PLAYER_INITIAL_STATS.baseMaxHealth;
    let currentXpMagnetRadius = PLAYER_INITIAL_STATS.baseXpMagnetRadius;
    let currentExpModifier = PLAYER_INITIAL_STATS.baseExpModifier;
    let currentCooldownModifier = PLAYER_INITIAL_STATS.baseCooldownModifier;
    let currentGlobalDamageFactor = PLAYER_INITIAL_STATS.globalDamageFactor;
    let currentDamageReduction = PLAYER_INITIAL_STATS.baseDamageReduction;
    let currentCritChance = PLAYER_INITIAL_STATS.baseCritChance;
    let currentCritDamage = PLAYER_INITIAL_STATS.baseCritDamage;
    let dashCooldownModifier = 1.0;
    let currentRegenAmount = PLAYER_INITIAL_STATS.regenAmount;
    let currentStatusEffectDuration = PLAYER_INITIAL_STATS.statusEffectDuration;
    let currentProjectileSpeed = 1.0;
    let dashDurationModifier = 1.0;
    let lastStandCharges = 0;
    
    // New stats from corrupted tree
    let hpBonusMultiplier = 1.0;
    let dotDamageReduction = 0.0;
    let lastStandHealthPercent = 0.01; // Default to 1 HP (or 1%)
    let lastStandSpeedBoost = false;
    let baseDamageMultiplier = 1.0;
    let projectileRangeMultiplier = 1.0;
    let initialLevel = 1;
    let hasInitialFreeUpgrade = false;
    let extraUpgradeChoices = 0;
    let hasInfiniteFury = false;


    if (selectedClass.statModifiers) {
        currentSpeed += selectedClass.statModifiers.baseSpeed || 0;
        currentMaxHealth += selectedClass.statModifiers.baseMaxHealth || 0;
        currentXpMagnetRadius += selectedClass.statModifiers.baseXpMagnetRadius || 0;
        currentExpModifier += selectedClass.statModifiers.baseExpModifier || 0;
        currentGlobalDamageFactor += selectedClass.statModifiers.globalDamageFactor || 0;
    }
    
    const allTalents = TALENT_TREE_CONFIG;
    allTalents.forEach(talentConfig => {
        const purchasedLevel = permanentBuffs.shop[talentConfig.id] || 0;
        if (purchasedLevel > 0) {
            const totalBonus = talentConfig.bonusPerLevel * purchasedLevel;
            switch (talentConfig.statAffected) {
                case 'speed': currentSpeed *= (1 + totalBonus); break;
                case 'maxHealth': currentMaxHealth += totalBonus; break;
                case 'expModifier': currentExpModifier += totalBonus; break;
                case 'cooldownModifier': currentCooldownModifier -= totalBonus; break;
                case 'damageReduction': currentDamageReduction += totalBonus; break;
                case 'globalDamageFactor': currentGlobalDamageFactor += totalBonus; break;
                case 'regenAmount': currentRegenAmount += totalBonus; break;
                case 'statusEffectDuration': currentStatusEffectDuration += totalBonus; break;
                case 'projectileSpeed': currentProjectileSpeed += totalBonus; break;
                case 'critChance': currentCritChance += totalBonus; break;
                case 'critDamage': currentCritDamage += totalBonus; break;
                case 'dashDuration': dashDurationModifier += totalBonus; break;
                case 'xpMagnetRadius': currentXpMagnetRadius *= (1 + totalBonus); break;
                case 'lastStandCharges': lastStandCharges += totalBonus; break;
                case 'redundancyProtocol':
                    if (purchasedLevel > 0) {
                        currentDamageReduction += 0.05;
                        currentRegenAmount += 1.5;
                    }
                    break;
                case 'ultimate':
                    if (purchasedLevel > 0) {
                        currentMaxHealth *= (1 + totalBonus);
                        currentGlobalDamageFactor += totalBonus;
                        currentSpeed *= (1 + totalBonus);
                    }
                    break;
                // Corrupted Talents
                case 'hpBonusMultiplier': hpBonusMultiplier += totalBonus; break;
                case 'dotDamageReduction': dotDamageReduction = 0.15 + 0.10 * purchasedLevel; break;
                case 'dashCooldownAndDuration':
                    const dashTalent = allTalents.find(t => t.id === talentConfig.id);
                    if (dashTalent) {
                        dashCooldownModifier -= dashTalent.bonusPerLevel.cooldown * purchasedLevel;
                        dashDurationModifier += dashTalent.bonusPerLevel.duration * purchasedLevel;
                    }
                    break;
                case 'lastStandUpgrade': if(purchasedLevel > 0) { lastStandHealthPercent = 0.25; lastStandSpeedBoost = true; } break;
                case 'baseDamage': baseDamageMultiplier += totalBonus; break;
                case 'projectileRange': projectileRangeMultiplier += totalBonus; break;
                case 'protocolRewrite': if(purchasedLevel > 0) { extraUpgradeChoices += 1; } break;
                case 'infiniteFury': if(purchasedLevel > 0) hasInfiniteFury = true; break;
                case 'ultimateCorrupted':
                        if (purchasedLevel > 0) {
                        currentMaxHealth *= (1 + totalBonus);
                        currentGlobalDamageFactor += totalBonus;
                        currentSpeed *= (1 + totalBonus);
                    }
                    break;
            }
        }
    });

    Object.keys(achievementBuffs).forEach(stat => {
        const bonus = achievementBuffs[stat];
        switch (stat) {
            case 'speed': currentSpeed += bonus; break;
            case 'maxHealth': 
                if (stat === 'maxHealth' && bonus < 1) { // Handle percentage-based HP buffs
                        currentMaxHealth *= (1 + bonus);
                } else {
                    currentMaxHealth += bonus;
                }
                break;
            case 'expModifier': currentExpModifier += bonus; break;
            case 'cooldownModifier': currentCooldownModifier += bonus; break;
            case 'globalDamageFactor': currentGlobalDamageFactor += bonus; break;
            case 'damageReduction': currentDamageReduction += bonus; break;
            case 'xpMagnetRadius': currentXpMagnetRadius *= (1 + bonus); break;
            case 'dashCooldown': dashCooldownModifier -= bonus; break;
            case 'critDamage': currentCritDamage += bonus; break;
            case 'statusEffectDuration': currentStatusEffectDuration += bonus; break;
            case 'initialRerolls': extraUpgradeChoices += bonus; break;
        }
    });

    const activeModifiers = modifierIds.map(id => MODIFIER_DEFINITIONS.find(m => m.id === id)).filter(Boolean);

    activeModifiers.forEach(mod => {
        (mod.effects || []).forEach(effect => {
            switch(effect.stat) {
                case 'globalDamageFactor': if(effect.operation === 'multiply') currentGlobalDamageFactor *= effect.value; break;
                case 'maxHealth': if(effect.operation === 'multiply') currentMaxHealth *= effect.value; break;
                case 'speed': if(effect.operation === 'multiply') currentSpeed *= effect.value; break;
                case 'critChance': if(effect.operation === 'add') currentCritChance += effect.value; break;
                case 'regenAmount': if(effect.operation === 'add') currentRegenAmount += effect.value; break;
                case 'expModifier': if(effect.operation === 'add') currentExpModifier += effect.value; break;
                case 'xpMagnetRadius': if(effect.operation === 'multiply') currentXpMagnetRadius *= effect.value; break;
                case 'initialRerolls': if(effect.operation === 'add') extraUpgradeChoices += effect.value; break;
                case 'extraUpgradeChoices': if(effect.operation === 'add') extraUpgradeChoices += effect.value; break;
            }
        });
    });

    currentMaxHealth = Math.ceil(currentMaxHealth * hpBonusMultiplier);
    currentGlobalDamageFactor *= baseDamageMultiplier;
    currentProjectileSpeed *= projectileRangeMultiplier;
    
    currentCooldownModifier = Math.max(0.1, currentCooldownModifier);
    currentMaxHealth = Math.max(10, currentMaxHealth);
    currentSpeed = Math.max(50, currentSpeed);
    currentDamageReduction = Math.max(0, Math.min(0.9, currentDamageReduction));

    const activePassives = [];
    if (selectedClass.uniquePassive) {
        activePassives.push(selectedClass.uniquePassive.id);
    }
    
    const uniquePassiveData = {};
    if (selectedClass.id === 'class_technomancer') {
        uniquePassiveData.commandMode = 'ASSAULT';
        uniquePassiveData.lastCommandSwitch = 0;
    }

    return {
        id: `player-${Date.now()}`, classId: selectedClass.id, color: selectedClass.iconColor,
        skinId: selectedSkinId || 'skin_default',
        position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 }, velocity: { x: 0, y: 0 },
        size: PLAYER_INITIAL_STATS.size, speed: currentSpeed, maxHealth: currentMaxHealth, health: currentMaxHealth,
        damageReduction: currentDamageReduction,
        dotDamageReduction,
        regenAmount: currentRegenAmount,
        critChance: currentCritChance, critDamage: currentCritDamage,
        statusEffectDuration: currentStatusEffectDuration,
        projectileSpeedModifier: currentProjectileSpeed,
        projectileRangeModifier: projectileRangeMultiplier,
        lastHitTime: 0, weapons: [], xpMagnetRadius: currentXpMagnetRadius, expModifier: currentExpModifier,
        cooldownModifier: currentCooldownModifier, globalDamageFactor: currentGlobalDamageFactor,
        lastRegenTime: 0, overdriveActive: false, overdriveEndTime: 0, overdriveCooldownUntil: 0,
        overdriveDamageBonusFactor: 1, activeUniquePassiveIds: activePassives, uniquePassiveData,
        lastMoveDirection: { ...PLAYER_INITIAL_STATS.lastMoveDirection }, isDashing: false, dashEndTime: 0,
        dashCooldownUntil: 0, dashCooldownModifier: dashCooldownModifier, dashDirection: { x: 0, y: 0 }, temporaryBuffs: [],
        dashDurationModifier: dashDurationModifier,
        lastStandCharges: lastStandCharges, lastStandUsed: false,
        lastStandHealthPercent: lastStandHealthPercent,
        lastStandSpeedBoost: lastStandSpeedBoost,
        initialLevel, hasInitialFreeUpgrade,
        extraUpgradeChoices,
        hasInfiniteFury,
        furyStacks: 0,
        activeModifiers,
    };
};
    
const useGameEngine = (
    onGameOverCallback,
    onLevelUpCallback,
    isGameActive,
    onBossWarningStartCallback,
    onBossFightStartCallback,
    onStageClearCallback,
    permanentBuffs = {},
    achievementBuffs = {},
    decompilerBonuses = {},
    weaponMasteryStats = {}
) => {
    const sessionStatsRef = useGameEngineRef(null);

    const getInitialSessionStats = () => ({
        kills: Object.fromEntries(Object.values(EnemyType).map(type => [type, 0])),
        totalKills: 0,
        damageTaken: 0,
        damageDealtByWeapon: {},
        damageTakenDuringBoss: {},
        levelReached: 1,
        timeSurvived: 0,
        score: 0,
        evolvedWeapons: new Set(),
        defeatedBosses: new Set(),
        dataCachesCollectedInSession: 0,
        killsWhileBuffedInSession: 0,
        damageTakenInFirst5Minutes: 0,
        dashUsedInSession: false,
        reachedInfiniteMode: false,
        totalXpOrbsCollected: 0,
        totalDashes: 0,
        timeWithoutMoving: 0,
        lastMoveTime: 0,
        evolvedWeaponIds: new Set(),
        healthPickupsCollected: 0, 
        isNightmareMode: false,
        weaponsAcquiredCount: 0,
        corruptedLibrariesCleansed: 0,
        corruptedKernelsEarnedInSession: 0,
        furyKillCounter: 0,
    });

    const [gameState, setGameState] = useImmerState(() => {
        const initialPlayer = createPlayer(permanentBuffs, achievementBuffs, permanentBuffs.selectedSkinId);
        return {
            player: initialPlayer,
            enemies: [], projectiles: [], particles: [], expOrbs: [], healthPickups: [], corruptedZones: [],
            acidPuddles: [], 
            revivingProcesses: [], dataWalls: [], laserBeams: [],
            interactables: [], alliedMinions: [],
            knowledgeOrbs: [],
            unstableSectors: [],
            ramSockets: [],
            bossAttacks: [],
            score: 0, experience: 0, level: initialPlayer.initialLevel, expToNextLevel: INITIAL_EXP_TO_NEXT_LEVEL,
            gameTime: 0, isPaused: false, keys: { w: false, a: false, s: false, d: false, ' ': false }, 
            nextEnemySpawnTime: Date.now() + ENEMY_SPAWN_INITIAL_DELAY,
            nextHealthPickupSpawnTime: Date.now() + HEALTH_PICKUP_STATS.spawnIntervalMin + Math.random() * (HEALTH_PICKUP_STATS.spawnIntervalMax - HEALTH_PICKUP_STATS.spawnIntervalMin),
            nextInteractableSpawnTime: Date.now() + INTERACTABLE_STATS.SPAWN_INTERVAL_MIN,
            nextUnstableSectorTime: 0,
            boss: null,
            bossShieldNodes: [],
            isBossEventTriggered: false,
            stage: 1, 
            isInfiniteMode: false,
            isNightmareMode: false,
            eventActive: null,
            eventKillCounter: 0,
            eventKillsSoFar: 0,
            dataVault: null,
        };
    });
    const ownedUpgradesRef = useGameEngineRef(new Map()); 

    const resetGame = useAppCallback((newPermanentBuffs, newAchievementBuffs, newSelectedSkinId, isNightmare, modifierIds = []) => {
        setGameState(draft => {
            const initialPlayer = createPlayer(newPermanentBuffs, newAchievementBuffs, newSelectedSkinId, modifierIds);
            ownedUpgradesRef.current.clear();
            sessionStatsRef.current = getInitialSessionStats();
            sessionStatsRef.current.isNightmareMode = isNightmare;
            sessionStatsRef.current.lastMoveTime = Date.now();
            skinStateCache = {};

            const selectedClassDef = CLASS_DEFINITIONS.find(c => c.id === newPermanentBuffs.selectedClassId) || CLASS_DEFINITIONS[0];
            const startingWeaponId = selectedClassDef.startingWeaponId;
            let initialWeapons = [];

            if(startingWeaponId){
                const startingWeaponUpgradeId = `weapon_${startingWeaponId}`;
                const startingWeaponUpgrade = UPGRADE_POOL.find(u => u.id === startingWeaponUpgradeId);
                if (startingWeaponUpgrade && startingWeaponUpgrade.type === 'weapon_new') {
                    const tempDraftState = { player: { ...initialPlayer }, weapons: [] };
                    startingWeaponUpgrade.apply(tempDraftState.player, tempDraftState.weapons);
                    initialWeapons = tempDraftState.weapons.map(w => ({...w, level: 1})); 
                    ownedUpgradesRef.current.set(startingWeaponUpgrade.id, 1);
                    sessionStatsRef.current.weaponsAcquiredCount = 1;
                }
            }
            
            const gameModifiers = {
                enemyHealthMultiplier: 1.0, enemySpeedMultiplier: 1.0, enemyDamageMultiplier: 1.0,
                bossHealthMultiplier: 1.0, healthPickupSpawnRateMultiplier: 1.0,
                expToNextLevelMultiplier: 1.0, bossTimerModifier: 0, eliteChance: 0
            };
            
            const activeModifiersOnReset = modifierIds.map(id => MODIFIER_DEFINITIONS.find(m => m.id === id)).filter(Boolean);
            
            activeModifiersOnReset.forEach(mod => {
                (mod.effects || []).forEach(effect => {
                    switch(effect.stat) {
                        case 'enemyHealthMultiplier': gameModifiers.enemyHealthMultiplier *= effect.value; break;
                        case 'enemySpeedMultiplier': gameModifiers.enemySpeedMultiplier *= effect.value; break;
                        case 'enemyDamageMultiplier': gameModifiers.enemyDamageMultiplier *= effect.value; break;
                        case 'bossHealthMultiplier': gameModifiers.bossHealthMultiplier *= effect.value; break;
                        case 'healthPickupSpawnRateMultiplier': gameModifiers.healthPickupSpawnRateMultiplier *= effect.value; break;
                        case 'expToNextLevelMultiplier': gameModifiers.expToNextLevelMultiplier *= effect.value; break;
                        case 'bossTimerModifier': gameModifiers.bossTimerModifier += effect.value; break;
                        case 'eliteChance': gameModifiers.eliteChance = effect.value; break;
                    }
                });
            });
            
            const startLevelMod = activeModifiersOnReset.find(m => m.effects.some(e => e.stat === 'initialLevel'));
            if (startLevelMod) {
                const levelEffect = startLevelMod.effects.find(e => e.stat === 'initialLevel');
                if (levelEffect.operation === 'add') initialPlayer.initialLevel += levelEffect.value;
            }
            const freeUpgradeMod = activeModifiersOnReset.find(m => m.effects.some(e => e.stat === 'initialFreeUpgrades'));
            if (freeUpgradeMod) {
                initialPlayer.hasInitialFreeUpgrade = true; 
            }

            Object.assign(draft, {
                player: {...initialPlayer, weapons: initialWeapons},
                enemies: [], projectiles: [], particles: [], expOrbs: [], healthPickups: [], corruptedZones: [],
                acidPuddles: [],
                revivingProcesses: [], dataWalls: [], laserBeams: [], interactables: [], alliedMinions: [],
                knowledgeOrbs: [], unstableSectors: [], ramSockets: [], bossAttacks: [],
                score: 0, experience: 0, level: initialPlayer.initialLevel,                     
                expToNextLevel: Math.floor(INITIAL_EXP_TO_NEXT_LEVEL * Math.pow(EXP_LEVEL_MULTIPLIER * gameModifiers.expToNextLevelMultiplier, initialPlayer.initialLevel - 1)),
                gameModifiers,
                gameTime: 0, isPaused: false, keys: { w: false, a: false, s: false, d: false, ' ': false },
                nextEnemySpawnTime: Date.now() + ENEMY_SPAWN_INITIAL_DELAY,
                nextHealthPickupSpawnTime: Date.now() + HEALTH_PICKUP_STATS.spawnIntervalMin + Math.random() * (HEALTH_PICKUP_STATS.spawnIntervalMax - HEALTH_PICKUP_STATS.spawnIntervalMin),
                nextInteractableSpawnTime: Date.now() + INTERACTABLE_STATS.SPAWN_INTERVAL_MIN + Math.random() * (INTERACTABLE_STATS.SPAWN_INTERVAL_MAX - INTERACTABLE_STATS.SPAWN_INTERVAL_MIN),
                nextUnstableSectorTime: Date.now() + 8000,
                boss: null,
                bossShieldNodes: [],
                isBossEventTriggered: false,
                stage: 1,
                isInfiniteMode: false,
                isNightmareMode: isNightmare,
                eventActive: null,
                eventKillCounter: 0,
                eventKillsSoFar: 0,
                dataVault: null,
            });

            if (initialPlayer.hasInitialFreeUpgrade) {
                const freeUpgradesCount = (freeUpgradeMod.effects.find(e => e.stat === 'initialFreeUpgrades') || {}).value || 0;
                for (let i = 0; i < freeUpgradesCount; i++) {
                    setTimeout(() => onLevelUpCallback(true), 100 * (i + 1));
                }
            }
        });
    }, [onLevelUpCallback, setGameState]);

    const spawnBoss = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 1) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const nightmareDamageMultiplier = isNightmareMode ? 1.25 : 1;
            const initialAngle = Math.random() * 2 * Math.PI;
            const bossData = {
                id: `boss-${now}`,
                bossType: 'guardian', 
                position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 4 },
                size: BOSS_STATS.size,
                coreSize: BOSS_STATS.coreSize,
                health: BOSS_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                damage: BOSS_STATS.damage * nightmareDamageMultiplier * draft.gameModifiers.enemyDamageMultiplier,
                color: GAME_COLORS.BOSS_CORE, speed: BOSS_STATS.speed,
                velocity: { x: Math.cos(initialAngle) * BOSS_STATS.speed, y: Math.sin(initialAngle) * BOSS_STATS.speed },
                phase: 1, isInvulnerable: true, 
                lastPhase1AttackTime: now, lastPhase2AttackTime: now, phase2BurstCounter: 0, lastPulseAttackTime: now,
                lastCorruptedZoneTime: now, lastGlitchMinionSpawnTime: now, lastDataStreamAttackTime: now,
                lastKernelPanicPulseTime: now, kernelPanicChargeStartTime: 0,
                statusEffects: [], 
            };
            const shieldNodes = [];
            for (let i = 0; i < BOSS_SHIELD_NODE_STATS.count; i++) {
                shieldNodes.push({
                    id: `shieldnode-${bossData.id}-${i}`,
                    angle: (Math.PI * 2 / BOSS_SHIELD_NODE_STATS.count) * i, position: { x: 0, y: 0 }, 
                    size: BOSS_SHIELD_NODE_STATS.size,
                    health: BOSS_SHIELD_NODE_STATS.maxHealth * nightmareMultiplier, maxHealth: BOSS_SHIELD_NODE_STATS.maxHealth * nightmareMultiplier,
                    color: GAME_COLORS.BOSS_SHIELD_NODE, statusEffects: [], 
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.bossShieldNodes = shieldNodes;
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);

    const spawnBoss2 = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 2) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const nightmareDamageMultiplier = isNightmareMode ? 1.25 : 1;

            const bossData = {
                id: `boss2-${now}`,
                bossType: 'sincronizador',
                position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                size: BOSS_2_STATS.size,
                health: BOSS_2_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_2_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                damage: BOSS_2_STATS.damage * nightmareDamageMultiplier * draft.gameModifiers.enemyDamageMultiplier,
                color: GAME_COLORS.BOSS_2_CORE, speed: 0, 
                phase: 1, isInvulnerable: true, 
                lastEnergyWaveTime: now,
                lastLaserTime: now,
                lastDataWallTime: now,
                lastMinionSpawnTime: now,
                lastNovaAttackTime: now,
                statusEffects: [], 
            };
            const subRoutines = [];
            for (let i = 0; i < BOSS_2_SUB_ROUTINE_STATS.count; i++) {
                subRoutines.push({
                    id: `subroutine-${bossData.id}-${i}`,
                    angle: (Math.PI * 2 / BOSS_2_SUB_ROUTINE_STATS.count) * i,
                    position: { x: 0, y: 0 }, 
                    size: BOSS_2_SUB_ROUTINE_STATS.size,
                    health: BOSS_2_SUB_ROUTINE_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                    maxHealth: BOSS_2_SUB_ROUTINE_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                    color: GAME_COLORS.BOSS_2_SUB_ROUTINE,
                    statusEffects: [], 
                    lastShotTime: now + i * 500,
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.bossShieldNodes = subRoutines;
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);
    
    const spawnBoss3 = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 3) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const bossData = {
                id: `boss3-${now}`, bossType: 'arbiter', position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                size: BOSS_3_STATS.size, health: BOSS_3_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_3_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                color: GAME_COLORS.BOSS_3_CORE, phase: 1, statusEffects: [], vulnerableEndTime: 0,
                lastAttackTime: {}, hasStarted: false,
                phase3AuraRadius: BOSS_3_STATS.phase3AuraInitialRadius, lastPhase3AuraDamageTime: 0,
            };
            const sockets = [];
            const padding = 200;
            const positions = [
                { x: padding, y: padding }, { x: CANVAS_WIDTH - padding, y: padding },
                { x: padding, y: CANVAS_HEIGHT - padding }, { x: CANVAS_WIDTH - padding, y: CANVAS_HEIGHT - padding }
            ];
            for (let i = 0; i < RAM_SOCKET_STATS.count; i++) {
                sockets.push({
                    id: `ram-${bossData.id}-${i}`, position: positions[i],
                    isCorrupted: false, cleanseProgress: 0,
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.ramSockets = sockets;
            draft.bossShieldNodes = [];
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
            draft.bossAttacks = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);

    const spawnBoss4 = useGameEngineCallback((isNightmareMode) => {
        setGameState(draft => {
            if (draft.stage !== 4) return;
            const now = Date.now();
            const nightmareMultiplier = isNightmareMode ? 2 : 1;
            const bossData = {
                id: `boss4-${now}`, bossType: 'hivemind_nexus', position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                size: BOSS_4_STATS.size, health: BOSS_4_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_4_STATS.maxHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                color: GAME_COLORS.BOSS_4_CORE, phase: 1, statusEffects: [],
                lastAttackTime: {}, arenaShrinkAmount: 0,
            };
            const subRouters = [];
            const padding = 150;
            const positions = [ { x: padding, y: padding }, { x: CANVAS_WIDTH - padding, y: padding }, { x: padding, y: CANVAS_HEIGHT - padding }, { x: CANVAS_WIDTH - padding, y: CANVAS_HEIGHT - padding }];
            for (let i = 0; i < BOSS_4_STATS.subRouterCount; i++) {
                subRouters.push({
                    id: `subrouter-${bossData.id}-${i}`, position: positions[i],
                    size: 40, health: BOSS_4_STATS.subRouterHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier, maxHealth: BOSS_4_STATS.subRouterHealth * nightmareMultiplier * draft.gameModifiers.bossHealthMultiplier,
                    color: GAME_COLORS.BOSS_4_SUB_ROUTER, statusEffects: []
                });
            }
            const playerProjectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
            draft.boss = bossData;
            draft.bossShieldNodes = subRouters;
            draft.enemies =[];
            draft.projectiles = playerProjectiles;
            draft.expOrbs = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
            draft.bossAttacks = [];
        });
        onBossFightStartCallback();
    }, [onBossFightStartCallback, setGameState]);

    const startNextStage = useAppCallback((stageNumber) => {
        setGameState(draft => {
            let healthBonus = 0;
            if (stageNumber === 2) healthBonus = 50;
            if (stageNumber === 3) healthBonus = 100;
            if (stageNumber === 4) healthBonus = 150;

            draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + healthBonus);
            draft.stage = stageNumber;
            draft.enemies = [];
            draft.projectiles = [];
            draft.particles = [];
            draft.healthPickups = [];
            draft.corruptedZones = [];
            draft.acidPuddles = [];
            draft.interactables = [];
            draft.alliedMinions = [];
            draft.boss = null;
            draft.bossShieldNodes = [];
            draft.isBossEventTriggered = false;
            draft.nextEnemySpawnTime = Date.now() + ENEMY_SPAWN_INITIAL_DELAY;
        });
    }, [setGameState]);

    const _applyStatusEffectToEntity = useGameEngineCallback((entity, effect, now) => {
        if (!entity.statusEffects) entity.statusEffects = [];
        const existingEffectIndex = entity.statusEffects.findIndex(ef => ef.type === effect.type && ef.sourceId === effect.sourceId);
        const newEffectEntry = { ...effect, startTime: now };

        if (existingEffectIndex !== -1) { 
            const existing = entity.statusEffects[existingEffectIndex];
            existing.startTime = newEffectEntry.startTime;
            existing.duration = newEffectEntry.duration; 
            if (newEffectEntry.magnitude) { 
                    existing.magnitude = effect.type === StatusEffectType.VULNERABILITY ? Math.max(existing.magnitude || 1, newEffectEntry.magnitude) : newEffectEntry.magnitude;
            }
        } else {
            entity.statusEffects.push(newEffectEntry);
        }
    },[]);
    
    const handleGameOverWithStats = useAppCallback(() => {
        sessionStatsRef.current.timeSurvived = gameState.gameTime;
        sessionStatsRef.current.levelReached = gameState.level;
        sessionStatsRef.current.score = gameState.score;
        sessionStatsRef.current.reachedInfiniteMode = gameState.isInfiniteMode;
        sessionStatsRef.current.evolvedWeaponIds = new Set(gameState.player.weapons.filter(w => w.isEvolved).map(w => w.evolutionId));
        onGameOverCallback(sessionStatsRef.current);
    }, [gameState.gameTime, gameState.level, gameState.score, gameState.isInfiniteMode, gameState.player.weapons, onGameOverCallback]);

    const gameTick = useAppCallback((deltaTime) => {

            try {
                setGameState(draft => {

                    if (draft.isPaused || !isGameActive) {
                        return; // Se estiver pausado, simplesmente n√£o fazemos nada e sa√≠mos.
                    }
                    const now = Date.now();
                    const { gameModifiers } = draft;
                    
                    const gameTimeSeconds = Math.floor(draft.gameTime);
                    const shouldTriggerDataVault = 
                        (gameTimeSeconds === DATA_VAULT_TRIGGER_TIME) ||
                        (gameTimeSeconds === DATA_VAULT_2_TRIGGER_TIME) ||
                        (gameTimeSeconds === DATA_VAULT_3_TRIGGER_TIME);

                    if (!draft.eventActive && !draft.boss && shouldTriggerDataVault) {
                        draft.eventActive = 'DATA_VAULT';
                        const killRequirementMultiplier = 
                            gameTimeSeconds === DATA_VAULT_2_TRIGGER_TIME ? 1.5 :
                            gameTimeSeconds === DATA_VAULT_3_TRIGGER_TIME ? 2.0 : 1.0;
                        
                        draft.eventKillCounter = Math.floor(DATA_VAULT_KILL_REQUIREMENT * killRequirementMultiplier);
                        draft.eventKillsSoFar = 0;
                        draft.dataVault = { position: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 } };
                        SoundManager.play('eventStart');
                    }

                    const bossShouldTrigger = 
                        (draft.stage === 1 && draft.gameTime >= (BOSS_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode) ||
                        (draft.stage === 2 && draft.gameTime >= (BOSS_2_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode) ||
                        (draft.stage === 3 && draft.gameTime >= (BOSS_3_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode) ||
                        (draft.stage === 4 && draft.gameTime >= (BOSS_4_TRIGGER_TIME + gameModifiers.bossTimerModifier) && !draft.isInfiniteMode);

                    if (bossShouldTrigger && !draft.isBossEventTriggered) {
                        draft.isBossEventTriggered = true;
                        draft.isPaused = true; 
                        draft.enemies = [];
                        draft.projectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id);
                        draft.expOrbs = []; draft.healthPickups = []; draft.particles = []; draft.corruptedZones = []; draft.acidPuddles = []; draft.interactables = []; draft.alliedMinions = []; draft.unstableSectors = [];
                        onBossWarningStartCallback(draft.stage); 
                        SoundManager.play('bossWarning');
                        return; 
                    }

                    const isBossFightActive = draft.boss !== null;
                    if(isBossFightActive && sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] === undefined){
                        sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] = 0;
                    }
                    const shouldSpawnNormalEnemies = !isBossFightActive;

                    let playerSpeedMultiplier = 1;
                    let playerCooldownMultiplier = 1;
                    let playerDamageMultiplier = 1;
                    let playerDamageReductionMultiplier = 1;
                    let tempRegenPerSecond = 0;
                    
                    if (draft.player.hasInfiniteFury) {
                        playerDamageMultiplier *= (1 + (draft.player.furyStacks || 0) * 0.01);
                        playerCooldownMultiplier *= (1 - (draft.player.furyStacks || 0) * 0.01);
                    }

                    draft.player.temporaryBuffs = draft.player.temporaryBuffs.filter(buff => {
                        if (now >= buff.endTime) return false;
                        switch(buff.type) {
                            case TemporaryBuffType.MOVE_SPEED: playerSpeedMultiplier *= buff.magnitude; break;
                            case TemporaryBuffType.ATTACK_SPEED: playerCooldownMultiplier *= buff.magnitude; break;
                            case TemporaryBuffType.DAMAGE_AMP: playerDamageMultiplier *= buff.magnitude; break;
                            case TemporaryBuffType.REGEN: tempRegenPerSecond += buff.magnitude; break;
                            case TemporaryBuffType.DAMAGE_REDUCTION: playerDamageReductionMultiplier *= buff.magnitude; break;
                        }
                        return true;
                    });
                    const finalPlayerDamageReduction = 1 - ((1 - (draft.player.damageReduction || 0)) * playerDamageReductionMultiplier);

                    const libraryPlayerIsOn = draft.interactables.find(i => i.type === InteractableType.CORRUPTED_LIBRARY && calculateDistance(draft.player.position, i.position) < i.radius);
                    if (libraryPlayerIsOn) {
                        playerCooldownMultiplier *= INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].DEBUFF_MAGNITUDE;
                    }
                    
                    draft.bossAttacks.forEach(attack => {
                        if(attack.type === BossAttackType.STATIC_ZONE && calculateDistance(draft.player.position, attack.position) < BOSS_3_STATS.staticZoneRadius) {
                            playerSpeedMultiplier *= 0.4;
                        }
                    });

                    draft.particles.forEach(p => {
                        if (p.type === 'slow_puddle' && calculateDistance(p.position, draft.player.position) < p.radius) {
                            playerSpeedMultiplier *= 0.5;
                        }
                    });
                    
                    const currentDashCooldown = DASH_STATS.COOLDOWN * (draft.player.dashCooldownModifier || 1.0);
                    if (draft.keys[' '] && !draft.player.isDashing && now > draft.player.dashCooldownUntil) {
                        draft.player.isDashing = true;
                        draft.player.dashEndTime = now + (DASH_STATS.DURATION * (draft.player.dashDurationModifier || 1.0));
                        draft.player.dashCooldownUntil = now + currentDashCooldown;
                        const moveDir = normalizeVector({ x: (draft.keys.d ? 1:0) - (draft.keys.a ? 1:0), y: (draft.keys.s ? 1:0) - (draft.keys.w ? 1:0) });
                        if(moveDir.x === 0 && moveDir.y === 0) {
                            draft.player.dashDirection = { ...draft.player.lastMoveDirection };
                        } else {
                            draft.player.dashDirection = moveDir;
                        }
                        sessionStatsRef.current.dashUsedInSession = true;
                        sessionStatsRef.current.totalDashes++;
                        SoundManager.play('playerDash');
                    }
                    
                    if (draft.player.isDashing) {
                        if (now > draft.player.dashEndTime) {
                            draft.player.isDashing = false;
                        } else {
                            draft.particles.push({ id: `p-dash-${now}-${Math.random()}`, position: { ...draft.player.position }, velocity: { x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*10 }, size: Math.random()*3+2, color: draft.player.color, life: 20 });
                        }
                    }
                    
                    const playerMoved = (draft.keys.w || draft.keys.a || draft.keys.s || draft.keys.d);
                    if(playerMoved) {
                        sessionStatsRef.current.lastMoveTime = now;
                        sessionStatsRef.current.timeWithoutMoving = 0;
                    } else {
                        sessionStatsRef.current.timeWithoutMoving = now - sessionStatsRef.current.lastMoveTime;
                    }

                    if (draft.player.isDashing) {
                        const dashSpeed = draft.player.speed * DASH_STATS.SPEED_MULTIPLIER * playerSpeedMultiplier;
                        draft.player.position.x += draft.player.dashDirection.x * dashSpeed * deltaTime;
                        draft.player.position.y += draft.player.dashDirection.y * dashSpeed * deltaTime;
                    } else if (playerMoved) {
                        let dx = 0, dy = 0;
                        if (draft.keys.w) dy -= 1; if (draft.keys.s) dy += 1;
                        if (draft.keys.a) dx -= 1; if (draft.keys.d) dx += 1;
                        const norm = normalizeVector({ x: dx, y: dy });
                        draft.player.lastMoveDirection = { ...norm };
                        draft.player.position.x += norm.x * draft.player.speed * playerSpeedMultiplier * deltaTime;
                        draft.player.position.y += norm.y * draft.player.speed * playerSpeedMultiplier * deltaTime;
                    }
                    draft.player.position.x = Math.max(draft.player.size / 2, Math.min(CANVAS_WIDTH - draft.player.size / 2, draft.player.position.x));
                    draft.player.position.y = Math.max(draft.player.size / 2, Math.min(CANVAS_HEIGHT - draft.player.size / 2, draft.player.position.y));
                    
                    if (draft.player.classId === 'class_technomancer') {
                        draft.alliedMinions.forEach((minion, index) => {
                            minion.angle = minion.angle || 0;
                            
                            let currentTarget = [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].find(e => e.id === minion.targetId && e.health > 0);
                            if (!currentTarget) {
                                let closestEnemy = null, minDistance = Infinity;
                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                    if (target.health > 0) {
                                        const dist = calculateDistance(minion.position, target.position);
                                        if (dist < minDistance) { minDistance = dist; closestEnemy = target; }
                                    }
                                });
                                if (closestEnemy) minion.targetId = closestEnemy.id;
                                currentTarget = closestEnemy;
                            }
                            if (currentTarget) {
                                const dir = normalizeVector({ x: currentTarget.position.x - minion.position.x, y: currentTarget.position.y - minion.position.y });
                                minion.position.x += dir.x * minion.speed * deltaTime;
                                minion.position.y += dir.y * minion.speed * deltaTime;
                                minion.angle = Math.atan2(dir.y, dir.x);
                            }
                        });
                    }

                    const permanentRegen = draft.player.regenAmount || 0;
                    if ((permanentRegen > 0 || tempRegenPerSecond > 0) && now - (draft.player.lastRegenTime || 0) > 1000) { 
                        let totalRegen = tempRegenPerSecond + permanentRegen;
                        draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + totalRegen);
                        draft.player.lastRegenTime = now;
                    }

                    if (draft.player.overdriveActive && now > draft.player.overdriveEndTime) { draft.player.overdriveActive = false; draft.player.overdriveDamageBonusFactor = 1; }
                    const overdriveLevel = ownedUpgradesRef.current.get('player_overdrive') || 0;
                    if (overdriveLevel > 0 && !draft.player.overdriveActive && now > draft.player.overdriveCooldownUntil && (draft.player.health / draft.player.maxHealth) < 0.25) { draft.player.overdriveActive = true; draft.player.overdriveEndTime = now + 5000; draft.player.overdriveCooldownUntil = now + 5000 + 30000; draft.player.overdriveDamageBonusFactor = 1 + (0.15 + overdriveLevel * 0.05); }

                    if (shouldSpawnNormalEnemies && now > draft.nextEnemySpawnTime) {
                        const spawnPos = getEnemySpawnPosition();
                        const timeForDifficulty = draft.isInfiniteMode ? draft.gameTime - BOSS_4_TRIGGER_TIME : (draft.stage === 2 ? draft.gameTime - BOSS_TRIGGER_TIME : (draft.stage === 3 ? draft.gameTime - BOSS_2_TRIGGER_TIME : (draft.stage === 4 ? draft.gameTime - BOSS_3_TRIGGER_TIME : draft.gameTime)));
                        let difficultyMultiplier = 1 + Math.floor(timeForDifficulty / 60) * 0.15;
                        let healthMultiplier = 1 + Math.floor(timeForDifficulty / 45) * 0.20;
                        let damageMultiplier = 1 + Math.floor(timeForDifficulty / 60) * 0.15;

                        if (draft.isNightmareMode) {
                            healthMultiplier *= 2;
                            damageMultiplier *= 1.25;
                        }

                        let enemyConfig;
                        if (draft.stage === 1) {
                            const eligibleTypes = [EnemyType.DEFAULT, EnemyType.MEMORY_LEAK, EnemyType.SPYWARE, EnemyType.TROJAN_HORSE, EnemyType.ROOTKIT, EnemyType.DDOS_BOT]
                                .filter(type => draft.gameTime > (ENEMY_SPAWN_TIMES[type] || -1));
                            if(eligibleTypes.length === 0) eligibleTypes.push(EnemyType.DEFAULT);
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch (selectedType) {
                                case EnemyType.MEMORY_LEAK: enemyConfig = ENEMY_MEMORY_LEAK_STATS; break;
                                case EnemyType.SPYWARE: enemyConfig = ENEMY_SPYWARE_STATS; break;
                                case EnemyType.TROJAN_HORSE: enemyConfig = ENEMY_TROJAN_HORSE_STATS; break;
                                case EnemyType.ROOTKIT: enemyConfig = ENEMY_ROOTKIT_STATS; break;
                                case EnemyType.DDOS_BOT: enemyConfig = ENEMY_DDOS_BOT_STATS; break;
                                default: enemyConfig = ENEMY_DEFAULT_STATS;
                            }
                        } else if (draft.stage === 2) {
                            const eligibleTypes = [EnemyType.PROCESSO_CORROMPIDO, EnemyType.PONTEIRO_NULO, EnemyType.SEGMENTO_FALHA, EnemyType.PROCESSO_ZUMBI];
                            const timeInStage2 = draft.gameTime - BOSS_TRIGGER_TIME;
                            if (timeInStage2 < 90) eligibleTypes.splice(3, 1);
                            if (timeInStage2 < 60) eligibleTypes.splice(2, 1);
                            if (timeInStage2 < 30) eligibleTypes.splice(1, 1);
                            
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch (selectedType) {
                                case EnemyType.PONTEIRO_NULO: enemyConfig = ENEMY_PONTEIRO_NULO_STATS; break;
                                case EnemyType.SEGMENTO_FALHA: enemyConfig = ENEMY_SEGMENTO_FALHA_STATS; break;
                                case EnemyType.PROCESSO_ZUMBI: enemyConfig = ENEMY_PROCESSO_ZUMBI_STATS; break;
                                default: enemyConfig = ENEMY_PROCESSO_CORROMPIDO_STATS;
                            }
                        } else if (draft.stage === 3) { 
                            const eligibleTypes = [EnemyType.NANITE, EnemyType.HEATSINK, EnemyType.IO_CONTROLLER, EnemyType.VOLATILE_PROCESS];
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch(selectedType) {
                                case EnemyType.HEATSINK: enemyConfig = ENEMY_HEATSINK_STATS; break;
                                case EnemyType.IO_CONTROLLER: enemyConfig = ENEMY_IO_CONTROLLER_STATS; break;
                                case EnemyType.VOLATILE_PROCESS: enemyConfig = ENEMY_VOLATILE_PROCESS_STATS; break;
                                default: enemyConfig = ENEMY_NANITE_STATS;
                            }
                        } else if (draft.stage === 4) {
                            const eligibleTypes = [EnemyType.RECURSIVE_PROCESS, EnemyType.ROGUE_FIREWALL, EnemyType.LATENCY_SPIKE, EnemyType.PROTOCOL_ANOMALY];
                            const selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
                            switch(selectedType) {
                                case EnemyType.ROGUE_FIREWALL: enemyConfig = ENEMY_ROGUE_FIREWALL_STATS; break;
                                case EnemyType.LATENCY_SPIKE: enemyConfig = ENEMY_LATENCY_SPIKE_STATS; break;
                                case EnemyType.PROTOCOL_ANOMALY: enemyConfig = ENEMY_PROTOCOL_ANOMALY_STATS; break;
                                default: enemyConfig = ENEMY_RECURSIVE_PROCESS_STATS;
                            }
                        }

                        const createEnemyObject = (config, specificSpawnPos) => {
                            const enemy = {
                                id: `enemy-${now}-${Math.random().toString(36).substr(2, 5)}`,
                                type: config.type, position: specificSpawnPos || spawnPos, size: config.size,
                                baseSpeed: config.baseSpeed, speed: config.baseSpeed * difficultyMultiplier * gameModifiers.enemySpeedMultiplier,
                                color: config.color,
                                health: config.health * healthMultiplier * gameModifiers.enemyHealthMultiplier, maxHealth: config.health * healthMultiplier * gameModifiers.enemyHealthMultiplier,
                                damage: config.damage * damageMultiplier * gameModifiers.enemyDamageMultiplier,
                                expValue: Math.floor(config.expValue * (1 + Math.floor(draft.gameTime / 45) * 0.115)), 
                                isVisible: true, dotEffects: [], statusEffects: [],
                                isConvertible: config.isConvertible,
                            };
                            if (config.type === EnemyType.MEMORY_LEAK) { enemy.trail = []; enemy.lastTrailDropTime = now; } 
                            else if (config.type === EnemyType.SPYWARE) { enemy.invisibilityToggleTime = now + config.visibilityDuration; enemy.isCurrentlyVisible = true; }
                            else if (config.type === EnemyType.PONTEIRO_NULO) { enemy.teleportCooldownUntil = now + 2000; enemy.isChargingTeleport = false; }
                            else if (config.type === EnemyType.SEGMENTO_FALHA) { enemy.isShielded = false; enemy.shieldCooldownUntil = now + 3000; }
                            else if (config.type === EnemyType.PROCESSO_ZUMBI) { enemy.hasRevived = false; }
                            else if (config.type === EnemyType.NANITE) { enemy.waveOffset = Math.random() * Math.PI * 2; }
                            else if (config.type === EnemyType.HEATSINK) { enemy.lastPulseTime = now; }
                            else if (config.type === EnemyType.IO_CONTROLLER) { enemy.lastShotTime = now; }
                            else if (config.type === EnemyType.VOLATILE_PROCESS) { enemy.fuseEndTime = now + config.fuseTime; }
                            else if (config.type === EnemyType.PROTOCOL_ANOMALY) { enemy.protocol = 'TCP'; enemy.lastProtocolSwitch = now; }
                            return enemy;
                        };
                        
                        const newlySpawnedEnemies = [];
                        if (enemyConfig.type === EnemyType.DDOS_BOT) {
                            for (let i = 0; i < ENEMY_DDOS_BOT_STATS.swarmCount; i++) {
                                newlySpawnedEnemies.push(createEnemyObject(enemyConfig, getEnemySpawnPosition()));
                            }
                        } else {
                            newlySpawnedEnemies.push(createEnemyObject(enemyConfig, spawnPos));
                        }

                        newlySpawnedEnemies.forEach(enemy => {
                            if (gameModifiers.eliteChance > 0 && Math.random() < gameModifiers.eliteChance && !enemy.isElite) {
                                enemy.isElite = true;
                                enemy.health *= 2;
                                enemy.maxHealth *= 2;
                                enemy.damage *= 1.5;
                                enemy.size *= 1.2;
                                enemy.color = '#FFD700';
                                enemy.expValue = Math.floor(enemy.expValue * 1.5);
                            }
                        });
                        
                        draft.enemies.push(...newlySpawnedEnemies);
                        
                        let spawnDelay = Math.max(ENEMY_SPAWN_MIN_INTERVAL, ENEMY_SPAWN_INITIAL_DELAY - draft.gameTime * ENEMY_SPAWN_INTERVAL_DECREMENT_FACTOR);
                        if (draft.isNightmareMode) {
                            spawnDelay *= 0.75; 
                        }

                        if (draft.stage === 2 && !draft.isInfiniteMode && (draft.gameTime - BOSS_TRIGGER_TIME < 60)) {
                            spawnDelay *= 2; 
                        }

                        if (draft.stage === 3 && !draft.isInfiniteMode && (draft.gameTime - BOSS_2_TRIGGER_TIME < 70)) {
                            spawnDelay *= 2.5;
                        }
                        if (draft.stage === 4 && !draft.isInfiniteMode && (draft.gameTime - BOSS_3_TRIGGER_TIME < 80)) {
                            spawnDelay *= 3;
                        }

                        draft.nextEnemySpawnTime = now + spawnDelay;
                    }
                    
                    if (now > draft.nextInteractableSpawnTime && !isBossFightActive) {
                        const type = Math.random() < 0.6 ? InteractableType.DATA_CACHE : InteractableType.CORRUPTED_LIBRARY;
                        const pos = getRandomCanvasPosition(100);
                        let newInteractable;

                        if (type === InteractableType.DATA_CACHE) {
                            const stats = INTERACTABLE_STATS[InteractableType.DATA_CACHE];
                            const buffTemplate = stats.BUFFS[Math.floor(Math.random() * stats.BUFFS.length)];
                            newInteractable = {
                                id: `interact-${now}`, type: InteractableType.DATA_CACHE, position: pos, size: stats.SIZE,
                                creationTime: now, duration: stats.DURATION, buff: { ...buffTemplate }
                            };
                        } else {
                            const stats = INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY];
                            newInteractable = {
                                id: `interact-${now}`, type: InteractableType.CORRUPTED_LIBRARY, position: pos, radius: stats.RADIUS,
                                creationTime: now, duration: stats.DURATION, cleanseProgress: 0, wasInsideLastFrame: false,
                            };
                        }
                        draft.interactables.push(newInteractable);
                        draft.nextInteractableSpawnTime = now + INTERACTABLE_STATS.SPAWN_INTERVAL_MIN + Math.random() * (INTERACTABLE_STATS.SPAWN_INTERVAL_MAX - INTERACTABLE_STATS.SPAWN_INTERVAL_MIN);
                    }

                     if (draft.stage === 3 && !isBossFightActive && now > draft.nextUnstableSectorTime) {
                        draft.unstableSectors = [];
                        const count = 15 + Math.floor(Math.random() * 6);
                        for (let i = 0; i < count; i++) {
                            draft.unstableSectors.push({
                                x: Math.floor(Math.random() * (CANVAS_WIDTH / 40)) * 40,
                                y: Math.floor(Math.random() * (CANVAS_HEIGHT / 40)) * 40,
                                endTime: now + 5000
                            });
                        }
                        draft.nextUnstableSectorTime = now + 8000;
                    }
                    draft.unstableSectors = draft.unstableSectors.filter(s => now < s.endTime);


                    const interactablesToRemove = new Set();
                    draft.interactables.forEach(i => {
                        if (now > i.creationTime + i.duration) { interactablesToRemove.add(i.id); return; }
                        if (i.type === InteractableType.DATA_CACHE) {
                            const interactionRadiusSq = (draft.player.size / 2 + i.size / 2) ** 2;
                            if (calculateDistanceSq(draft.player.position, i.position) < interactionRadiusSq) {
                                const newBuff = { ...i.buff, endTime: now + i.buff.duration, id: `buff-${now}` };
                                draft.player.temporaryBuffs.push(newBuff); interactablesToRemove.add(i.id); SoundManager.play('pickupBuff');
                                sessionStatsRef.current.dataCachesCollectedInSession++;
                            }
                        } else if (i.type === InteractableType.CORRUPTED_LIBRARY) {
                            const isInside = calculateDistanceSq(draft.player.position, i.position) < i.radius * i.radius;
                            if (isInside) {
                                if (!i.wasInsideLastFrame) SoundManager.play('enterDebuffZone');
                                i.cleanseProgress += (1 / INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].CLEANSE_TIME) * (deltaTime * 1000);
                                if (i.cleanseProgress >= 1) {
                                    SoundManager.play('cleanseComplete');
                                    sessionStatsRef.current.corruptedLibrariesCleansed++;
                                    const rewardType = Math.random() < 0.4 ? 'HEALTH' : 'XP';
                                    if (rewardType === 'HEALTH') {
                                        draft.healthPickups.push({ id: `hp-lib-${now}`, position: i.position, size: HEALTH_PICKUP_STATS.size, healAmount: HEALTH_PICKUP_STATS.healAmount, color: GAME_COLORS.HEALTH_PICKUP, });
                                    } else {
                                        const { REWARD_XP_COUNT, REWARD_XP_VALUE } = INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY];
                                        for(let j=0; j < REWARD_XP_COUNT; j++) {
                                                draft.expOrbs.push({ id: `xp-lib-${now}-${j}`, position: {x: i.position.x + (Math.random()-0.5)*20, y: i.position.y + (Math.random()-0.5)*20}, size: 10, value: REWARD_XP_VALUE, color: GAME_COLORS.XP_ORB });
                                        }
                                    }
                                    interactablesToRemove.add(i.id);
                                }
                            } else {
                                i.cleanseProgress = Math.max(0, i.cleanseProgress - (INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].DECAY_RATE / INTERACTABLE_STATS[InteractableType.CORRUPTED_LIBRARY].CLEANSE_TIME) * (deltaTime * 1000));
                            }
                            i.wasInsideLastFrame = isInside;
                        }
                    });
                    if (interactablesToRemove.size > 0) {
                        draft.interactables = draft.interactables.filter(i => !interactablesToRemove.has(i.id));
                    }

                    if (draft.revivingProcesses.length > 0) {
                        const newlyRevived = [];
                        draft.revivingProcesses = draft.revivingProcesses.filter(proc => {
                            if (now >= proc.reviveAt) {
                                SoundManager.play('zombieRevive');
                                const nightmareDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                const enemy = {
                                    id: `enemy-revived-${now}-${Math.random().toString(36).substr(2, 5)}`, type: ENEMY_PROCESSO_ZUMBI_STATS.type, position: proc.position, size: ENEMY_PROCESSO_ZUMBI_STATS.size,
                                    baseSpeed: ENEMY_PROCESSO_ZUMBI_STATS.baseSpeed, speed: ENEMY_PROCESSO_ZUMBI_STATS.baseSpeed, color: ENEMY_PROCESSO_ZUMBI_STATS.color, health: proc.maxHealth * ENEMY_PROCESSO_ZUMBI_STATS.reviveHealthFactor, maxHealth: proc.maxHealth,
                                    damage: ENEMY_PROCESSO_ZUMBI_STATS.damage * nightmareDamageMultiplier, expValue: 0, isVisible: true, dotEffects: [], statusEffects: [], hasRevived: true,
                                };
                                newlyRevived.push(enemy); for(let k=0; k<15; ++k) draft.particles.push({ id: `p-revive-${enemy.id}-${k}`, position: { ...enemy.position }, velocity: { x: (Math.random()-0.5)*70, y: (Math.random()-0.5)*70 }, size: Math.random()*2+2, color: GAME_COLORS.ENEMY_PROCESSO_ZUMBI, life: 80 });
                                return false;
                            }
                            return true;
                        });
                        if (newlyRevived.length > 0) { draft.enemies.push(...newlyRevived); }
                    }

                    if (now > draft.nextHealthPickupSpawnTime && !isBossFightActive) { 
                        draft.healthPickups.push({ id: `hp-${now}`, position: getRandomCanvasPosition(), size: HEALTH_PICKUP_STATS.size, healAmount: HEALTH_PICKUP_STATS.healAmount, color: GAME_COLORS.HEALTH_PICKUP, });
                        const intervalMin = HEALTH_PICKUP_STATS.spawnIntervalMin / gameModifiers.healthPickupSpawnRateMultiplier;
                        const intervalMax = HEALTH_PICKUP_STATS.spawnIntervalMax / gameModifiers.healthPickupSpawnRateMultiplier;
                        draft.nextHealthPickupSpawnTime = now + intervalMin + Math.random() * (intervalMax - intervalMin);
                    }
                    
                    draft.enemies.forEach(e => {
                        let currentSpeedMultiplier = 1; let isFrozen = false; let isFeared = false; e.vulnerabilityFactor = 1; 
                        const statusEffectDuration = (draft.player.statusEffectDuration || 1.0);
                        e.statusEffects = e.statusEffects.filter(effect => { if (now > effect.startTime + (effect.duration * statusEffectDuration)) return false; switch (effect.type) { case StatusEffectType.SLOW: currentSpeedMultiplier = Math.min(currentSpeedMultiplier, effect.magnitude || 0.5); break; case StatusEffectType.FREEZE: isFrozen = true; break; case StatusEffectType.VULNERABILITY: e.vulnerabilityFactor = Math.max(e.vulnerabilityFactor, effect.magnitude || 1.2); break; case StatusEffectType.FEAR: isFeared = true; break; } return true; });
                        if (e.dotEffects && e.dotEffects.length > 0) { e.dotEffects = e.dotEffects.filter(dot => { if (now - dot.lastTickTime >= dot.tickInterval) { e.health -= dot.damagePerTick * e.vulnerabilityFactor; dot.ticksRemaining--; dot.lastTickTime = now; draft.particles.push({ id: `p-dot-${e.id}-${now}-${Math.random()}`, position: {x: e.position.x + (Math.random()-0.5)*e.size, y: e.position.y + (Math.random()-0.5)*e.size}, size: 2, color: GAME_COLORS.ENEMY_DOT_EFFECT, life: 20 }); } return dot.ticksRemaining > 0; }); }
                        if (e.type === EnemyType.MEMORY_LEAK && e.trail && now - (e.lastTrailDropTime || 0) > ENEMY_MEMORY_LEAK_STATS.trailDropInterval) { e.trail.push({ x: e.position.x, y: e.position.y, createdAt: now, id: `trail-${e.id}-${now}` }); e.lastTrailDropTime = now; if (e.trail.length > 20) e.trail.shift(); }
                        if (e.type === EnemyType.SPYWARE && now > (e.invisibilityToggleTime || 0)) { e.isCurrentlyVisible = !e.isCurrentlyVisible; e.invisibilityToggleTime = now + (e.isCurrentlyVisible ? ENEMY_SPYWARE_STATS.visibilityDuration : ENEMY_SPYWARE_STATS.invisibilityDuration); }
                        if (e.type === EnemyType.HEATSINK && now > (e.lastPulseTime || 0) + ENEMY_HEATSINK_STATS.pulseInterval) { draft.particles.push({ id: `hs-pulse-${e.id}`, type: 'heatsink_pulse', position: { ...e.position }, radius: 0, targetRadius: 80, life: 500, initialLife: 500, destroysProjectiles: true }); e.lastPulseTime = now; }
                        if (e.type === EnemyType.IO_CONTROLLER && now > (e.lastShotTime || 0) + ENEMY_IO_CONTROLLER_STATS.fireRate) { const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); const baseAngle = Math.atan2(dirToPlayer.y, dirToPlayer.x); const totalSpread = ENEMY_IO_CONTROLLER_STATS.spread * (Math.PI / 180); for(let i=-1; i<=1; i++) { const angle = baseAngle + i * (totalSpread / 2); const velocity = { x: Math.cos(angle) * ENEMY_IO_CONTROLLER_STATS.projectileSpeed, y: Math.sin(angle) * ENEMY_IO_CONTROLLER_STATS.projectileSpeed }; draft.projectiles.push({ id: `io-proj-${e.id}-${i}`, position: {...e.position}, velocity, size: ENEMY_IO_CONTROLLER_STATS.projectileSize, color: e.color, damage: e.damage, ownerId: e.id, lifetime: 4000 }); } e.lastShotTime = now; }
                        if (e.type === EnemyType.VOLATILE_PROCESS && now >= e.fuseEndTime) { draft.particles.push({ id: `vol-exp-${e.id}`, type: 'volatile_explosion', position: {...e.position}, radius: 0, targetRadius: ENEMY_VOLATILE_PROCESS_STATS.explosionRadius, color: e.color, life: 300, initialLife: 300, damage: ENEMY_VOLATILE_PROCESS_STATS.explosionDamage, ownerId: e.id }); e.health = 0; }
                        if (e.type === EnemyType.LATENCY_SPIKE) {
                            if (calculateDistanceSq(e.position, draft.player.position) < e.slowAuraRadius * e.slowAuraRadius) {
                                playerSpeedMultiplier *= e.slowMagnitude;
                            }
                            if (now > (e.lastShotTime || 0) + 4000) {
                                const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y });
                                draft.projectiles.push({ id: `latency-proj-${e.id}-${now}`, position: { ...e.position }, velocity: { x: dirToPlayer.x * 200, y: dirToPlayer.y * 200 }, size: 15, color: GAME_COLORS.ENEMY_LATENCY_SPIKE, damage: 0, ownerId: e.id, lifetime: 4000, type: 'latency_spike_shot' });
                                e.lastShotTime = now;
                            }
                        }
                        if (e.type === EnemyType.PROTOCOL_ANOMALY) {
                            if (now > (e.lastProtocolSwitch || 0) + ENEMY_PROTOCOL_ANOMALY_STATS.protocolSwitchInterval) {
                                e.protocol = e.protocol === 'TCP' ? 'UDP' : 'TCP';
                                e.lastProtocolSwitch = now;
                                const healthPercent = e.health / e.maxHealth;
                                if (e.protocol === 'UDP') {
                                    e.speed = e.baseSpeed * 2.5;
                                    e.maxHealth = ENEMY_PROTOCOL_ANOMALY_STATS.health * 0.6;
                                } else {
                                    e.speed = e.baseSpeed;
                                    e.maxHealth = ENEMY_PROTOCOL_ANOMALY_STATS.health;
                                }
                                e.health = e.maxHealth * healthPercent;
                            }
                            if (e.protocol === 'UDP' && now > (e.lastShotTime || 0) + 1500) {
                                const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y });
                                draft.projectiles.push({ id: `anomaly-proj-${e.id}-${now}`, position: { ...e.position }, velocity: { x: dirToPlayer.x * 300, y: dirToPlayer.y * 300 }, size: 10, color: '#ff4757', damage: e.damage, ownerId: e.id, lifetime: 3000, });
                                e.lastShotTime = now;
                            }
                        }
                        
                        let canEnemyMove = true;
                        if (e.type === EnemyType.PONTEIRO_NULO) {
                            if (e.isChargingTeleport) { canEnemyMove = false;
                                if (now > e.teleportChargeStartTime + ENEMY_PONTEIRO_NULO_STATS.teleportChargeTime) { SoundManager.play('teleportExecute'); const dist = calculateDistance(e.position, draft.player.position); const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); e.position.x += dirToPlayer.x * Math.min(dist - e.size, 200); e.position.y += dirToPlayer.y * Math.min(dist - e.size, 200); e.isChargingTeleport = false; e.teleportCooldownUntil = now + ENEMY_PONTEIRO_NULO_STATS.teleportCooldown; }
                            } else if (now > e.teleportCooldownUntil) { SoundManager.play('teleportCharge'); e.isChargingTeleport = true; e.teleportChargeStartTime = now; }
                        }
                        if (e.type === EnemyType.SEGMENTO_FALHA) { if (e.isShielded && now > e.shieldActivateTime + ENEMY_SEGMENTO_FALHA_STATS.shieldDuration) { SoundManager.play('shieldBreak'); e.isShielded = false; e.shieldCooldownUntil = now + ENEMY_SEGMENTO_FALHA_STATS.shieldCooldown; } else if (!e.isShielded && now > e.shieldCooldownUntil) { SoundManager.play('shieldActivate'); e.isShielded = true; e.shieldActivateTime = now; } }
                        if (e.type === EnemyType.SPYWARE && !e.isCurrentlyVisible) canEnemyMove = false;
                        if (isFrozen) canEnemyMove = false;

                        if (canEnemyMove) { 
                            const actualSpeed = e.speed * currentSpeedMultiplier; 
                            if (isFeared) { 
                                const dirAwayFromPlayer = normalizeVector({ x: e.position.x - draft.player.position.x, y: e.position.y - draft.player.position.y }); 
                                e.position.x += dirAwayFromPlayer.x * actualSpeed * deltaTime; 
                                e.position.y += dirAwayFromPlayer.y * actualSpeed * deltaTime; 
                            } else {
                                if (e.type === EnemyType.NANITE) { 
                                    const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); 
                                    const perpendicular = { x: -dirToPlayer.y, y: dirToPlayer.x }; 
                                    const waveFactor = Math.sin(now / 350 + e.waveOffset) * 80; 
                                    e.position.x += (dirToPlayer.x * actualSpeed * deltaTime) + (perpendicular.x * waveFactor * deltaTime); 
                                    e.position.y += (dirToPlayer.y * actualSpeed * deltaTime) + (perpendicular.y * waveFactor * deltaTime); 
                                } else { 
                                    const dirToPlayer = normalizeVector({ x: draft.player.position.x - e.position.x, y: draft.player.position.y - e.position.y }); 
                                    e.position.x += dirToPlayer.x * actualSpeed * deltaTime; 
                                    e.position.y += dirToPlayer.y * actualSpeed * deltaTime; 
                                }
                            } 
                        }
                    });
                    draft.enemies.forEach(e => { if (e.type === EnemyType.MEMORY_LEAK && e.trail) { e.trail = e.trail.filter(segment => now - segment.createdAt < ENEMY_MEMORY_LEAK_STATS.trailLifetime); } });

                    if (draft.boss) {
                        const boss = draft.boss;

                        let activeShieldNodesCount = (draft.bossShieldNodes || []).filter(node => node.health > 0).length;
                         
                         let isInvulnerableThisTick = false;
                         if (boss.bossType === 'guardian' || boss.bossType === 'sincronizador' || boss.bossType === 'hivemind_nexus') {
                             isInvulnerableThisTick = boss.phase === 1 && activeShieldNodesCount > 0;
                         } else if (boss.bossType === 'arbiter') {
                             isInvulnerableThisTick = boss.phase < 3 && draft.ramSockets.some(s => s.isCorrupted);
                         }
                         boss.isInvulnerable = isInvulnerableThisTick;

                         let bossCurrentSpeedMultiplier = 1; let bossIsFrozen = false; boss.vulnerabilityFactor = 1;
                         boss.statusEffects = boss.statusEffects.filter(effect => { if (now > effect.startTime + effect.duration) return false; switch (effect.type) { case StatusEffectType.SLOW: bossCurrentSpeedMultiplier = Math.min(bossCurrentSpeedMultiplier, effect.magnitude || 0.5); break; case StatusEffectType.FREEZE: bossIsFrozen = true; break; case StatusEffectType.VULNERABILITY: boss.vulnerabilityFactor = Math.max(boss.vulnerabilityFactor, effect.magnitude || 1.2); break; } return true; });
                         if (!bossIsFrozen) {
                            if (boss.bossType === 'guardian') {
                                boss.position.x += boss.velocity.x * bossCurrentSpeedMultiplier * deltaTime;
                                boss.position.y += boss.velocity.y * bossCurrentSpeedMultiplier * deltaTime;

                                if ((boss.position.x - boss.size / 2 <= 0 && boss.velocity.x < 0) || (boss.position.x + boss.size / 2 >= CANVAS_WIDTH && boss.velocity.x > 0)) {
                                    boss.velocity.x *= -1;
                                }
                                if ((boss.position.y - boss.size / 2 <= 0 && boss.velocity.y < 0) || (boss.position.y + boss.size / 2 >= CANVAS_HEIGHT && boss.velocity.y > 0)) {
                                    boss.velocity.y *= -1;
                                }
                                
                                boss.position.x = Math.max(boss.size / 2, Math.min(CANVAS_WIDTH - boss.size / 2, boss.position.x));
                                boss.position.y = Math.max(boss.size / 2, Math.min(CANVAS_HEIGHT - boss.size / 2, boss.position.y));
                                
                                const projectileDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                const projectileDamage = BOSS_STATS.projectilePhase1Damage * projectileDamageMultiplier;
                                if (boss.phase === 1) { if (now - boss.lastPhase1AttackTime > BOSS_STATS.projectilePhase1FireRate) { const dirToPlayer = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y }); draft.projectiles.push({ id: `bproj1-${now}`, position: { ...boss.position }, velocity: { x: dirToPlayer.x * BOSS_STATS.projectilePhase1Speed, y: dirToPlayer.y * BOSS_STATS.projectilePhase1Speed }, size: BOSS_STATS.projectilePhase1Size, color: GAME_COLORS.BOSS_PROJECTILE_PHASE1, damage: projectileDamage, ownerId: boss.id, lifetime: 5000, type: 'boss_phase1', baseSpeed: BOSS_STATS.projectilePhase1Speed }); boss.lastPhase1AttackTime = now; } } 
                                else if (boss.phase === 2) {  if (now - boss.lastPhase2AttackTime > BOSS_STATS.projectilePhase2FireRate && boss.phase2BurstCounter === 0) { boss.phase2BurstCounter = BOSS_STATS.projectilePhase2BurstCount; boss.lastPhase2AttackTime = now - BOSS_STATS.projectilePhase2BurstInterval; } if (boss.phase2BurstCounter > 0 && now - boss.lastPhase2AttackTime > BOSS_STATS.projectilePhase2BurstInterval) { const dirToPlayer = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y }); const angleOffset = (Math.random() - 0.5) * 0.3;  const finalDirX = Math.cos(Math.atan2(dirToPlayer.y, dirToPlayer.x) + angleOffset); const finalDirY = Math.sin(Math.atan2(dirToPlayer.y, dirToPlayer.x) + angleOffset); draft.projectiles.push({ id: `bproj2-${now}-${boss.phase2BurstCounter}`, position: { ...boss.position }, velocity: { x: finalDirX * BOSS_STATS.projectilePhase2Speed, y: finalDirY * BOSS_STATS.projectilePhase2Speed }, size: BOSS_STATS.projectilePhase2Size, color: GAME_COLORS.BOSS_PROJECTILE_PHASE2, damage: BOSS_STATS.projectilePhase2Damage * projectileDamageMultiplier, ownerId: boss.id, lifetime: 4000, type: 'boss_phase2', baseSpeed: BOSS_STATS.projectilePhase2Speed }); boss.lastPhase2AttackTime = now; boss.phase2BurstCounter--; } if (now - boss.lastCorruptedZoneTime > BOSS_STATS.corruptedZoneInterval) { SoundManager.play('corruptedZoneAppear'); const zonePos = { x: Math.random() * (CANVAS_WIDTH - BOSS_STATS.corruptedZoneRadius*2) + BOSS_STATS.corruptedZoneRadius, y: Math.random() * (CANVAS_HEIGHT - BOSS_STATS.corruptedZoneRadius*2 - UI_BAR_HEIGHT) + BOSS_STATS.corruptedZoneRadius}; draft.corruptedZones.push({ id: `czone-${now}`, position: zonePos, radius: BOSS_STATS.corruptedZoneRadius, creationTime: now, duration: BOSS_STATS.corruptedZoneDuration, damage: BOSS_STATS.corruptedZoneDamage * projectileDamageMultiplier, damageInterval: BOSS_STATS.corruptedZoneDamageInterval, lastDamageTime: 0 }); boss.lastCorruptedZoneTime = now; } if (now - boss.lastGlitchMinionSpawnTime > BOSS_STATS.glitchMinionSpawnInterval) { SoundManager.play('minionSpawn'); for (let i = 0; i < BOSS_STATS.glitchMinionSpawnCount; i++) { const spawnOffsetAngle = Math.random() * Math.PI * 2; const spawnOffsetDist = boss.size * 0.75; draft.enemies.push({ id: `glitch-${now}-${i}`, type: EnemyType.GLITCH_MINION, position: { x: boss.position.x + Math.cos(spawnOffsetAngle) * spawnOffsetDist, y: boss.position.y + Math.sin(spawnOffsetAngle) * spawnOffsetDist }, size: GLITCH_MINION_STATS.size, baseSpeed: GLITCH_MINION_STATS.baseSpeed, speed: GLITCH_MINION_STATS.baseSpeed, health: GLITCH_MINION_STATS.health, damage: GLITCH_MINION_STATS.damage * projectileDamageMultiplier, expValue: GLITCH_MINION_STATS.expValue, color: GAME_COLORS.ENEMY_GLITCH_MINION, isVisible: true, dotEffects: [], statusEffects: [] }); } boss.lastGlitchMinionSpawnTime = now; } } 
                                else if (boss.phase === 3) { if (now - boss.lastCorruptedZoneTime > BOSS_STATS.corruptedZoneInterval * 0.8) { SoundManager.play('corruptedZoneAppear'); const zonePos = { x: Math.random() * (CANVAS_WIDTH - BOSS_STATS.corruptedZoneRadius*2) + BOSS_STATS.corruptedZoneRadius, y: Math.random() * (CANVAS_HEIGHT - BOSS_STATS.corruptedZoneRadius*2 - UI_BAR_HEIGHT) + BOSS_STATS.corruptedZoneRadius}; draft.corruptedZones.push({ id: `czone-${now}`, position: zonePos, radius: BOSS_STATS.corruptedZoneRadius, creationTime: now, duration: BOSS_STATS.corruptedZoneDuration, damage: BOSS_STATS.corruptedZoneDamage * projectileDamageMultiplier, damageInterval: BOSS_STATS.corruptedZoneDamageInterval, lastDamageTime: 0 }); boss.lastCorruptedZoneTime = now; } if (now - boss.lastGlitchMinionSpawnTime > BOSS_STATS.glitchMinionSpawnInterval * 0.7) { SoundManager.play('minionSpawn'); for (let i = 0; i < BOSS_STATS.glitchMinionSpawnCount + 1; i++) { const spawnOffsetAngle = Math.random() * Math.PI * 2; const spawnOffsetDist = boss.size * 0.75; draft.enemies.push({ id: `glitch-${now}-${i}`, type: EnemyType.GLITCH_MINION, position: { x: boss.position.x + Math.cos(spawnOffsetAngle) * spawnOffsetDist, y: boss.position.y + Math.sin(spawnOffsetAngle) * spawnOffsetDist }, size: GLITCH_MINION_STATS.size, baseSpeed: GLITCH_MINION_STATS.baseSpeed * 1.1, speed: GLITCH_MINION_STATS.baseSpeed * 1.1, health: GLITCH_MINION_STATS.health, damage: GLITCH_MINION_STATS.damage * projectileDamageMultiplier, expValue: GLITCH_MINION_STATS.expValue, color: GAME_COLORS.ENEMY_GLITCH_MINION, isVisible: true, dotEffects: [], statusEffects: [] }); } boss.lastGlitchMinionSpawnTime = now; } if (now - boss.lastDataStreamAttackTime > BOSS_STATS.dataStreamBarrageInterval && !boss.kernelPanicChargeStartTime) { SoundManager.play('dataStreamFire'); const playerDir = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y }); const baseAngle = Math.atan2(playerDir.y, playerDir.x); const spread = Math.PI / 4; for (let i = 0; i < BOSS_STATS.dataStreamProjectileCount; i++) { const angle = baseAngle - spread / 2 + (spread / (BOSS_STATS.dataStreamProjectileCount -1)) * i + (Math.random()-0.5)*0.1; const velocity = { x: Math.cos(angle) * BOSS_STATS.dataStreamProjectileSpeed, y: Math.sin(angle) * BOSS_STATS.dataStreamProjectileSpeed }; draft.projectiles.push({ id: `dstream-${now}-${i}`, position: { ...boss.position }, velocity, size: BOSS_STATS.dataStreamProjectileSize, color: GAME_COLORS.PROJECTILE_DATA_STREAM, damage: BOSS_STATS.dataStreamProjectileDamage * projectileDamageMultiplier, ownerId: boss.id, lifetime: 3000, type: 'boss_data_stream', baseSpeed: BOSS_STATS.dataStreamProjectileSpeed }); } boss.lastDataStreamAttackTime = now; } if (!boss.kernelPanicChargeStartTime && now - boss.lastKernelPanicPulseTime > BOSS_STATS.kernelPanicPulseCooldown) { boss.kernelPanicChargeStartTime = now; SoundManager.play('kernelPanicCharge'); draft.particles.push({ id: `kpanicwarn-${now}`, type: 'kernel_panic_warning', position: {...boss.position}, radius: BOSS_STATS.kernelPanicPulseRadius, targetRadius: BOSS_STATS.kernelPanicPulseRadius, color: GAME_COLORS.KERNEL_PANIC_PULSE_WARNING, life: BOSS_STATS.kernelPanicPulseChargeTime, size: 0 }); } if (boss.kernelPanicChargeStartTime && now > boss.kernelPanicChargeStartTime + BOSS_STATS.kernelPanicPulseChargeTime) { SoundManager.play('kernelPanicExecute'); draft.particles.push({ id: `kpanicboom-${now}`, type: 'kernel_panic_explosion', position: {...boss.position}, radius: 0, targetRadius: BOSS_STATS.kernelPanicPulseRadius, color: GAME_COLORS.TEXT_RED, life: 500, initialLife: 500, size: 0 }); if (calculateDistance(draft.player.position, boss.position) < BOSS_STATS.kernelPanicPulseRadius + draft.player.size/2) { if (!draft.player.overdriveActive && !draft.player.isDashing) { draft.player.health -= BOSS_STATS.kernelPanicPulseDamage * projectileDamageMultiplier; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } boss.kernelPanicChargeStartTime = 0; boss.lastKernelPanicPulseTime = now; } }
                            }
                            else if (boss.bossType === 'sincronizador') {
                                const projectileDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                
                                if (boss.phase === 1) { 
                                    if (now - boss.lastEnergyWaveTime > BOSS_2_STATS.phase1EnergyWaveInterval) {
                                        draft.particles.push({ id: `b2-wave-${now}`, type: 'boss_pulse', position: {...boss.position}, radius: 0, targetRadius: BOSS_2_STATS.phase1EnergyWaveRadius, color: GAME_COLORS.BOSS_2_ENERGY_WAVE, life: 700, initialLife: 700, size: 0, damage: BOSS_2_STATS.phase1EnergyWaveDamage * projectileDamageMultiplier, ownerId: boss.id });
                                        boss.lastEnergyWaveTime = now;
                                    }
                                } else {
                                    const novaCooldown = boss.phase === 3 ? BOSS_2_STATS.phase2NovaRate * 0.8 : BOSS_2_STATS.phase2NovaRate;
                                    if (now - boss.lastNovaAttackTime > novaCooldown) {
                                        boss.lastNovaAttackTime = now;
                                        SoundManager.play('dataStreamFire');
                                        for (let i = 0; i < BOSS_2_STATS.phase2NovaProjectileCount; i++) {
                                            const angle = (i / BOSS_2_STATS.phase2NovaProjectileCount) * Math.PI * 2;
                                            const velocity = { x: Math.cos(angle) * BOSS_2_STATS.phase2NovaProjectileSpeed, y: Math.sin(angle) * BOSS_2_STATS.phase2NovaProjectileSpeed };
                                            draft.projectiles.push({
                                                id: `b2-nova-${now}-${i}`,
                                                position: { ...boss.position },
                                                velocity,
                                                size: BOSS_2_STATS.phase2NovaProjectileSize,
                                                color: GAME_COLORS.BOSS_PROJECTILE_PHASE2,
                                                damage: BOSS_2_STATS.phase2NovaProjectileDamage * projectileDamageMultiplier,
                                                ownerId: boss.id,
                                                lifetime: 4000
                                            });
                                        }
                                    }
                                    if (now - boss.lastLaserTime > BOSS_2_STATS.laserCooldown) {
                                        SoundManager.play('laserCharge');
                                        draft.laserBeams.push({ id: `laser-${now}`, chargeStartTime: now, fireStartTime: now + BOSS_2_STATS.laserChargeTime, endTime: now + BOSS_2_STATS.laserChargeTime + BOSS_2_STATS.laserFireDuration, angle: Math.random() * Math.PI * 2, lastHitTime: 0, damage: BOSS_2_STATS.laserDamage * projectileDamageMultiplier });
                                        boss.lastLaserTime = now + BOSS_2_STATS.laserCooldown;
                                    }
                                    const wallCooldown = boss.phase === 3 ? BOSS_2_STATS.dataWallSpawnInterval * 0.7 : BOSS_2_STATS.dataWallSpawnInterval;
                                    if (now - boss.lastDataWallTime > wallCooldown) {
                                        const isHorizontal = Math.random() > 0.5;
                                        const startPos = isHorizontal ? -BOSS_2_STATS.dataWallWidth : CANVAS_WIDTH + BOSS_2_STATS.dataWallWidth;
                                        const numWalls = Math.floor((isHorizontal ? CANVAS_WIDTH : CANVAS_HEIGHT) / (BOSS_2_STATS.dataWallGap));
                                        for (let i = 0; i < numWalls; i++) {
                                            const wall = {
                                                id: `wall-${now}-${i}`,
                                                position: isHorizontal ? { x: startPos, y: i * BOSS_2_STATS.dataWallGap } : { x: i * BOSS_2_STATS.dataWallGap, y: startPos },
                                                velocity: isHorizontal ? { x: BOSS_2_STATS.dataWallSpeed, y: 0 } : { x: 0, y: -BOSS_2_STATS.dataWallSpeed },
                                                width: isHorizontal ? BOSS_2_STATS.dataWallWidth : BOSS_2_STATS.dataWallGap - 65,
                                                height: isHorizontal ? BOSS_2_STATS.dataWallGap - 65 : BOSS_2_STATS.dataWallWidth,
                                                damage: BOSS_2_STATS.dataWallDamage * projectileDamageMultiplier,
                                            };
                                            draft.dataWalls.push(wall);
                                        }
                                        boss.lastDataWallTime = now;
                                    }
                                    if (boss.phase === 3 && now - boss.lastMinionSpawnTime > BOSS_2_STATS.phase3MinionSpawnInterval) {
                                        SoundManager.play('minionSpawn');
                                        for (let i = 0; i < BOSS_2_STATS.phase3MinionSpawnCount; i++) { draft.enemies.push({ id: `glitch-b2-${now}-${i}`, type: EnemyType.GLITCH_MINION, position: { ...getRandomCanvasPosition() }, size: GLITCH_MINION_STATS.size, baseSpeed: GLITCH_MINION_STATS.baseSpeed*1.2, speed: GLITCH_MINION_STATS.baseSpeed*1.2, health: GLITCH_MINION_STATS.health*1.5, damage: GLITCH_MINION_STATS.damage*1.2 * projectileDamageMultiplier, expValue: 0, color: GAME_COLORS.ENEMY_GLITCH_MINION, isVisible: true, dotEffects: [], statusEffects: [] }); }
                                        boss.lastMinionSpawnTime = now;
                                    }
                                }
                            }
                            else if (boss.bossType === 'arbiter') {
                                if (!boss.hasStarted) {
                                    draft.ramSockets.forEach(s => s.isCorrupted = true);
                                    boss.hasStarted = true;
                                }

                                const nightmareDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;

                                if(boss.phase < 3) {
                                    if (isInvulnerableThisTick) {
                                        if (now > (boss.lastAttackTime.dataSmasher || 0) + BOSS_3_STATS.dataSmasherRate) {
                                            draft.bossAttacks.push({ type: BossAttackType.DATA_SMASHER, id: `smash-${now}`, targetPosition: { ...draft.player.position }, creationTime: now, warningDuration: BOSS_3_STATS.dataSmasherWarnTime, radius: BOSS_3_STATS.dataSmasherRadius, damage: BOSS_3_STATS.dataSmasherDamage * nightmareDamageMultiplier });
                                            boss.lastAttackTime.dataSmasher = now;
                                        }
                                        if (now > (boss.lastAttackTime.corruptionWave || 0) + BOSS_3_STATS.corruptionWaveRate) {
                                            const dirToPlayer = normalizeVector({ x: draft.player.position.x - boss.position.x, y: draft.player.position.y - boss.position.y });
                                            draft.projectiles.push({ id: `bwave-${now}`, position: { ...boss.position }, velocity: { x: dirToPlayer.x * BOSS_3_STATS.corruptionWaveSpeed, y: dirToPlayer.y * BOSS_3_STATS.corruptionWaveSpeed }, size: BOSS_3_STATS.corruptionWaveWidth, color: GAME_COLORS.BOSS_3_CORE, damage: BOSS_3_STATS.corruptionWaveDamage * nightmareDamageMultiplier, ownerId: boss.id, lifetime: 8000, type: 'corruption_wave'});
                                            boss.lastAttackTime.corruptionWave = now;
                                        }
                                        
                                        if(boss.phase === 2) {
                                            if (now > (boss.lastAttackTime.hostileTakeover || 0) + BOSS_3_STATS.hostileTakeoverRate) {
                                                const isHorizontal = Math.random() > 0.5;
                                                const lineCount = isHorizontal ? 9 : 12;
                                                const lineIndex = Math.floor(Math.random() * lineCount);
                                                const linePosition = lineIndex * 150 + 75;
                                                draft.bossAttacks.push({ type: BossAttackType.HOSTILE_TAKEOVER, id: `bus-${now}`, line: linePosition, isHorizontal, creationTime: now, warningDuration: BOSS_3_STATS.busWarnTime, fireDuration: BOSS_3_STATS.busFireDuration, damage: BOSS_3_STATS.busDamage * nightmareDamageMultiplier });
                                                boss.lastAttackTime.hostileTakeover = now;
                                            }
                                            if (now > (boss.lastAttackTime.corruptedPuddle || 0) + BOSS_3_STATS.phase2CorruptedPuddleRate) {
                                                SoundManager.play('corruptedZoneAppear');
                                                const zoneCount = 7;
                                                for (let i = 0; i < zoneCount; i++) {
                                                    draft.corruptedZones.push({
                                                        id: `czone-b3-${now}-${i}`,
                                                        position: getRandomCanvasPosition(),
                                                        radius: BOSS_3_STATS.phase2CorruptedPuddleRadius,
                                                        creationTime: now,
                                                        duration: BOSS_3_STATS.phase2CorruptedPuddleDuration,
                                                        damage: BOSS_3_STATS.phase2CorruptedPuddleDamage * nightmareDamageMultiplier,
                                                        damageInterval: BOSS_3_STATS.phase2CorruptedPuddleDamageInterval,
                                                        lastDamageTime: 0
                                                    });
                                                }
                                                boss.lastAttackTime.corruptedPuddle = now;
                                            }
                                            if (now > (boss.lastAttackTime.staticZone || 0) + BOSS_3_STATS.staticZoneRate) {
                                                for (let i = 0; i < BOSS_3_STATS.staticZoneCount; i++) {
                                                    draft.bossAttacks.push({ type: BossAttackType.STATIC_ZONE, id: `static-${now}-${i}`, position: getRandomCanvasPosition(), creationTime: now, duration: BOSS_3_STATS.staticZoneDuration, radius: BOSS_3_STATS.staticZoneRadius });
                                                }
                                                boss.lastAttackTime.staticZone = now;
                                            }
                                        }
                                    } else { 
                                        if (now > boss.vulnerableEndTime) {
                                            draft.ramSockets.forEach(s => s.isCorrupted = true);
                                            SoundManager.play('bossPhaseChange');
                                            draft.bossAttacks = [];
                                        }
                                    }
                                } else { 
                                    boss.position = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                                    boss.phase3AuraRadius += BOSS_3_STATS.phase3AuraExpandRate * deltaTime;
                                    if (now > boss.lastPhase3AuraDamageTime + BOSS_3_STATS.phase3AuraDamageTick) {
                                        if(calculateDistance(boss.position, draft.player.position) < boss.phase3AuraRadius && !draft.player.isDashing && !draft.player.overdriveActive) { 
                                            draft.player.health -= BOSS_3_STATS.phase3AuraDamage * nightmareDamageMultiplier * (1 - finalPlayerDamageReduction);
                                            if(draft.player.health <=0) { draft.player.health = 0; handleGameOverWithStats(); }
                                        }
                                        boss.lastPhase3AuraDamageTime = now;
                                    }
                                    if (now > (boss.lastAttackTime.phase3Bus || 0) + BOSS_3_STATS.phase3BusOverloadRate) {
                                        const isHorizontal = Math.random() > 0.5;
                                        const lineCount = isHorizontal ? 9 : 12;
                                        const lineIndex1 = Math.floor(Math.random() * lineCount);
                                        let lineIndex2 = Math.floor(Math.random() * lineCount);
                                        while(lineIndex2 === lineIndex1) lineIndex2 = Math.floor(Math.random() * lineCount);
                                        
                                        draft.bossAttacks.push({ type: BossAttackType.HOSTILE_TAKEOVER, id: `bus-p3-${now}-1`, line: lineIndex1 * 150 + 75, isHorizontal, creationTime: now, warningDuration: 700, fireDuration: 500, damage: BOSS_3_STATS.busDamage * nightmareDamageMultiplier });
                                        draft.bossAttacks.push({ type: BossAttackType.HOSTILE_TAKEOVER, id: `bus-p3-${now}-2`, line: lineIndex2 * 150 + 75, isHorizontal, creationTime: now, warningDuration: 700, fireDuration: 500, damage: BOSS_3_STATS.busDamage * nightmareDamageMultiplier });
                                        boss.lastAttackTime.phase3Bus = now;
                                    }
                                    if (now > (boss.lastAttackTime.phase3Volatile || 0) + BOSS_3_STATS.phase3VolatileMemoryRate) {
                                        for (let i = 0; i < 2; i++) {
                                            draft.acidPuddles.push({
                                                id: `puddle-boss-${now}-${i}`, position: getRandomCanvasPosition(), radius: 110,
                                                damagePerTick: BOSS_3_STATS.phase3VolatilePuddleDamage * nightmareDamageMultiplier, tickRate: 250,
                                                lastTickTime: now, endTime: now + BOSS_3_STATS.phase3VolatilePuddleDuration,
                                                ownerId: boss.id, color: GAME_COLORS.BOSS_3_AURA,
                                            });
                                        }
                                        boss.lastAttackTime.phase3Volatile = now;
                                    }
                                    if (now > (boss.lastAttackTime.finalJudgement || 0) + BOSS_3_STATS.phase3FinalJudgementRate) {
                                        for(let i = 0; i < 36; i++) {
                                            const angle = (i * 10) * (Math.PI/180);
                                            const velocity = { x: Math.cos(angle) * 350, y: Math.sin(angle) * 350 };
                                            draft.projectiles.push({ id: `bproj3-judgement-${now}-${i}`, position: { ...boss.position }, velocity, size: 20, color: GAME_COLORS.BOSS_3_BUS_FIRE, damage: 30 * nightmareDamageMultiplier, ownerId: boss.id, lifetime: 6000 });
                                        }
                                        boss.lastAttackTime.finalJudgement = now;
                                    }
                                }

                                if (boss.phase === 1 && boss.health / boss.maxHealth < BOSS_3_STATS.phase2HealthThreshold) {
                                    boss.phase = 2;
                                    SoundManager.play('bossPhaseChange');
                                    if(!isInvulnerableThisTick) boss.vulnerableEndTime = 0; 
                                    draft.ramSockets.forEach(s => s.isCorrupted = true);
                                    draft.bossAttacks = [];
                                } else if(boss.phase === 2 && boss.health / boss.maxHealth < BOSS_3_STATS.phase3HealthThreshold) {
                                    boss.phase = 3;
                                    boss.isInvulnerable = false;
                                    SoundManager.play('bossPhaseChange');
                                    draft.ramSockets = [];
                                    draft.bossAttacks = [];
                                }
                            }
                            else if(boss.bossType === 'hivemind_nexus') {
                                const nightmareDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                
                                if (boss.phase === 1 && activeShieldNodesCount === 0) {
                                    boss.phase = 2; SoundManager.play('bossPhaseChange'); boss.isInvulnerable = false;
                                    boss.lastAttackTime = {};
                                } else if (boss.phase === 2 && boss.health / boss.maxHealth < BOSS_4_STATS.phase3HealthThreshold) {
                                    boss.phase = 3; SoundManager.play('bossPhaseChange');
                                    boss.position = { x: CANVAS_WIDTH/2, y: CANVAS_HEIGHT/2 };
                                    boss.lastAttackTime = {};
                                }

                                if (boss.phase === 1) {
                                    if (now > (boss.lastAttackTime.dosWave || 0) + BOSS_4_STATS.dosWaveRate) {
                                        draft.particles.push({ id: `b4-wave-${now}`, type: 'boss_pulse', position: {...boss.position}, radius: 0, targetRadius: CANVAS_WIDTH, color: GAME_COLORS.BOSS_4_DOS_WAVE, life: 1500, initialLife: 1500, size: 0, damage: BOSS_4_STATS.dosWaveDamage * nightmareDamageMultiplier, ownerId: boss.id });
                                        boss.lastAttackTime.dosWave = now;
                                    }
                                } else if (boss.phase === 2) {
                                    if (now > (boss.lastAttackTime.packetFlood || 0) + BOSS_4_STATS.packetFloodRate) {
                                        for (let i = 0; i < 32; i++) {
                                            const angle = (i/32) * Math.PI*2;
                                            draft.projectiles.push({ id: `b4-packet-${now}-${i}`, position: {...boss.position}, velocity: { x: Math.cos(angle)*250, y: Math.sin(angle)*250 }, size: 12, color: GAME_COLORS.BOSS_PROJECTILE_PHASE2, damage: 15 * nightmareDamageMultiplier, ownerId: boss.id, lifetime: 5000 });
                                        }
                                        boss.lastAttackTime.packetFlood = now;
                                    }
                                    if (now > (boss.lastAttackTime.quarantine || 0) + BOSS_4_STATS.quarantineRate) {
                                        draft.corruptedZones.push({ id: `b4-qzone-${now}`, position: {...draft.player.position}, radius: 120, creationTime: now, duration: 4000, damage: BOSS_4_STATS.quarantineDamage * nightmareDamageMultiplier, damageInterval: 250, lastDamageTime: 0, color: 'rgba(255, 71, 87, 0.4)' });
                                        boss.lastAttackTime.quarantine = now;
                                    }
                                } else if (boss.phase === 3) {
                                    boss.arenaShrinkAmount += BOSS_4_STATS.arenaShrinkRate * deltaTime;
                                    if (draft.player.position.x < boss.arenaShrinkAmount || draft.player.position.x > CANVAS_WIDTH - boss.arenaShrinkAmount || draft.player.position.y < boss.arenaShrinkAmount || draft.player.position.y > CANVAS_HEIGHT - boss.arenaShrinkAmount) {
                                        if (now - draft.player.lastHitTime > 250) {
                                            draft.player.health -= 5 * nightmareDamageMultiplier; draft.player.lastHitTime = now;
                                            if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                                        }
                                    }
                                    if (now > (boss.lastAttackTime.portScan || 0) + BOSS_4_STATS.portScanRate * 0.7) {
                                        for(let i = 0; i < BOSS_4_STATS.portScanLaserCount; i++) {
                                            draft.laserBeams.push({ id: `b4-laser-${now}-${i}`, chargeStartTime: now, fireStartTime: now + 800, endTime: now + 800 + 1200, angle: Math.random() * Math.PI * 2, lastHitTime: 0, damage: BOSS_4_STATS.portScanDamage * nightmareDamageMultiplier });
                                        }
                                        boss.lastAttackTime.portScan = now;
                                    }
                                }
                            }
                        }

                        (draft.bossShieldNodes || []).forEach(node => {
                                node.vulnerabilityFactor = 1; node.statusEffects = node.statusEffects.filter(effect => { if (now > effect.startTime + effect.duration) return false; if(effect.type === StatusEffectType.VULNERABILITY) node.vulnerabilityFactor = Math.max(node.vulnerabilityFactor, effect.magnitude || 1.2); return true; });
                                if (node.health > 0) {
                                    if(!bossIsFrozen){
                                        const orbitSpeed = boss.bossType === 'guardian' ? BOSS_SHIELD_NODE_STATS.orbitSpeed : BOSS_2_SUB_ROUTINE_STATS.orbitSpeed;
                                        node.angle += orbitSpeed * (60 * deltaTime);
                                    }
                                    const orbitRadius = boss.bossType === 'guardian' ? BOSS_SHIELD_NODE_STATS.orbitRadius : BOSS_2_SUB_ROUTINE_STATS.orbitRadius;
                                    node.position.x = boss.position.x + Math.cos(node.angle) * orbitRadius; node.position.y = boss.position.y + Math.sin(node.angle) * orbitRadius;
                                    if (boss.bossType === 'sincronizador' && now - (node.lastShotTime || 0) > BOSS_2_SUB_ROUTINE_STATS.projectileFireRate) {
                                        const projectileDamageMultiplier = draft.isNightmareMode ? 1.25 : 1;
                                        const dirToPlayer = normalizeVector({ x: draft.player.position.x - node.position.x, y: draft.player.position.y - node.position.y });
                                        draft.projectiles.push({ id: `subroutine-proj-${node.id}-${now}`, position: { ...node.position }, velocity: { x: dirToPlayer.x * BOSS_2_SUB_ROUTINE_STATS.projectileSpeed, y: dirToPlayer.y * BOSS_2_SUB_ROUTINE_STATS.projectileSpeed }, size: BOSS_2_SUB_ROUTINE_STATS.projectileSize, color: GAME_COLORS.BOSS_2_SUB_ROUTINE, damage: BOSS_2_SUB_ROUTINE_STATS.projectileDamage * projectileDamageMultiplier, ownerId: boss.id, lifetime: 4000, type: 'boss_subroutine_shot' });
                                        node.lastShotTime = now;
                                    }
                                }
                            });
                            
                        if (boss.bossType === 'guardian') {
                            if (boss.phase === 1 && activeShieldNodesCount === 0) { boss.phase = 2; SoundManager.play('bossPhaseChange'); boss.isInvulnerable = false; boss.lastCorruptedZoneTime = now; boss.lastGlitchMinionSpawnTime = now; boss.lastPhase2AttackTime = now; for(let i=0; i<70; ++i) draft.particles.push({ id: `p-bossphase2-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*300, y: (Math.random()-0.5)*300 }, size: Math.random()*4+3, color: GAME_COLORS.ENEMY_GLITCH_MINION, life: Math.random() * 120 + 90 }); draft.projectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id || p.type === 'firewall_shard'); } 
                            else if (boss.phase === 2 && boss.health / boss.maxHealth < BOSS_PHASE_HEALTH_THRESHOLDS.PHASE_3) { boss.phase = 3; SoundManager.play('bossPhaseChange'); boss.lastDataStreamAttackTime = now; boss.lastKernelPanicPulseTime = now; boss.kernelPanicChargeStartTime = 0; for(let i=0; i<100; ++i) draft.particles.push({ id: `p-bossphase3-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*400, y: (Math.random()-0.5)*400 }, size: Math.random()*5+4, color: GAME_COLORS.PROJECTILE_DATA_STREAM, life: Math.random() * 150 + 100 }); draft.projectiles = draft.projectiles.filter(p => p.ownerId === draft.player.id || p.type === 'firewall_shard'); }
                        } else if (boss.bossType === 'sincronizador') {
                            if (boss.phase === 1 && activeShieldNodesCount === 0) { boss.phase = 2; SoundManager.play('bossPhaseChange'); boss.isInvulnerable = false; boss.lastLaserTime = now + 2000; boss.lastDataWallTime = now; for(let i=0; i<80; ++i) draft.particles.push({ id: `p-b2phase2-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*350, y: (Math.random()-0.5)*350 }, size: Math.random()*4+3, color: GAME_COLORS.BOSS_2_CORE, life: Math.random() * 130 + 90 }); }
                            else if (boss.phase === 2 && boss.health / boss.maxHealth < BOSS_2_STATS.phase3HealthThreshold) { boss.phase = 3; SoundManager.play('bossPhaseChange'); boss.lastMinionSpawnTime = now; }
                        }

                        draft.particles.forEach(particle => {
                            if (particle.ownerId === boss.id && !draft.player.isDashing && !draft.player.overdriveActive) {
                                if (particle.type === 'boss_pulse' && particle.radius && particle.life > 0) {
                                    const distToPlayer = calculateDistance(draft.player.position, particle.position);
                                    const waveWidth = 20;
                                    if (distToPlayer > particle.radius - waveWidth && distToPlayer < particle.radius + waveWidth) {
                                        if (now - draft.player.lastHitTime > 500) {
                                            let damageTaken = (particle.damage || 0) * (1 - finalPlayerDamageReduction);
                                            draft.player.health -= damageTaken;
                                            if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                            draft.player.lastHitTime = now;
                                            SoundManager.play('playerHit');
                                            if (draft.player.health <= 0) {
                                                draft.player.health = 0;
                                                handleGameOverWithStats();
                                            }
                                        }
                                    }
                                }
                            }
                        });

                        if (boss.health <= 0) {
                            sessionStatsRef.current.defeatedBosses.add(boss.bossType);
                            onStageClearCallback(draft.stage, draft.isNightmareMode);
                            draft.boss = null; 
                            draft.bossShieldNodes = []; 
                            draft.corruptedZones = []; 
                            draft.dataWalls = []; 
                            draft.laserBeams = []; 
                            draft.ramSockets = []; 
                            draft.bossAttacks = [];
                            draft.enemies = draft.enemies.filter(e => e.type !== EnemyType.GLITCH_MINION); 
                            SoundManager.play('enemyDie');  
                            const rewardPosition = { ...boss.position };
                            for (let i = 0; i < 2; ++i) {
                                draft.knowledgeOrbs.push({
                                    id: `k-orb-boss-${now}-${i}`,
                                    position: { x: rewardPosition.x + (Math.random() - 0.5) * 50, y: rewardPosition.y + (Math.random() - 0.5) * 50 },
                                    size: 25,
                                });
                            }
                            for(let i=0; i<150; ++i) draft.particles.push({ id: `p-bossdeath-${now}-${i}`, position: { ...boss.position }, velocity: { x: (Math.random()-0.5)*350, y: (Math.random()-0.5)*350 }, size: Math.random()*5+3, color: boss.color, life: Math.random() * 180 + 120 });
                        }
                    }
                    
                    draft.laserBeams = draft.laserBeams.filter(laser => {
                        if (now >= laser.fireStartTime && now < laser.endTime) {
                            const laserRotationSpeed = BOSS_2_STATS.laserRotationSpeed * (draft.boss?.phase === 3 ? 1.5 : 1);
                            laser.angle += laserRotationSpeed * (60 * deltaTime);
                            const laserDir = { x: Math.cos(laser.angle), y: Math.sin(laser.angle) };
                            const playerToBoss = { x: draft.player.position.x - (draft.boss?.position?.x || 0), y: draft.player.position.y - (draft.boss?.position?.y || 0) };
                            const distToLaserLine = Math.abs(playerToBoss.x * laserDir.y - playerToBoss.y * laserDir.x);
                            if (distToLaserLine < (BOSS_2_STATS.laserWidth / 2 + draft.player.size / 2)) {
                                    if (now - (laser.lastHitTime || 0) > 250 && !draft.player.overdriveActive && !draft.player.isDashing) {
                                    let damageTaken = (laser.damage || 0) * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                                    draft.player.health -= damageTaken;
                                    if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                    sessionStatsRef.current.damageTaken += damageTaken;
                                    if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                    laser.lastHitTime = now; SoundManager.play('playerHit');
                                    if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                                    }
                            }
                        }
                        return now < laser.endTime;
                    });
                    draft.dataWalls.forEach(wall => {
                        wall.position.x += wall.velocity.x * deltaTime; wall.position.y += wall.velocity.y * deltaTime;
                        const playerRect = { x: draft.player.position.x - draft.player.size / 2, y: draft.player.position.y - draft.player.size / 2, width: draft.player.size, height: draft.player.size };
                        const wallRect = { x: wall.position.x, y: wall.position.y, width: wall.width, height: wall.height };
                        if (playerRect.x < wallRect.x + wallRect.width && playerRect.x + playerRect.width > wallRect.x && playerRect.y < wallRect.y + wallRect.height && playerRect.y + playerRect.height > wallRect.y) {
                            if (now - draft.player.lastHitTime > 500 && !draft.player.overdriveActive && !draft.player.isDashing) {
                                const damageTaken = (wall.damage || 0) * (1 - finalPlayerDamageReduction);
                                draft.player.health -= damageTaken; 
                                if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                sessionStatsRef.current.damageTaken += damageTaken;
                                if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                            }
                        }
                    });
                    draft.dataWalls = draft.dataWalls.filter(wall => wall.position.x > -wall.width && wall.position.x < CANVAS_WIDTH && wall.position.y > -wall.height && wall.position.y < CANVAS_HEIGHT);
                    draft.corruptedZones = draft.corruptedZones.filter(zone => { if (now > zone.creationTime + zone.duration) return false; if (calculateDistance(draft.player.position, zone.position) < zone.radius + draft.player.size / 2) { if (now - (zone.lastDamageTime || 0) > zone.damageInterval) { if (!draft.player.overdriveActive && !draft.player.isDashing) { 
                        const damageTaken = zone.damage * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                        draft.player.health -= damageTaken; 
                        if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                        sessionStatsRef.current.damageTaken += damageTaken;
                        if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                        SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } zone.lastDamageTime = now; } } return true; });
                    
                    const finalCooldownModifier = draft.player.cooldownModifier * playerCooldownMultiplier;
                    const finalDamageMultiplier = draft.player.globalDamageFactor * draft.player.overdriveDamageBonusFactor * playerDamageMultiplier;
                    
                    const applyCritDamage = (baseDamage, target) => {
                        let finalDamage = baseDamage;
                        const isCrit = Math.random() < draft.player.critChance;
                        
                        if (isCrit) {
                            finalDamage *= draft.player.critDamage;
                            draft.particles.push({ id: `crit-${target.id}-${now}`, type: 'crit_text', position: { ...target.position }, velocity: {x: 0, y: -80}, life: 500, text: 'CR√çTICO!', color: GAME_COLORS.CRITICAL_HIT_TEXT, size: 20 });

                            const aniquilacaoLevel = permanentBuffs.shop?.capstone_offense || 0;
                            if (aniquilacaoLevel > 0) {
                                const explosionRadius = 60;
                                const explosionDamage = finalDamage * 0.30;
                                
                                draft.particles.push({ id: `crit-explosion-${target.id}-${now}`, type: 'aegis_pulse', position: { ...target.position }, radius: 0, targetRadius: explosionRadius, color: 'rgba(255, 193, 7, 0.7)', life: 200, size: 0 });

                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss ? [draft.boss] : [])].forEach(nearbyEnemy => {
                                    if (nearbyEnemy.id !== target.id && nearbyEnemy.health > 0) {
                                        if (calculateDistance(target.position, nearbyEnemy.position) < explosionRadius) {
                                            let finalExplosionDamage = explosionDamage * (nearbyEnemy.vulnerabilityFactor || 1);
                                            if (nearbyEnemy.type === EnemyType.SEGMENTO_FALHA && nearbyEnemy.isShielded) { finalExplosionDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                            nearbyEnemy.health -= finalExplosionDamage;
                                            sessionStatsRef.current.damageDealtByWeapon['capstone_offense'] = (sessionStatsRef.current.damageDealtByWeapon['capstone_offense'] || 0) + finalExplosionDamage;
                                        }
                                    }
                                });
                            }
                        }
                        return finalDamage;
                    };

                    draft.player.weapons.forEach(w => {
                        const weaponBaseId = w.originalBaseWeaponId || w.id.split('_')[0];
                        const weaponMastery = weaponMasteryStats[weaponBaseId];
                        let masteryDamageMultiplier = 1.0;
                        let masterySpeedMultiplier = 1.0;
                        if (weaponMastery) {
                            masteryDamageMultiplier += weaponMastery.damage_multiplier || 0;
                            masterySpeedMultiplier += weaponMastery.projectile_speed || 0;
                        }
                        const weaponFinalDamageMultiplier = finalDamageMultiplier * masteryDamageMultiplier;

                        if (w.isEvolved && !sessionStatsRef.current.evolvedWeapons.has(w.id)){
                            sessionStatsRef.current.evolvedWeapons.add(w.id);
                            sessionStatsRef.current.evolvedWeaponIds.add(w.evolutionId);
                        }
                        if ((w.id === 'antivirus' || w.id === 'antivirus_system_purge' || w.id === 'antivirus_hunter_swarm' || w.id === 'antivirus_tesla_coil') && w.lastShotTime !== undefined) {
                            let fireRate = ANTIVIRUS_SCAN_STATS.fireRate * Math.pow(0.85, ownedUpgradesRef.current.get('antivirus_rate') || 0);
                            if (w.id === 'antivirus_system_purge') fireRate *= 1.1; if (w.id === 'antivirus_hunter_swarm') fireRate *= 1.2; if (w.id === 'antivirus_tesla_coil') fireRate *= 0.95;
                            if (now - w.lastShotTime > fireRate * finalCooldownModifier && (draft.enemies.length > 0 || (draft.boss && draft.bossShieldNodes.some(n => n.health > 0)) || (draft.boss && !draft.boss.isInvulnerable) )) {
                                let closestTarget = null; let minDistance = Infinity; const potentialTargets = []; if (draft.boss && draft.boss.isInvulnerable) potentialTargets.push(...draft.bossShieldNodes.filter(n => n.health > 0)); else if (draft.boss) potentialTargets.push(draft.boss); potentialTargets.push(...draft.enemies.filter(e => e.isCurrentlyVisible !== false && e.health > 0)); potentialTargets.forEach(target => { const distance = calculateDistance(target.position, draft.player.position); if (distance < minDistance) { minDistance = distance; closestTarget = target; } });
                                if (closestTarget) {
                                    SoundManager.play('shoot');
                                    const baseDirection = normalizeVector({ x: closestTarget.position.x - draft.player.position.x, y: closestTarget.position.y - draft.player.position.y });
                                    let projectileDamage = (ANTIVIRUS_SCAN_STATS.damage + 8 * (ownedUpgradesRef.current.get('antivirus_damage') || 0)) * weaponFinalDamageMultiplier;
                                    if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && closestTarget.health === closestTarget.maxHealth) { projectileDamage *= 1.25; }
                                    const pierceCount = ownedUpgradesRef.current.get('antivirus_pierce') || 0;
                                    let projectileSize = ANTIVIRUS_SCAN_STATS.projectileSize;
                                    let currentProjectileBaseSpeed = ANTIVIRUS_SCAN_STATS.projectileSpeed * (draft.player.projectileSpeedModifier || 1.0) * masterySpeedMultiplier;
                                    let projectileAppliesStatus = null; 
                                    const cryoLevel = ownedUpgradesRef.current.get('antivirus_cryo_rounds') || 0; 
                                    if (cryoLevel > 0) {
                                        if (cryoLevel >= 4) {
                                            projectileAppliesStatus = { type: StatusEffectType.FREEZE, chance: 0.15, duration: STATUS_EFFECT_PARAMS[StatusEffectType.FREEZE].baseDuration, sourceId: 'antivirus_cryo_rounds_freeze' };
                                        } else {
                                            projectileAppliesStatus = { type: StatusEffectType.SLOW, chance: 0.20 + cryoLevel * 0.05, duration: STATUS_EFFECT_PARAMS[StatusEffectType.SLOW].baseDuration, magnitude: STATUS_EFFECT_PARAMS[StatusEffectType.SLOW].baseMagnitude - (cryoLevel-1) * 0.05, sourceId: 'antivirus_cryo_rounds' };
                                        }
                                    }
                                    let projectileChainLightning = null; if (w.id === 'antivirus_tesla_coil') { projectileChainLightning = { maxChains: STATUS_EFFECT_PARAMS.CHAIN_LIGHTNING.baseMaxChains + 1, range: STATUS_EFFECT_PARAMS.CHAIN_LIGHTNING.baseRange + 25, damageMultiplierPerChain: STATUS_EFFECT_PARAMS.CHAIN_LIGHTNING.baseDamageMultiplier, color: GAME_COLORS.PROJECTILE_CHAIN_LIGHTNING, currentChainHits: 0 }; }
                                    
                                    const firstShotCritMastery = weaponMastery?.first_shot_crit;
                                    
                                    const createProjectile = (extraProps = {}) => {
                                        const proj = { id: `proj-${w.id}-${now}-${Math.random()}`, position: { ...draft.player.position }, baseSpeed: currentProjectileBaseSpeed, velocity: { x: baseDirection.x * currentProjectileBaseSpeed, y: baseDirection.y * currentProjectileBaseSpeed }, size: projectileSize, color: GAME_COLORS.PROJECTILE, damage: projectileDamage, ownerId: draft.player.id, pierceCount, hitEnemyIds: [], lifetime: 3000, type: 'antivirus_shot', appliesStatus: projectileAppliesStatus, chainLightning: projectileChainLightning, hitEnemyIdsChain: [], weaponBaseId, ...extraProps };
                                        if (firstShotCritMastery) {
                                            proj.isFirstShotCrit = true;
                                        }
                                        return proj;
                                    };
                                    
                                    if (w.id === 'antivirus_system_purge') {
                                        projectileDamage += ANTIVIRUS_SCAN_STATS.systemPurgeDamageBonus;
                                        projectileSize *= ANTIVIRUS_SCAN_STATS.systemPurgeSizeMultiplier;
                                        const totalSpread = ANTIVIRUS_SCAN_STATS.systemPurgeSpreadAngle;
                                        const angleBetweenShots = ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot > 1 ? totalSpread / (ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot -1) : 0;
                                        const startAngle = Math.atan2(baseDirection.y, baseDirection.x) - (ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot > 1 ? totalSpread / 2 : 0);
                                        for (let i = 0; i < ANTIVIRUS_SCAN_STATS.systemPurgeProjectilesPerShot; i++) {
                                            const currentAngle = startAngle + (i * angleBetweenShots);
                                            const direction = { x: Math.cos(currentAngle), y: Math.sin(currentAngle) };
                                            draft.projectiles.push(createProjectile({ id: `proj-${w.id}-${now}-${i}`, velocity: { x: direction.x * currentProjectileBaseSpeed, y: direction.y * currentProjectileBaseSpeed }, color: GAME_COLORS.PROJECTILE_SYSTEM_PURGE, type: 'antivirus_system_purge_shot'}));
                                        }
                                    } else if (w.id === 'antivirus_hunter_swarm') {
                                        currentProjectileBaseSpeed = ANTIVIRUS_SCAN_STATS.hunterSwarmProjectileSpeed * (draft.player.projectileSpeedModifier || 1.0);
                                        projectileDamage = (ANTIVIRUS_SCAN_STATS.hunterSwarmDamage + 8 * (ownedUpgradesRef.current.get('antivirus_damage') || 0)) * weaponFinalDamageMultiplier;
                                        projectileSize *= ANTIVIRUS_SCAN_STATS.hunterSwarmSizeMultiplier;
                                        draft.projectiles.push(createProjectile({ baseSpeed: currentProjectileBaseSpeed, damage: projectileDamage, size: projectileSize, color: GAME_COLORS.PROJECTILE_HUNTER_SWARM, lifetime: 4000, type: 'antivirus_hunter_swarm_shot', isSeeking: true, targetEnemyId: closestTarget.id, appliesDot: { sourceEvolutionId: "antivirus_hunter_swarm", damagePerTick: ANTIVIRUS_SCAN_STATS.hunterSwarmDotDamagePerTick * weaponFinalDamageMultiplier, duration: ANTIVIRUS_SCAN_STATS.hunterSwarmDotDuration, tickInterval: ANTIVIRUS_SCAN_STATS.hunterSwarmDotTickInterval } }));
                                    } else {
                                        draft.projectiles.push(createProjectile({type: w.id === 'antivirus_tesla_coil' ? 'antivirus_tesla_shot' : 'antivirus_shot' }));
                                    }
                                    w.lastShotTime = now;
                                }
                            }
                        }
                        else if (w.id === 'firewall' || w.id === 'firewall_aegis_shield') {
                            const masteryRadiusMultiplier = weaponMastery?.radius_multiplier ? 1 + weaponMastery.radius_multiplier : 1;
                            const firewallRadius = FIREWALL_STATS.radius * masteryRadiusMultiplier;
                            if (w.orbs === undefined || w.currentAngle === undefined) return;
                            w.currentAngle += FIREWALL_STATS.angleSpeed * (60 * deltaTime);
                            const isAegis = w.id === 'firewall_aegis_shield';
                            if (isAegis) {
                                if (!w.lastPulseTime) w.lastPulseTime = now;
                                if (now - w.lastPulseTime >= FIREWALL_STATS.aegisPulseFrequency * finalCooldownModifier) {
                                    for (let i = 0; i < w.orbs; i++) {
                                        const angle = w.currentAngle + (i * (2 * Math.PI / w.orbs));
                                        const orbPosition = { x: draft.player.position.x + Math.cos(angle) * firewallRadius, y: draft.player.position.y + Math.sin(angle) * firewallRadius };
                                        draft.particles.push({ id: `aegis-pulse-${now}-${i}`, type: 'aegis_pulse', position: orbPosition, radius: 0, targetRadius: FIREWALL_STATS.aegisPulseRadius + (FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier / 2), color: GAME_COLORS.FIREWALL_AEGIS_PULSE, life: 300, initialLife: 300, size: 0 });
                                        [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                            if(target.health <= 0) return;
                                            const targetSize = target.bossType ? (target.bossType === 'guardian' ? target.coreSize/2 : target.size/2) : target.size/2;
                                            if (calculateDistance(target.position, orbPosition) < FIREWALL_STATS.aegisPulseRadius + (FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier / 2) + targetSize) {
                                                let pulseBaseDamage = FIREWALL_STATS.aegisPulseDamage * weaponFinalDamageMultiplier * (decompilerBonuses[target.type] || 1.0) * (target.vulnerabilityFactor || 1);
                                                let damageDealt = applyCritDamage(pulseBaseDamage, target);
                                                if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { damageDealt *= 1.25; }
                                                if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { damageDealt *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                                target.health -= damageDealt;
                                                sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + damageDealt;
                                            }
                                        });
                                    }
                                    w.lastPulseTime = now;
                                }
                            }
                            const shardLevel = ownedUpgradesRef.current.get('firewall_shards') || 0;
                            if (shardLevel > 0) {
                                let shardFrequency = FIREWALL_STATS.shardBaseFrequency / shardLevel;
                                let shardDamage = FIREWALL_STATS.shardBaseDamage * shardLevel;
                                if (isAegis) shardDamage += FIREWALL_STATS.aegisShardDamageBonus;
                                shardDamage *= weaponFinalDamageMultiplier;
                                for (let i = 0; i < w.orbs; i++) {
                                    if (!w.lastShardTimes) w.lastShardTimes = {};
                                    if (now - (w.lastShardTimes[i] || 0) > shardFrequency * finalCooldownModifier) {
                                        const angle = w.currentAngle + (i * (2 * Math.PI / w.orbs));
                                        const orbPosition = { x: draft.player.position.x + Math.cos(angle) * firewallRadius, y: draft.player.position.y + Math.sin(angle) * firewallRadius };
                                        let closestEnemy = null; let minDistance = Infinity;
                                        const potentialTargets = []; if (draft.boss && draft.boss.isInvulnerable) potentialTargets.push(...draft.bossShieldNodes.filter(n => n.health > 0)); else if (draft.boss) potentialTargets.push(draft.boss); potentialTargets.push(...draft.enemies.filter(e => e.isCurrentlyVisible !== false && e.health > 0));
                                        potentialTargets.forEach(target => {
                                            const dist = calculateDistance(target.position, orbPosition);
                                            if (dist < 150 && dist < minDistance) { minDistance = dist; closestEnemy = target; }
                                        });
                                        if (closestEnemy) {
                                            const direction = normalizeVector({ x: closestEnemy.position.x - orbPosition.x, y: closestEnemy.position.y - orbPosition.y });
                                            draft.projectiles.push({ id: `shard-${w.id}-${now}-${i}`, position: { ...orbPosition }, baseSpeed: FIREWALL_STATS.shardSpeed * (draft.player.projectileSpeedModifier || 1.0), velocity: { x: direction.x * FIREWALL_STATS.shardSpeed, y: direction.y * FIREWALL_STATS.shardSpeed }, size: FIREWALL_STATS.shardSize * (isAegis ? 1.2 : 1), color: GAME_COLORS.PROJECTILE_SHARD, damage: shardDamage, ownerId: draft.player.id, pierceCount: 0, hitEnemyIds: [], lifetime: FIREWALL_STATS.shardLifetime, type: 'firewall_shard', weaponBaseId });
                                            w.lastShardTimes[i] = now;
                                        }
                                    }
                                }
                            }
                        }
                        else if ((w.id === 'acid_virus' || w.id === 'acid_virus_pandemic') && w.lastShotTime !== undefined) {
                            const masteryDurationMultiplier = weaponMastery?.duration_multiplier ? 1 + weaponMastery.duration_multiplier : 1;
                            let cooldown = ACID_VIRUS_STATS.cooldown;
                            if (now - w.lastShotTime > cooldown * finalCooldownModifier && (draft.enemies.length > 0 || (draft.boss && draft.bossShieldNodes.some(n => n.health > 0)) || (draft.boss && !draft.boss.isInvulnerable) )) {
                                let closestTarget = null; let minDistance = Infinity;
                                const potentialTargets = []; if (draft.boss && draft.boss.isInvulnerable) potentialTargets.push(...draft.bossShieldNodes.filter(n => n.health > 0)); else if (draft.boss) potentialTargets.push(draft.boss); potentialTargets.push(...draft.enemies.filter(e => e.isCurrentlyVisible !== false && e.health > 0));
                                potentialTargets.forEach(target => { const distance = calculateDistance(target.position, draft.player.position); if (distance < minDistance) { minDistance = distance; closestTarget = target; } });
                                if(closestTarget) {
                                    SoundManager.play('acidVirusShot');
                                    const direction = normalizeVector({ x: closestTarget.position.x - draft.player.position.x, y: closestTarget.position.y - draft.player.position.y });
                                    const isEvolved = w.id === 'acid_virus_pandemic';
                                    draft.projectiles.push({
                                        id: `acid-${w.id}-${now}`,
                                        position: { ...draft.player.position },
                                        velocity: { x: direction.x * ACID_VIRUS_STATS.projectileSpeed, y: direction.y * ACID_VIRUS_STATS.projectileSpeed },
                                        size: ACID_VIRUS_STATS.projectileSize,
                                        color: GAME_COLORS.PROJECTILE_ACID_VIRUS,
                                        ownerId: draft.player.id,
                                        type: 'acid_virus_shot',
                                        isEvolved,
                                        pierceCount: isEvolved ? 2 : 0, 
                                        hitEnemyIds: [],
                                        lifetime: 3000,
                                        weaponBaseId,
                                        masteryDurationMultiplier
                                    });
                                    w.lastShotTime = now;
                                }
                            }
                        }
                        else if (w.id === 'defrag' || w.id === 'defrag_quantum_optimizer') {
                            w.comboCounter = w.comboCounter || 0;
                            let cooldown = DEFRAG_STATS.cooldown * Math.pow(0.88, ownedUpgradesRef.current.get('defrag_cooldown') || 0);
                            if (weaponMastery?.cooldown_multiplier) {
                                cooldown *= (1 + weaponMastery.cooldown_multiplier);
                            }
                            if (w.id === 'defrag_quantum_optimizer') cooldown *= 0.6;
                            
                            if (now - w.lastShotTime > cooldown * finalCooldownModifier) {
                                SoundManager.play('defragSwing');
                                
                                const isSpinAttack = w.id === 'defrag_quantum_optimizer' || (w.comboCounter >= DEFRAG_STATS.comboHitsForSpin);

                                if (isSpinAttack && w.id !== 'defrag_quantum_optimizer') {
                                    w.comboCounter = 0;
                                } else {
                                    w.comboCounter++;
                                }

                                let baseDamage = (DEFRAG_STATS.damage + 12 * (ownedUpgradesRef.current.get('defrag_damage') || 0)) * weaponFinalDamageMultiplier;
                                let arcRange = DEFRAG_STATS.range * Math.pow(1.15, ownedUpgradesRef.current.get('defrag_range') || 0) * (draft.player.projectileRangeModifier || 1);
                                let arcAngle = DEFRAG_STATS.arc;
                                let playerAngle = Math.atan2(draft.player.lastMoveDirection.y, draft.player.lastMoveDirection.x);
                                
                                if(isSpinAttack) {
                                    baseDamage *= DEFRAG_STATS.spinDamageMultiplier;
                                    arcRange *= DEFRAG_STATS.spinRangeMultiplier;
                                    arcAngle = 2 * Math.PI;
                                }

                                draft.particles.push({id: `defrag-arc-${now}`, type: 'defrag_arc', position: {...draft.player.position}, startAngle: isSpinAttack ? 0 : playerAngle - arcAngle/2, endAngle: isSpinAttack ? 2*Math.PI : playerAngle + arcAngle/2, radius: arcRange, color: GAME_COLORS.EFFECT_DEFRAG, life: 100});
                                let hitCountThisSwing = 0;
                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                    if (target.health <= 0) return;
                                    const dist = calculateDistance(draft.player.position, target.position);
                                    const targetSize = target.bossType ? target.coreSize / 2 : target.size / 2;
                                    if (dist < arcRange + targetSize) {
                                        const angleToTarget = Math.atan2(target.position.y - draft.player.position.y, target.position.x - draft.player.position.x);
                                        let angleDiff = Math.abs(playerAngle - angleToTarget);
                                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                                        
                                        if (isSpinAttack || angleDiff < arcAngle / 2) {
                                            const decompilerBonus = decompilerBonuses[target.type] || 1.0;
                                            let damageToTarget = baseDamage * decompilerBonus * (target.vulnerabilityFactor || 1);
                                            let finalDamage = applyCritDamage(damageToTarget, target);
                                            if(draft.boss && draft.boss.bossType === 'arbiter' && draft.boss.phase === 3) finalDamage *= 2;
                                            if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { finalDamage *= 1.25; }
                                            if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                            target.health -= finalDamage;
                                            sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + finalDamage;
                                            hitCountThisSwing++;
                                        }
                                    }
                                });

                                if (weaponMastery?.speed_on_cleave && hitCountThisSwing >= 3) {
                                    draft.player.temporaryBuffs.push({id: `defrag-mastery-${now}`, type: TemporaryBuffType.MOVE_SPEED, magnitude: 1.2, endTime: now + 2000, sourceId: "defrag_mastery", icon: 'üèÉ'});
                                }
                                
                                const fragmentLevel = ownedUpgradesRef.current.get('defrag_fragments') || 0;
                                if (isSpinAttack && (fragmentLevel > 0 || w.id === 'defrag_quantum_optimizer')) {
                                    const fragmentCount = 6;
                                    const fragmentDamage = baseDamage * (0.2 + fragmentLevel * 0.05);
                                    for (let i = 0; i < fragmentCount; i++) {
                                        const angle = (i / fragmentCount) * Math.PI * 2;
                                        const direction = { x: Math.cos(angle), y: Math.sin(angle) };
                                        draft.projectiles.push({
                                            id: `defrag-frag-${now}-${i}`,
                                            position: { ...draft.player.position },
                                            velocity: { x: direction.x * 300, y: direction.y * 300 },
                                            size: 10,
                                            color: GAME_COLORS.EFFECT_DEFRAG,
                                            damage: fragmentDamage,
                                            ownerId: draft.player.id,
                                            pierceCount: fragmentLevel,
                                            hitEnemyIds: [],
                                            lifetime: 1000,
                                            type: 'defrag_fragment',
                                            weaponBaseId
                                        });
                                    }
                                }
                                w.lastShotTime = now;
                            }
                        }
                        else if (w.id === 'data_leech' || w.id === 'leech_siphon_chain') {
                            w.lastPlayerPos = w.lastPlayerPos || {...draft.player.position};
                            w.chainTargetIds = [];

                            if (now > (w.critSurgeEndTime || 0)) { w.isCriticallySurging = false; }
                            if (!w.isCriticallySurging && now - (w.lastCritCheckTime || 0) > 1000) {
                                w.lastCritCheckTime = now;
                                if (Math.random() < draft.player.critChance) {
                                    w.isCriticallySurging = true;
                                    w.critSurgeEndTime = now + 500;
                                }
                            }

                            let stillRampUpSpeed = DATA_LEECH_STATS.stillDamageRampUpTime;
                            if (weaponMastery?.still_bonus_speed) {
                                stillRampUpSpeed /= weaponMastery.still_bonus_speed;
                            }

                            const playerIsStill = calculateDistance(w.lastPlayerPos, draft.player.position) < 1;
                            if(playerIsStill) {
                                w.stillTime = Math.min(stillRampUpSpeed, (w.stillTime || 0) + deltaTime * 1000);
                            } else {
                                w.stillTime = 0;
                                w.lastPlayerPos = {...draft.player.position};
                            }
                            const stillMultiplier = 1 + ((DATA_LEECH_STATS.stillDamageMultiplierMax - 1) * (w.stillTime / stillRampUpSpeed));

                            const masteryRangeMultiplier = weaponMastery?.range_multiplier ? 1 + weaponMastery.range_multiplier : 1;
                            const range = DATA_LEECH_STATS.range * Math.pow(1.2, ownedUpgradesRef.current.get('leech_range') || 0) * masteryRangeMultiplier * (draft.player.projectileRangeModifier || 1);
                            const currentTarget = [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss ? [draft.boss] : [])].find(e => e.id === w.targetId && e.health > 0);
                            
                            if (!currentTarget || calculateDistance(draft.player.position, currentTarget.position) > range) {
                                w.targetId = null;
                                let closestTarget = null, minDistance = range;
                                [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(e => {
                                    if (e.isCurrentlyVisible !== false && e.health > 0) {
                                        const dist = calculateDistance(draft.player.position, e.position);
                                        if(dist < minDistance) { minDistance = dist; closestTarget = e; }
                                    }
                                });
                                if(closestTarget) {
                                    w.targetId = closestTarget.id;
                                    SoundManager.play('dataLeechConnect');
                                }
                            }

                            if(w.targetId && now - (w.lastTickTime || 0) > DATA_LEECH_STATS.tickRate) {
                                const baseDamagePerTick = (DATA_LEECH_STATS.damagePerTick + (ownedUpgradesRef.current.get('leech_damage') || 0) * 0.75);
                                let damage = baseDamagePerTick * weaponFinalDamageMultiplier * stillMultiplier;
                                
                                if(w.isCriticallySurging) {
                                    damage *= draft.player.critDamage;
                                }

                                const primaryTarget = [...draft.enemies, ...draft.bossShieldNodes, draft.boss].find(e => e && e.id === w.targetId);
                                
                                if(primaryTarget) {
                                    const decompilerBonus = decompilerBonuses[primaryTarget.type] || 1.0;
                                    let finalDamage = damage * decompilerBonus * (primaryTarget.vulnerabilityFactor || 1) * (primaryTarget.type === EnemyType.SEGMENTO_FALHA && primaryTarget.isShielded ? (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction) : 1);
                                    if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && primaryTarget.health === primaryTarget.maxHealth) { finalDamage *= 1.25; }
                                    primaryTarget.health -= finalDamage;
                                    sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + finalDamage;
                                    if((ownedUpgradesRef.current.get('leech_slow') || 0) > 0) {
                                        _applyStatusEffectToEntity(primaryTarget, {type: StatusEffectType.SLOW, duration: 200, magnitude: 0.7, sourceId: 'data_leech_slow'}, now);
                                    }

                                    let chainCount = ownedUpgradesRef.current.get('leech_chain') || 0;
                                    if (w.id === 'leech_siphon_chain') { chainCount += 4; } 

                                    if (chainCount > 0) {
                                        let potentialTargets = [...draft.enemies, ...draft.bossShieldNodes];
                                        let validChainTargets = potentialTargets
                                            .filter(e => e.id !== primaryTarget.id && e.health > 0 && e.isCurrentlyVisible !== false && calculateDistance(primaryTarget.position, e.position) < range * 0.75)
                                            .sort((a, b) => calculateDistance(primaryTarget.position, a.position) - calculateDistance(primaryTarget.position, b.position))
                                            .slice(0, chainCount);

                                        validChainTargets.forEach(chainTarget => {
                                            w.chainTargetIds.push(chainTarget.id);
                                            const chainDecompilerBonus = decompilerBonuses[chainTarget.type] || 1.0;
                                            let chainFinalDamage = damage * DATA_LEECH_STATS.chainDamageMultiplier * chainDecompilerBonus * (chainTarget.vulnerabilityFactor || 1);
                                            if (chainTarget.type === EnemyType.SEGMENTO_FALHA && chainTarget.isShielded) { chainFinalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                            chainTarget.health -= chainFinalDamage;
                                            sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + chainFinalDamage;
                                        });
                                    }
                                }
                                w.lastTickTime = now;
                            }
                        }
                    });

                    draft.alliedMinions.forEach(minion => {
                        if (now - (minion.lastAttackTime || 0) > SUB_PROCESS_MINION_STATS.attackCooldown) {
                            for (const enemy of [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])]) {
                                if (enemy.health > 0) {
                                    const targetSize = enemy.bossType ? enemy.coreSize / 2 : enemy.size / 2;
                                    if (calculateDistance(minion.position, enemy.position) < minion.size / 2 + targetSize) {
                                        const decompilerBonus = decompilerBonuses[enemy.type] || 1.0;
                                        const baseMinionDamage = minion.damage * finalDamageMultiplier * decompilerBonus * (enemy.vulnerabilityFactor || 1);
                                        const finalDamage = applyCritDamage(baseMinionDamage, enemy);
                                        if (enemy.type === EnemyType.SEGMENTO_FALHA && enemy.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                        enemy.health -= finalDamage;
                                        sessionStatsRef.current.damageDealtByWeapon['class_technomancer'] = (sessionStatsRef.current.damageDealtByWeapon['class_technomancer'] || 0) + finalDamage;
                                        minion.lastAttackTime = now;
                                        SoundManager.play('enemyHit');
                                        break; 
                                    }
                                }
                            }
                        }

                        if (now - (minion.lastDamageTakenTime || 0) > SUB_PROCESS_MINION_STATS.damageTakenCooldown) {
                            for (const enemy of draft.enemies) {
                                if (enemy.health > 0) {
                                    if (calculateDistance(minion.position, enemy.position) < minion.size / 2 + enemy.size / 2) {
                                        minion.health -= enemy.damage;
                                        minion.lastDamageTakenTime = now;
                                        for(let k=0; k<3; ++k) draft.particles.push({ id: `p-minionhit-${minion.id}-${k}`, position: { ...minion.position }, velocity: { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }, size: Math.random()*2+1, color: minion.color, life: 30 });
                                        break; 
                                    }
                                }
                            }
                        }
                    });
                
                    const isAcidVirusEvolved = draft.player.weapons.some(w => w.id === 'acid_virus_pandemic');
                    const acidVirusWeapon = draft.player.weapons.find(w => w.id.includes('acid_virus'));
                    const acidWeaponBaseId = acidVirusWeapon ? (acidVirusWeapon.originalBaseWeaponId || 'acid_virus') : null;
                    
                    draft.acidPuddles.forEach(puddle => {
                        if (now > puddle.endTime) return;
                        if(now - puddle.lastTickTime > puddle.tickRate) {
                            [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => {
                                if(target.health <= 0) return;
                                const dist = calculateDistance(puddle.position, target.position);
                                if(dist < puddle.radius + target.size / 2) {
                                    const decompilerBonus = decompilerBonuses[target.type] || 1.0;
                                    let finalDamage = puddle.damagePerTick * decompilerBonus * (target.vulnerabilityFactor || 1);
                                    if (puddle.isCritical) {
                                        finalDamage *= draft.player.critDamage;
                                    }
                                    if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                    if (draft.boss && draft.boss.bossType === 'arbiter' && draft.boss.phase === 3) { finalDamage *= 2; }
                                    if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { finalDamage *= 1.25; }
                                    target.health -= finalDamage;
                                    if(acidWeaponBaseId) sessionStatsRef.current.damageDealtByWeapon[acidWeaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[acidWeaponBaseId] || 0) + finalDamage;

                                    if(isAcidVirusEvolved) {
                                        _applyStatusEffectToEntity(target, { type: StatusEffectType.VULNERABILITY, duration: 500, magnitude: 1.25, sourceId: 'acid_virus_pandemic' }, now);
                                    } else if (puddle.appliesSlow) {
                                        _applyStatusEffectToEntity(target, { type: StatusEffectType.SLOW, duration: 500, magnitude: 0.7, sourceId: 'acid_virus_viscosity' }, now);
                                    }
                                }
                            });
                            puddle.lastTickTime = now;
                        }
                    });
                    draft.acidPuddles = draft.acidPuddles.filter(p => now < p.endTime);
                    
                    draft.bossAttacks = draft.bossAttacks.filter(attack => now < (attack.creationTime + (attack.warningDuration || 0) + (attack.fireDuration || 0) + (attack.armDuration || 0) + (attack.duration || 0 + 300)));
                    
                    draft.bossAttacks.forEach(attack => {
                        if (attack.type === BossAttackType.LOGIC_BOMB && !attack.triggered && now > attack.creationTime + attack.armDuration) {
                            if(calculateDistance(draft.player.position, attack.position) < 40) {
                                attack.triggered = true;
                                attack.detonationTime = now;
                            }
                        }
                    });

                    draft.projectiles.forEach(p => { 
                        if (p.isSeeking && p.targetEnemyId) { 
                            const target = draft.enemies.find(e => e.id === p.targetEnemyId && e.health > 0 && e.isCurrentlyVisible !== false) || (draft.boss && draft.boss.id === p.targetEnemyId && draft.boss.health > 0 && !draft.boss.isInvulnerable ? draft.boss : null) || draft.bossShieldNodes.find(n => n.id === p.targetEnemyId && n.health > 0); 
                            if (target) { 
                                const dirToTarget = normalizeVector({ x: target.position.x - p.position.x, y: target.position.y - p.position.y }); 
                                const seekSpeed = p.baseSpeed || ACID_VIRUS_STATS.pandemicSporeSpeed; 
                                p.velocity.x = (p.velocity.x * (1 - ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce)) + (dirToTarget.x * seekSpeed * ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce); 
                                p.velocity.y = (p.velocity.y * (1 - ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce)) + (dirToTarget.y * seekSpeed * ANTIVIRUS_SCAN_STATS.hunterSwarmSeekForce); 
                                const currentSpeed = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.y * p.velocity.y); 
                                if (currentSpeed > 0) { 
                                    p.velocity.x = (p.velocity.x / currentSpeed) * seekSpeed; 
                                    p.velocity.y = (p.velocity.y / currentSpeed) * seekSpeed; 
                                } 
                            } else { 
                                p.isSeeking = false; 
                            } 
                        } 
                        p.position.x += p.velocity.x * deltaTime; 
                        p.position.y += p.velocity.y * deltaTime; 
                        p.lifetime -= deltaTime * 1000; 
                    });
                    draft.projectiles = draft.projectiles.filter(p => p.position.x > -p.size && p.position.x < CANVAS_WIDTH + p.size && p.position.y > -p.size && p.position.y < CANVAS_HEIGHT + p.size && p.lifetime > 0);
                    
                    draft.particles.forEach(p => { 
                        if (p.velocity) { p.position.x += p.velocity.x * deltaTime; p.position.y += p.velocity.y * deltaTime; } 
                        p.life -= deltaTime * 1000;
                    });
                    draft.particles = draft.particles.filter(p => p.life > 0);
                    
                    [...draft.expOrbs, ...draft.healthPickups, ...draft.knowledgeOrbs].forEach(orb => {
                        if (draft.player.xpMagnetRadius > 0) { 
                            const distSqToPlayer = calculateDistanceSq(orb.position, draft.player.position); 
                            if (distSqToPlayer < draft.player.xpMagnetRadius * draft.player.xpMagnetRadius) { 
                                const dirToPlayer = normalizeVector({ x: draft.player.position.x - orb.position.x, y: draft.player.position.y - orb.position.y }); 
                                const distToPlayer = Math.sqrt(distSqToPlayer);
                                const magnetSpeedFactor = Math.max(1, (draft.player.xpMagnetRadius - distToPlayer) / draft.player.xpMagnetRadius * 3); 
                                orb.position.x += dirToPlayer.x * (draft.player.speed + 50) * magnetSpeedFactor * deltaTime; 
                                orb.position.y += dirToPlayer.y * (draft.player.speed + 50) * magnetSpeedFactor * deltaTime; 
                            } 
                        } 
                    });
                    
                    const projectilesToRemove = new Set();
                    draft.projectiles.forEach(p => {
                        if (projectilesToRemove.has(p.id)) return;
                        const weaponBaseId = p.weaponBaseId || null;
                        const firewallMastery = weaponMasteryStats['firewall'];
                        const canBlockProjectiles = firewallMastery?.projectile_block && firewallMastery?.unlocked;

                        for (const particle of draft.particles) {
                            if (p.ownerId === draft.player.id && particle.destroysProjectiles && calculateDistance(p.position, particle.position) < particle.radius) {
                                    projectilesToRemove.add(p.id);
                                    break;
                            }
                        }
                        if (projectilesToRemove.has(p.id)) return;
                            if(p.ownerId !== draft.player.id && canBlockProjectiles) {
                            const firewallWeapon = draft.player.weapons.find(w => w.id === 'firewall' || w.id === 'firewall_aegis_shield');
                            if (firewallWeapon) {
                                const orbSize = firewallWeapon.id === 'firewall_aegis_shield' ? FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier : FIREWALL_STATS.orbSize;
                                for(let i = 0; i < firewallWeapon.orbs; i++) {
                                    const angle = firewallWeapon.currentAngle + (i * (2 * Math.PI / firewallWeapon.orbs));
                                    const orbPosition = { x: draft.player.position.x + Math.cos(angle) * (FIREWALL_STATS.radius * (weaponMasteryStats['firewall']?.radius_multiplier ? 1 + weaponMasteryStats['firewall'].radius_multiplier : 1)), y: draft.player.position.y + Math.sin(angle) * (FIREWALL_STATS.radius * (weaponMasteryStats['firewall']?.radius_multiplier ? 1 + weaponMasteryStats['firewall'].radius_multiplier : 1))};
                                    if(calculateDistance(p.position, orbPosition) < p.size/2 + orbSize/2) {
                                        projectilesToRemove.add(p.id);
                                        SoundManager.play('shieldBreak');
                                        break;
                                    }
                                }
                                if(projectilesToRemove.has(p.id)) return;
                            }
                        }
                        if (p.ownerId === draft.player.id) {
                            for (const e of [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])]) {
                                if (e.health <= 0 || p.hitEnemyIds?.includes(e.id) || (e.isCurrentlyVisible === false)) continue;
                                const targetSize = e.bossType ? (e.bossType === 'guardian' ? e.coreSize : (e.bossType === 'arbiter' ? e.size / 2 : e.size)) : (e.size || 0);
                                const projectileCollisionRadiusSq = (p.size / 2 + targetSize / 2) ** 2;
                                if (calculateDistanceSq(p.position, e.position) < projectileCollisionRadiusSq) {
                                    if (p.type === 'acid_virus_shot') {
                                        SoundManager.play('acidVirusImpact');
                                        const puddleRadius = ACID_VIRUS_STATS.puddleRadius * Math.pow(1.15, ownedUpgradesRef.current.get('acid_virus_spread') || 0);
                                        const puddleDuration = (ACID_VIRUS_STATS.puddleDuration + 1000 * (ownedUpgradesRef.current.get('acid_virus_duration') || 0)) * (p.masteryDurationMultiplier || 1);
                                        const acidVirusWeapon = draft.player.weapons.find(w => w.id.includes('acid_virus'));
                                        const acidWeaponBaseId = acidVirusWeapon ? (acidVirusWeapon.originalBaseWeaponId || 'acid_virus') : null;
                                        const acidMastery = weaponMasteryStats[acidWeaponBaseId];
                                        let masteryDotMultiplier = 1.0;
                                        if (acidMastery) {
                                            masteryDotMultiplier += acidMastery.dot_damage_multiplier || 0;
                                        }
                                        const damagePerTick = (ACID_VIRUS_STATS.puddleDamagePerTick + 3 * (ownedUpgradesRef.current.get('acid_virus_potency') || 0)) * finalDamageMultiplier * masteryDotMultiplier;
                                        const appliesSlow = (ownedUpgradesRef.current.get('acid_virus_viscosity') || 0) > 0;
                                        const isCriticalPuddle = Math.random() < draft.player.critChance;
                                        
                                        draft.acidPuddles.push({
                                            id: `puddle-${p.id}-${e.id}`, position: { ...e.position }, radius: puddleRadius,
                                            damagePerTick: damagePerTick, tickRate: ACID_VIRUS_STATS.puddleTickRate,
                                            lastTickTime: now, endTime: now + puddleDuration, ownerId: p.ownerId,
                                            isEvolved: p.isEvolved, appliesSlow: appliesSlow && !p.isEvolved,
                                            isCritical: isCriticalPuddle,
                                        });
                                        if (acidMastery?.armor_shred && e.statusEffects) {
                                                _applyStatusEffectToEntity(e, { type: StatusEffectType.VULNERABILITY, duration: 4000, magnitude: 1 + acidMastery.armor_shred, sourceId: 'acid_virus_mastery' }, now);
                                        }

                                        p.hitEnemyIds.push(e.id);
                                        if ((p.pierceCount || 0) <= 0) { projectilesToRemove.add(p.id); } else { p.pierceCount--; }
                                    } else if (p.type === 'acid_spore') {
                                        SoundManager.play('acidVirusImpact');
                                        const puddleRadius = ACID_VIRUS_STATS.puddleRadius * Math.pow(1.15, ownedUpgradesRef.current.get('acid_virus_spread') || 0);
                                        const puddleDuration = ACID_VIRUS_STATS.puddleDuration + 1000 * (ownedUpgradesRef.current.get('acid_virus_duration') || 0);
                                        const damagePerTick = (ACID_VIRUS_STATS.puddleDamagePerTick + 3 * (ownedUpgradesRef.current.get('acid_virus_potency') || 0)) * finalDamageMultiplier;
                                        const isCriticalPuddle = Math.random() < draft.player.critChance;

                                        draft.acidPuddles.push({
                                            id: `puddle-spore-${p.id}-${e.id}`, position: { ...e.position }, radius: puddleRadius,
                                            damagePerTick: damagePerTick, tickRate: ACID_VIRUS_STATS.puddleTickRate,
                                            lastTickTime: now, endTime: now + puddleDuration, ownerId: p.ownerId,
                                            isEvolved: true, appliesSlow: false, isCritical: isCriticalPuddle,
                                        });
                                        projectilesToRemove.add(p.id);
                                    } else { 
                                        const decompilerBonus = decompilerBonuses[e.type] || 1.0;
                                        let damageDealt = p.damage * decompilerBonus * (e.vulnerabilityFactor || 1);
                                        
                                        if (p.isFirstShotCrit && !draft.player.weapons.find(w => w.id === 'antivirus')?.hitTargetsThisShot?.has(e.id)) {
                                            damageDealt *= draft.player.critDamage;
                                            const avWeapon = draft.player.weapons.find(w => w.id === 'antivirus');
                                            if (avWeapon) {
                                                if (!avWeapon.hitTargetsThisShot) avWeapon.hitTargetsThisShot = new Set();
                                                avWeapon.hitTargetsThisShot.add(e.id);
                                            }
                                        } else {
                                            damageDealt = applyCritDamage(damageDealt, e);
                                        }
                                        
                                        if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && e.health === e.maxHealth) { damageDealt *= 1.25; }
                                        if (e.type === EnemyType.SEGMENTO_FALHA && e.isShielded) { damageDealt *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); }
                                        if (draft.boss && draft.boss.bossType === 'arbiter' && draft.boss.phase === 3) { damageDealt *= 2; }
                                        e.health -= damageDealt;
                                        if (weaponBaseId) sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] = (sessionStatsRef.current.damageDealtByWeapon[weaponBaseId] || 0) + damageDealt;
                                        SoundManager.play('enemyHit');
                                        if(p.appliesStatus && Math.random() < (p.appliesStatus.chance || 1)) { _applyStatusEffectToEntity(e, p.appliesStatus, now); if (p.appliesStatus.type === StatusEffectType.FREEZE) SoundManager.play('freezeSound'); }
                                        if(p.appliesDot && e.dotEffects) { e.dotEffects.push({ id: `dot-${p.appliesDot.sourceEvolutionId}-${e.id}-${now}`, sourceEvolutionId: p.appliesDot.sourceEvolutionId, damagePerTick: p.appliesDot.damagePerTick, ticksRemaining: Math.floor(p.appliesDot.duration / p.appliesDot.tickInterval), tickInterval: p.appliesDot.tickInterval, lastTickTime: now, }); }
                                        p.hitEnemyIds.push(e.id);
                                        let shouldProjectileBeRemoved = false;
                                        if (p.chainLightning && (!p.chainLightning.currentChainHits || p.chainLightning.currentChainHits < p.chainLightning.maxChains)) {
                                            const currentChainHits = p.chainLightning.currentChainHits || 0;
                                            const potentialChainTargets = draft.enemies.filter(nextE => nextE.health > 0 && nextE.id !== e.id && !(p.hitEnemyIdsChain || []).includes(nextE.id) && calculateDistance(e.position, nextE.position) < p.chainLightning.range).sort((a,b) => calculateDistance(e.position, a.position) - calculateDistance(e.position, b.position));
                                            
                                            if (potentialChainTargets.length > 0) {
                                                SoundManager.play('chainLightningSound');
                                                const nextTarget = potentialChainTargets[0];
                                                const dirToNextTarget = normalizeVector({ x: nextTarget.position.x - e.position.x, y: nextTarget.position.y - e.position.y });
                                                
                                                const nextChainHits = currentChainHits + 1;

                                                const newChainProjectile = {
                                                    ...p,
                                                    id: `proj-chain-${p.id}-${nextChainHits}-${now}-${Math.random()}`,
                                                    position: { ...e.position },
                                                    previousChainPosition: { ...e.position },
                                                    velocity: { x: dirToNextTarget.x * (p.baseSpeed || ANTIVIRUS_SCAN_STATS.projectileSpeed), y: dirToNextTarget.y * (p.baseSpeed || ANTIVIRUS_SCAN_STATS.projectileSpeed) },
                                                    damage: p.damage * Math.pow(p.chainLightning.damageMultiplierPerChain || 0.7, nextChainHits),
                                                    hitEnemyIds: [],
                                                    hitEnemyIdsChain: [...(p.hitEnemyIdsChain || []), e.id],
                                                    pierceCount: 0,
                                                    chainLightning: { ...p.chainLightning, currentChainHits: nextChainHits },
                                                    color: p.chainLightning.color || GAME_COLORS.PROJECTILE_CHAIN_LIGHTNING,
                                                    isSeeking: false,
                                                    appliesDot: null,
                                                };
                                                draft.projectiles.push(newChainProjectile);
                                            }
                                            shouldProjectileBeRemoved = true;
                                        } else {
                                            if ((p.pierceCount || 0) <= 0) shouldProjectileBeRemoved = true;
                                            else p.pierceCount--;
                                        }
                                        if (shouldProjectileBeRemoved) projectilesToRemove.add(p.id);
                                        for(let k=0; k<3; ++k) draft.particles.push({ id: `p-hit-${e.id}-${k}`, position: { ...p.position }, velocity: { x: (Math.random()-0.5)*50, y: (Math.random()-0.5)*50 }, size: Math.random()*2+1, color: e.color, life: 50 });
                                    }
                                    if (projectilesToRemove.has(p.id)) break; 
                                }
                            }
                        } else if (p.ownerId !== draft.player.id) {
                            if (p.type === 'latency_spike_shot') {
                                if (calculateDistance(p.position, draft.player.position) < p.size / 2 + draft.player.size / 2) {
                                    draft.particles.push({
                                        id: `slow-puddle-${now}`,
                                        type: 'slow_puddle',
                                        position: { ...draft.player.position },
                                        radius: 100,
                                        targetRadius: 100,
                                        life: 5000,
                                        initialLife: 5000,
                                        color: 'rgba(96, 165, 250, 0.4)'
                                    });
                                    projectilesToRemove.add(p.id);
                                }
                            } else if (!draft.player.overdriveActive && !draft.player.isDashing && calculateDistance(p.position, draft.player.position) < p.size / 2 + draft.player.size / 2) {
                                if (now - draft.player.lastHitTime > 500) {
                                    const damageTaken = (p.damage || 0) * (1 - finalPlayerDamageReduction);
                                    draft.player.health -= damageTaken;
                                    if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                    sessionStatsRef.current.damageTaken += damageTaken;
                                    if (isBossFightActive && draft.boss?.bossType && sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] !== undefined) {
                                        sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                    }
                                    draft.player.lastHitTime = now;
                                    SoundManager.play('playerHit');
                                    if (draft.player.health <= 0) {
                                        draft.player.health = 0;
                                        handleGameOverWithStats();
                                    }
                                }
                                projectilesToRemove.add(p.id);
                            }
                            if (draft.player.classId === 'class_technomancer' && draft.player.uniquePassiveData.commandMode === 'AEGIS') {
                                for(const minion of draft.alliedMinions) {
                                    if (calculateDistance(p.position, minion.position) < p.size / 2 + minion.size / 2) {
                                        minion.health -= p.damage;
                                        projectilesToRemove.add(p.id);
                                        break;
                                    }
                                }
                            }
                        }
                    });
                    if (projectilesToRemove.size > 0) {
                        draft.projectiles = draft.projectiles.filter(p => !projectilesToRemove.has(p.id));
                    }

                    if (!draft.player.overdriveActive && !draft.player.isDashing) {
                            if(draft.player.health <= 0 && draft.player.lastStandCharges > 0 && !draft.player.lastStandUsed) {
                            draft.player.lastStandUsed = true;
                            draft.player.health = draft.player.maxHealth * draft.player.lastStandHealthPercent;
                            draft.player.overdriveActive = true; 
                            let invulnDuration = 1000 + draft.player.lastStandCharges * 600;
                            if(draft.player.lastStandSpeedBoost) {
                                draft.player.temporaryBuffs.push({id: `laststand-speed-${now}`, type: TemporaryBuffType.MOVE_SPEED, magnitude: 2.0, endTime: now + invulnDuration, sourceId: "last_stand_speed"});
                            }
                            draft.player.overdriveEndTime = now + invulnDuration;
                            SoundManager.play('shieldActivate');
                        }
                        
                        draft.bossAttacks.forEach(attack => {
                            if (now - draft.player.lastHitTime < 250) return;

                            let damageDealt = false;
                            if (attack.type === BossAttackType.DATA_SMASHER && now > attack.creationTime + attack.warningDuration && !attack.hasDamaged) {
                                if(calculateDistance(draft.player.position, attack.targetPosition) < attack.radius) {
                                    draft.player.health -= attack.damage * (1 - finalPlayerDamageReduction);
                                    damageDealt = true;
                                    attack.hasDamaged = true;
                                }
                            }
                            else if (attack.type === BossAttackType.HOSTILE_TAKEOVER && now > attack.creationTime + attack.warningDuration) {
                                if(attack.isHorizontal) {
                                    if (Math.abs(draft.player.position.y - attack.line) < 15) damageDealt = true;
                                } else {
                                    if (Math.abs(draft.player.position.x - attack.line) < 15) damageDealt = true;
                                }
                                if(damageDealt) draft.player.health -= attack.damage * (1 - finalPlayerDamageReduction);
                            }
                            if(damageDealt) {
                                draft.player.lastHitTime = now; SoundManager.play('playerHit');
                                if(draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); }
                            }
                        });

                        draft.unstableSectors.forEach(sector => { if (now > sector.endTime - 500 && now < sector.endTime) { const playerRect = { x: draft.player.position.x - draft.player.size / 2, y: draft.player.position.y - draft.player.size / 2, width: draft.player.size, height: draft.player.size }; const sectorRect = { x: sector.x, y: sector.y, width: 40, height: 40 }; if (playerRect.x < sectorRect.x + sectorRect.width && playerRect.x + playerRect.width > sectorRect.x && playerRect.y < sectorRect.y + sectorRect.height && playerRect.y + playerRect.height > sectorRect.y) { if (now - draft.player.lastHitTime > 500) { const damageTaken = 5 * (1 - finalPlayerDamageReduction); draft.player.health -= damageTaken; if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken; sessionStatsRef.current.damageTaken += damageTaken; draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } } });
                        draft.enemies.forEach(e => { if(e.health <= 0) return; const isSpywareVisible = e.type === EnemyType.SPYWARE ? e.isCurrentlyVisible : true; const collisionRadius = e.size/2 + draft.player.size/2;
                            if (isSpywareVisible && calculateDistanceSq(e.position, draft.player.position) < collisionRadius * collisionRadius) { if (now - draft.player.lastHitTime > 500) {
                            let damageTaken = e.damage * (1 - finalPlayerDamageReduction);
                            draft.player.health -= damageTaken;
                            if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                            sessionStatsRef.current.damageTaken += damageTaken;
                            if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                            draft.player.lastHitTime = now; 
                            SoundManager.play('playerHit');
                            if (draft.player.activeUniquePassiveIds.includes("passive_sentinel_retaliation")) {
                                const hasRetaliationBuff = draft.player.temporaryBuffs.some(b => b.type === TemporaryBuffType.DAMAGE_REDUCTION && b.sourceId === "passive_sentinel_retaliation");
                                if(!hasRetaliationBuff) {
                                    draft.player.temporaryBuffs.push({id: `retaliation-${now}`, type: TemporaryBuffType.DAMAGE_REDUCTION, magnitude: 0.85, endTime: now + 3000, sourceId: "passive_sentinel_retaliation"});
                                }
                            }
                            if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } const fearProtocolLevel = ownedUpgradesRef.current.get('passive_fear_protocol') || 0; if (fearProtocolLevel > 0 && Math.random() < (0.15 + fearProtocolLevel * 0.05)) { const fearEffect = { type: StatusEffectType.FEAR, duration: STATUS_EFFECT_PARAMS[StatusEffectType.FEAR].baseDuration + (fearProtocolLevel-1)*250, sourceId: 'passive_fear_protocol' }; _applyStatusEffectToEntity(e, fearEffect, now); draft.enemies.forEach(otherE => { if(otherE.id !== e.id && calculateDistance(draft.player.position, otherE.position) < 100) { _applyStatusEffectToEntity(otherE, fearEffect, now); } }); draft.particles.push({ id: `fear-burst-${now}`, position: {...draft.player.position}, radius:0, targetRadius: 100, color: GAME_COLORS.STATUS_FEAR_AURA, life: 300, initialLife: 300, type: 'fear_aura_burst' }); } } } if (e.type === EnemyType.MEMORY_LEAK && e.trail) { e.trail.forEach(segment => { if (calculateDistance(segment, draft.player.position) < ENEMY_MEMORY_LEAK_STATS.trailSize / 2 + draft.player.size / 2) { if (now - draft.player.lastHitTime > 500) {
                            let damageTaken = ENEMY_MEMORY_LEAK_STATS.trailDamage * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                            draft.player.health -= damageTaken; 
                            if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                            sessionStatsRef.current.damageTaken += damageTaken;
                            if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                            draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } }); } });
                        if (draft.boss) {
                            if (calculateDistance(draft.boss.position, draft.player.position) < (draft.boss.bossType === 'guardian' ? draft.boss.size : (draft.boss.bossType === 'arbiter' ? draft.boss.size/2 : draft.boss.size)) / 2 + draft.player.size / 2) { if (now - draft.player.lastHitTime > 500) {
                                let damageTaken = (draft.boss.damage) * (1 - finalPlayerDamageReduction);
                                draft.player.health -= damageTaken; 
                                if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                sessionStatsRef.current.damageTaken += damageTaken;
                                if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } }
                            draft.particles.forEach(particle => { if (particle.type === 'boss_pulse' && particle.radius && particle.life > 200 ) { if(calculateDistance(draft.player.position, particle.position) < particle.radius + draft.player.size/2) { if (now - draft.player.lastHitTime > 500) {
                                let damageTaken = (particle.damage || BOSS_STATS.projectilePhase1Damage) * (1 - (finalPlayerDamageReduction + (draft.player.dotDamageReduction || 0)));
                                draft.player.health -= damageTaken; 
                                if (draft.gameTime < 300) sessionStatsRef.current.damageTakenInFirst5Minutes += damageTaken;
                                sessionStatsRef.current.damageTaken += damageTaken;
                                if (isBossFightActive) sessionStatsRef.current.damageTakenDuringBoss[draft.boss.bossType] += damageTaken;
                                draft.player.lastHitTime = now; SoundManager.play('playerHit'); if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } } else if (particle.type === 'volatile_explosion' && particle.radius) { if(calculateDistance(draft.player.position, particle.position) < particle.radius + draft.player.size/2) { if (now - (particle.lastHitTime || 0) > 500) { let damageTaken = (particle.damage || 0) * (1-finalPlayerDamageReduction); draft.player.health -= damageTaken; SoundManager.play('playerHit'); particle.lastHitTime = now; if (draft.player.health <= 0) { draft.player.health = 0; handleGameOverWithStats(); } } } } });
                        }
                    }
                    
                    const firewallWeapon = draft.player.weapons.find(w => w.id === 'firewall' || w.id === 'firewall_aegis_shield'); if (firewallWeapon && firewallWeapon.orbs && firewallWeapon.currentAngle !== undefined) { if (!firewallWeapon.orbHitCooldowns) firewallWeapon.orbHitCooldowns = {}; let baseFirewallDamage = FIREWALL_STATS.damage + 8 * (ownedUpgradesRef.current.get('firewall_damage') || 0); if (firewallWeapon.id === 'firewall_aegis_shield') baseFirewallDamage += FIREWALL_STATS.aegisContactDamageBonus; baseFirewallDamage *= finalDamageMultiplier; let firewallAppliesStatus = null; const vulnerabilityMatrixLevel = ownedUpgradesRef.current.get('firewall_vulnerability_matrix') || 0; if (vulnerabilityMatrixLevel > 0) { firewallAppliesStatus = { type: StatusEffectType.VULNERABILITY, duration: STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseDuration, magnitude: STATUS_EFFECT_PARAMS[StatusEffectType.VULNERABILITY].baseMagnitude + (vulnerabilityMatrixLevel -1) * 0.05, sourceId: 'firewall_vulnerability_matrix' }; } for (let i = 0; i < firewallWeapon.orbs; i++) { const angle = firewallWeapon.currentAngle + (i * (2 * Math.PI / firewallWeapon.orbs)); const orbPosition = { x: draft.player.position.x + Math.cos(angle) * FIREWALL_STATS.radius, y: draft.player.position.y + Math.sin(angle) * FIREWALL_STATS.radius }; const orbSize = firewallWeapon.id === 'firewall_aegis_shield' ? FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier : FIREWALL_STATS.orbSize; [...draft.enemies, ...draft.bossShieldNodes, ...(draft.boss && !draft.boss.isInvulnerable ? [draft.boss] : [])].forEach(target => { if (target.health <= 0 || target.isCurrentlyVisible === false) return; const targetSize = target.bossType ? (target.bossType === 'guardian' ? target.coreSize/2 : target.size/2) : target.size/2; if (calculateDistance(orbPosition, target.position) < orbSize/2 + targetSize) { if (now - (firewallWeapon.orbHitCooldowns[`enemy-${target.id}-orb-${i}`] || 0) > FIREWALL_STATS.hitCooldown) { const decompilerBonus = decompilerBonuses[target.type] || 1.0; let damageToTarget = baseFirewallDamage * decompilerBonus * (target.vulnerabilityFactor || 1); let finalDamage = applyCritDamage(damageToTarget, target); if (draft.player.activeUniquePassiveIds.includes('passive_executor_first_strike') && target.health === target.maxHealth) { finalDamage *= 1.25; } if (target.type === EnemyType.SEGMENTO_FALHA && target.isShielded) { finalDamage *= (1 - ENEMY_SEGMENTO_FALHA_STATS.shieldDamageReduction); } target.health -= finalDamage; firewallWeapon.orbHitCooldowns[`enemy-${target.id}-orb-${i}`] = now; SoundManager.play('enemyHit'); sessionStatsRef.current.damageDealtByWeapon['firewall'] = (sessionStatsRef.current.damageDealtByWeapon['firewall'] || 0) + finalDamage; if (firewallAppliesStatus) _applyStatusEffectToEntity(target, firewallAppliesStatus, now); for(let k=0; k<2; ++k) draft.particles.push({ id: `p-fwhit-${target.id}-${k}`, position: { ...orbPosition }, velocity: { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }, size: Math.random()*1.5+1, color: GAME_COLORS.FIREWALL_ORB, life: 30 }); } } }); } }

                    draft.ramSockets.forEach(socket => { 
                        if(socket.isCorrupted) {
                            const dist = calculateDistance(draft.player.position, socket.position);
                            if (dist < RAM_SOCKET_STATS.size/2 + draft.player.size/2) { 
                                socket.cleanseProgress += (1 / RAM_SOCKET_STATS.cleanseTime) * (deltaTime * 1000);
                                if (socket.cleanseProgress >= 1) { 
                                    socket.isCorrupted = false; socket.cleanseProgress = 0; SoundManager.play('cleanseComplete');
                                    if(draft.boss && !draft.ramSockets.some(s => s.isCorrupted)) {
                                        draft.boss.vulnerableEndTime = now + BOSS_3_STATS.vulnerabilityDuration; 
                                        draft.enemies = []; SoundManager.play('bossPhaseChange');
                                    }
                                }
                            } else {
                                    socket.cleanseProgress = Math.max(0, socket.cleanseProgress - 0.5 * (deltaTime * 1000) / RAM_SOCKET_STATS.cleanseTime);
                            }
                        }
                    });

                    const expOrbsToRemove = new Set();
                    draft.expOrbs.forEach(orb => { const collectionRadius = orb.size/2 + draft.player.size/2;
                        if (calculateDistanceSq(orb.position, draft.player.position) < collectionRadius * collectionRadius) {
                            const healAmount = (draft.player.regenAmount > 0) ? draft.player.maxHealth * (0.001 * (permanentBuffs.shop?.corr_hp_multiplier || 1)) : 0;
                            if(healAmount > 0) draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + healAmount);
                            draft.experience += Math.floor(orb.value * draft.player.expModifier);
                            sessionStatsRef.current.totalXpOrbsCollected++;
                            expOrbsToRemove.add(orb.id);
                            SoundManager.play('pickupXP');
                        } 
                    });
                    if (expOrbsToRemove.size > 0) {
                        draft.expOrbs = draft.expOrbs.filter(orb => !expOrbsToRemove.has(orb.id));
                    }
                    
                    const healthPickupsToRemove = new Set();
                    draft.healthPickups.forEach(pickup => { 
                        if (calculateDistance(pickup.position, draft.player.position) < pickup.size/2 + draft.player.size/2) { 
                            draft.player.health = Math.min(draft.player.maxHealth, draft.player.health + pickup.healAmount); 
                            healthPickupsToRemove.add(pickup.id); 
                            sessionStatsRef.current.healthPickupsCollected++;
                            SoundManager.play('pickupHealth');
                        } 
                    });
                    if(healthPickupsToRemove.size > 0) {
                        draft.healthPickups = draft.healthPickups.filter(p => !healthPickupsToRemove.has(p.id));
                    }

                    const knowledgeOrbsToRemove = new Set();
                    draft.knowledgeOrbs.forEach(orb => {
                        if (calculateDistance(orb.position, draft.player.position) < orb.size/2 + draft.player.size/2) {
                            draft.level++;
                            draft.experience = 0;
                            draft.expToNextLevel = Math.floor(draft.expToNextLevel * EXP_LEVEL_MULTIPLIER);
                            onLevelUpCallback();
                            SoundManager.play('levelUp');
                            knowledgeOrbsToRemove.add(orb.id);
                        }
                    });
                    if(knowledgeOrbsToRemove.size > 0) {
                        draft.knowledgeOrbs = draft.knowledgeOrbs.filter(orb => !knowledgeOrbsToRemove.has(orb.id));
                    }

                    const deadEnemies = draft.enemies.filter(e => e.health <= 0);
                    const newEnemiesFromDeath = [];
                    if (deadEnemies.length > 0) {
                        deadEnemies.forEach(dead => {
                            sessionStatsRef.current.kills[dead.type]++;
                            sessionStatsRef.current.totalKills++;
                            if (draft.player.hasInfiniteFury) {
                                sessionStatsRef.current.furyKillCounter = (sessionStatsRef.current.furyKillCounter || 0) + 1;
                                if (sessionStatsRef.current.furyKillCounter >= 150) {
                                    draft.player.furyStacks = (draft.player.furyStacks || 0) + 1;
                                    sessionStatsRef.current.furyKillCounter = 0;
                                }
                            }

                            const isBuffedByDataCache = draft.player.temporaryBuffs.some(b => b.icon);
                            if (isBuffedByDataCache) {
                                sessionStatsRef.current.killsWhileBuffedInSession++;
                            }
                            
                            if (draft.eventActive === 'DATA_VAULT') {
                                draft.eventKillsSoFar++;
                            }

                            const decompilerStats = JSON.parse(localStorage.getItem(DECOMPILER_STATS_KEY) || '{}');
                            decompilerStats[dead.type] = (decompilerStats[dead.type] || 0) + 1;
                            localStorage.setItem(DECOMPILER_STATS_KEY, JSON.stringify(decompilerStats));
                            
                            let xpValue = dead.expValue;
                            if (draft.player.activeUniquePassiveIds.includes('passive_corruptor_data_extraction')) {
                                const puddleEnemyWasIn = draft.acidPuddles.find(puddle => calculateDistance(dead.position, puddle.position) < puddle.radius);
                                if(puddleEnemyWasIn) {
                                    xpValue *= 1.10;
                                }
                            }

                            let shouldDropLoot = true;
                            if (dead.type === EnemyType.PROCESSO_ZUMBI && !dead.hasRevived && Math.random() < ENEMY_PROCESSO_ZUMBI_STATS.reviveChance) {
                                draft.revivingProcesses.push({ position: { ...dead.position }, reviveAt: now + ENEMY_PROCESSO_ZUMBI_STATS.reviveTime, maxHealth: dead.maxHealth });
                                shouldDropLoot = false;
                            } else if (draft.player.classId === 'class_technomancer' && dead.isConvertible && draft.alliedMinions.length < SUB_PROCESS_MINION_STATS.maxMinions && Math.random() < SUB_PROCESS_MINION_STATS.conversionChance) {
                                SoundManager.play('minionConvert');
                                const minionHealth = SUB_PROCESS_MINION_STATS.baseHealth + (draft.level * SUB_PROCESS_MINION_STATS.healthPerLevel);
                                const minionDamage = SUB_PROCESS_MINION_STATS.baseDamage + (draft.level * SUB_PROCESS_MINION_STATS.damagePerLevel);
                                draft.alliedMinions.push({
                                    id: `ally-${dead.id}`, position: {...dead.position}, size: SUB_PROCESS_MINION_STATS.size, speed: SUB_PROCESS_MINION_STATS.speed,
                                    health: minionHealth, maxHealth: minionHealth, damage: minionDamage, color: GAME_COLORS.ALLIED_MINION,
                                    targetId: null, angle: 0
                                });
                                for (let i=0; i<10; i++) draft.particles.push({ id: `p-convert-${dead.id}-${i}`, position: { ...dead.position }, velocity: { x: (Math.random()-0.5)*80, y: (Math.random()-0.5)*80 }, size: Math.random()*2+1, color: GAME_COLORS.ALLIED_MINION, life: 60 });
                                shouldDropLoot = false;
                            } else { 
                                const dataLeechWeapon = draft.player.weapons.find(w => w.id === 'data_leech' || w.id === 'leech_siphon_chain');
                                let wasAffectedByLeech = false;
                                if (dataLeechWeapon && (dataLeechWeapon.targetId === dead.id || (dataLeechWeapon.chainTargetIds && dataLeechWeapon.chainTargetIds.includes(dead.id)))) {
                                    wasAffectedByLeech = true;
                                }

                                if (draft.player.activeUniquePassiveIds.includes('passive_reaper_process_siphon') && wasAffectedByLeech && Math.random() < 0.15) {
                                    draft.healthPickups.push({ id: `hp-reaper-${dead.id}`, position: {...dead.position}, size: HEALTH_PICKUP_STATS.size * 0.6, healAmount: 5, color: GAME_COLORS.HEALTH_PICKUP });
                                }
                                
                                if (dataLeechWeapon && dataLeechWeapon.id === 'leech_siphon_chain' && wasAffectedByLeech && Math.random() < 0.25) {
                                    draft.healthPickups.push({ id: `hp-siphon-${dead.id}`, position: {...dead.position}, size: HEALTH_PICKUP_STATS.size * 0.4, healAmount: 5, color: GAME_COLORS.HEALTH_PICKUP });
                                }
                            }
                            
                            if(isAcidVirusEvolved) {
                                const puddleEnemyWasIn = draft.acidPuddles.find(puddle => calculateDistance(dead.position, puddle.position) < puddle.radius);
                                if(puddleEnemyWasIn && Math.random() < ACID_VIRUS_STATS.pandemicSporeChance) {
                                    SoundManager.play('acidSporeLaunch');
                                    let closestTarget = null, minDistance = Infinity;
                                    draft.enemies.forEach(e => {
                                        if(e.id !== dead.id && e.health > 0) {
                                            const dist = calculateDistance(dead.position, e.position);
                                            if (dist < minDistance) { minDistance = dist; closestTarget = e; }
                                        }
                                    });
                                    if(closestTarget) {
                                        const direction = normalizeVector({ x: closestTarget.position.x - dead.position.x, y: closestTarget.position.y - dead.position.y });
                                        draft.projectiles.push({
                                            id: `spore-${dead.id}`, position: { ...dead.position },
                                            velocity: { x: direction.x * ACID_VIRUS_STATS.pandemicSporeSpeed, y: direction.y * ACID_VIRUS_STATS.pandemicSporeSpeed },
                                            baseSpeed: ACID_VIRUS_STATS.pandemicSporeSpeed,
                                            size: ACID_VIRUS_STATS.pandemicSporeSize,
                                            color: GAME_COLORS.PROJECTILE_ACID_SPORE, ownerId: draft.player.id,
                                            type: 'acid_spore', isSeeking: true, targetEnemyId: closestTarget.id, lifetime: 5000, hitEnemyIds:[], weaponBaseId: 'acid_virus'
                                        });
                                    }
                                }
                            }

                            if (shouldDropLoot) { 
                                SoundManager.play('enemyDie'); 
                                draft.score += 10; 
                                draft.expOrbs.push({ id: `xp-${dead.id}`, position: { ...dead.position }, size: 10, value: xpValue, color: GAME_COLORS.XP_ORB }); 
                                for (let i=0; i<10; i++) draft.particles.push({ id: `p-death-${dead.id}-${i}`, position: { ...dead.position }, velocity: { x: (Math.random()-0.5)*100, y: (Math.random()-0.5)*100 }, size: Math.random()*3+1, color: dead.color, life: Math.random() * 50 + 50 }); 
                            }
                            if (dead.type === EnemyType.TROJAN_HORSE) {
                                for (let i = 0; i < ENEMY_TROJAN_HORSE_STATS.fragmentsToSpawn; i++) {
                                    newEnemiesFromDeath.push({
                                        id: `enemy-frag-${dead.id}-${i}`,
                                        type: ENEMY_MALWARE_FRAGMENT_STATS.type,
                                        position: { x: dead.position.x + (Math.random() - 0.5) * 20, y: dead.position.y + (Math.random() - 0.5) * 20 },
                                        size: ENEMY_MALWARE_FRAGMENT_STATS.size,
                                        baseSpeed: ENEMY_MALWARE_FRAGMENT_STATS.baseSpeed,
                                        speed: ENEMY_MALWARE_FRAGMENT_STATS.baseSpeed * (1 + Math.floor(draft.gameTime / 60) * 0.12),
                                        color: ENEMY_MALWARE_FRAGMENT_STATS.color,
                                        health: ENEMY_MALWARE_FRAGMENT_STATS.health * (1 + Math.floor(draft.gameTime / 60) * 0.18),
                                        damage: ENEMY_MALWARE_FRAGMENT_STATS.damage * (1 + Math.floor(draft.gameTime / 60) * 0.12),
                                        expValue: ENEMY_MALWARE_FRAGMENT_STATS.expValue,
                                        isVisible: true,
                                        dotEffects: [],
                                        statusEffects: [],
                                        isConvertible: ENEMY_MALWARE_FRAGMENT_STATS.isConvertible
                                    });
                                }
                            }
                            if (dead.type === EnemyType.RECURSIVE_PROCESS) {
                                SoundManager.play('minionSpawn');
                                for (let i = 0; i < 2; i++) {
                                    newEnemiesFromDeath.push({ id: `enemy-child-${dead.id}-${i}`, type: ENEMY_CHILD_PROCESS_STATS.type, position: { x: dead.position.x + (Math.random() - 0.5) * 20, y: dead.position.y + (Math.random() - 0.5) * 20 }, size: ENEMY_CHILD_PROCESS_STATS.size, baseSpeed: ENEMY_CHILD_PROCESS_STATS.baseSpeed, speed: ENEMY_CHILD_PROCESS_STATS.baseSpeed, color: ENEMY_CHILD_PROCESS_STATS.color, health: ENEMY_CHILD_PROCESS_STATS.health, damage: ENEMY_CHILD_PROCESS_STATS.damage, expValue: ENEMY_CHILD_PROCESS_STATS.expValue, isVisible: true, dotEffects: [], statusEffects: [], isConvertible: false });
                                }
                                shouldDropLoot = false;
                            }
                                if(draft.player.activeUniquePassiveIds.includes('passive_assassin_execution_flow')) {
                                const existingBuffIndex = draft.player.temporaryBuffs.findIndex(b => b.sourceId === 'passive_assassin_execution_flow');
                                if(existingBuffIndex !== -1) {
                                    draft.player.temporaryBuffs[existingBuffIndex].endTime = now + 2000;
                                    const attackSpeedBuffIndex = draft.player.temporaryBuffs.findIndex(b => b.sourceId === 'passive_assassin_execution_flow' && b.type === TemporaryBuffType.ATTACK_SPEED);
                                    if(attackSpeedBuffIndex !== -1) draft.player.temporaryBuffs[attackSpeedBuffIndex].endTime = now + 2000;
                                } else {
                                    draft.player.temporaryBuffs.push({id: `assassin-flow-mv-${now}`, type: TemporaryBuffType.MOVE_SPEED, magnitude: 1.20, endTime: now + 2000, sourceId: 'passive_assassin_execution_flow', icon: 'üèÉ' });
                                    draft.player.temporaryBuffs.push({id: `assassin-flow-as-${now}`, type: TemporaryBuffType.ATTACK_SPEED, magnitude: 0.85, endTime: now + 2000, sourceId: 'passive_assassin_execution_flow', icon: '‚ö°' });
                                }
                            }
                        });
                        draft.enemies = draft.enemies.filter(e => e.health > 0).concat(newEnemiesFromDeath);
                    }
                    draft.alliedMinions = draft.alliedMinions.filter(m => m.health > 0);

                    if (draft.eventActive === 'DATA_VAULT' && draft.eventKillsSoFar >= draft.eventKillCounter) {
                        draft.eventActive = null;
                        const vaultPos = { ...draft.dataVault.position };
                        draft.dataVault = null; 
                        
                        for (let i=0; i<3; ++i) {
                            draft.knowledgeOrbs.push({
                                id: `k-orb-${now}-${i}`,
                                position: { x: vaultPos.x + (Math.random() - 0.5) * 50, y: vaultPos.y + (Math.random() - 0.5) * 50 },
                                size: 25,
                            });
                        }
                        SoundManager.play('eventSuccess');
                    }

                    if (draft.experience >= draft.expToNextLevel) { 
                        draft.level++; 
                        draft.experience -= draft.expToNextLevel; 
                        draft.expToNextLevel = Math.floor(draft.expToNextLevel * EXP_LEVEL_MULTIPLIER * gameModifiers.expToNextLevelMultiplier); 
                        onLevelUpCallback(); 
                        SoundManager.play('levelUp'); 
                    }
                });
            } catch (e) {
                console.error("Erro cr√≠tico no gameTick:", e);
                if (engineRef && engineRef.current) {
                    engineRef.current.pauseGame();
                }
            }
        }, [isGameActive, onLevelUpCallback, onBossWarningStartCallback, onBossFightStartCallback, onStageClearCallback, _applyStatusEffectToEntity, handleGameOverWithStats, decompilerBonuses, weaponMasteryStats, setGameState ]);
        //fim gametick

    const handleKeyDown = useGameEngineCallback((key) => {
        if (gameState.isPaused && key.toLowerCase() !== 'p') return;
        setGameState(draft => { draft.keys[key.toLowerCase()] = true; });
    }, [gameState.isPaused, setGameState]);

    const handleKeyUp = useGameEngineCallback((key) => {
        setGameState(draft => { draft.keys[key.toLowerCase()] = false; });
    }, [setGameState]);
    
    const pauseGame = useAppCallback(() => {
        setGameState(draft => {
            draft.isPaused = true;
            draft.keys = { w: false, a: false, s: false, d: false, ' ': false };
        });
    }, [setGameState]);

    const resumeGame = useAppCallback(() => {
        setGameState(draft => {
            const now = Date.now();
            let updatedBoss = draft.boss;
            if(updatedBoss){
                if(updatedBoss.bossType === 'guardian'){
                    updatedBoss.lastPhase1AttackTime= Math.max(updatedBoss.lastPhase1AttackTime, now - BOSS_STATS.projectilePhase1FireRate + 1000); 
                    updatedBoss.lastPhase2AttackTime= Math.max(updatedBoss.lastPhase2AttackTime, now - BOSS_STATS.projectilePhase2FireRate + 1000); 
                    updatedBoss.lastPulseAttackTime= Math.max(updatedBoss.lastPulseAttackTime, now - BOSS_STATS.pulseAttackCooldown + 1000); 
                    updatedBoss.lastCorruptedZoneTime= Math.max(updatedBoss.lastCorruptedZoneTime, now - BOSS_STATS.corruptedZoneInterval + 1000); 
                    updatedBoss.lastGlitchMinionSpawnTime= Math.max(updatedBoss.lastGlitchMinionSpawnTime, now - BOSS_STATS.glitchMinionSpawnInterval + 1000); 
                    updatedBoss.lastDataStreamAttackTime= Math.max(updatedBoss.lastDataStreamAttackTime, now - BOSS_STATS.dataStreamBarrageInterval + 1000);
                    if (updatedBoss.kernelPanicChargeStartTime > 0) { 
                        updatedBoss.kernelPanicChargeStartTime = now - (BOSS_STATS.kernelPanicPulseChargeTime - (updatedBoss.lastKernelPanicPulseTime - updatedBoss.kernelPanicChargeStartTime)); 
                    } else { 
                        updatedBoss.lastKernelPanicPulseTime= Math.max(updatedBoss.lastKernelPanicPulseTime, now - BOSS_STATS.kernelPanicPulseCooldown + 1000); 
                    }
                } else if (updatedBoss.bossType === 'sincronizador') {
                    updatedBoss.lastEnergyWaveTime = Math.max(updatedBoss.lastEnergyWaveTime, now - BOSS_2_STATS.phase1EnergyWaveInterval + 1000);
                    updatedBoss.lastLaserTime = Math.max(updatedBoss.lastLaserTime, now - BOSS_2_STATS.laserCooldown + 1000);
                    updatedBoss.lastDataWallTime = Math.max(updatedBoss.lastDataWallTime, now - BOSS_2_STATS.dataWallSpawnInterval + 1000);
                }
            }
            draft.isPaused = false;
            draft.nextEnemySpawnTime = Math.max(draft.nextEnemySpawnTime, now + 500);
            draft.nextHealthPickupSpawnTime = Math.max(draft.nextHealthPickupSpawnTime, now + 2000);
        });
    }, [setGameState]);
    
    const applyUpgrade = useAppCallback((upgrade) => {
        setGameState(draft => {
            upgrade.apply(draft.player, draft.player.weapons);
            if (upgrade.type !== 'weapon_evolution') {
                ownedUpgradesRef.current.set(upgrade.id, (ownedUpgradesRef.current.get(upgrade.id) || 0) + 1);
            }
            if (upgrade.type === 'weapon_new') {
                sessionStatsRef.current.weaponsAcquiredCount++;
                const weaponId = upgrade.id.split('_')[1];
                const weapon = draft.player.weapons.find(w => w.id === weaponId);
                if (weapon && !weapon.level) weapon.level = 1;
                if (weapon && weapon.id === 'firewall' && !weapon.orbHitCooldowns) weapon.orbHitCooldowns = {};
            }
        });
    }, [setGameState]);

    const getUpgradeOptions = useAppCallback(() => {
        const currentOwnedUpgrades = ownedUpgradesRef.current;
        const currentPlayerWeapons = gameState.player.weapons;
        const selectedClassDef = CLASS_DEFINITIONS.find(c => c.id === (gameState.player).classId) || CLASS_DEFINITIONS[0];

        const evolutionOptions = [];
        WEAPON_EVOLUTIONS.forEach(evoRecipe => {
            if (currentPlayerWeapons.find(w => w.id === evoRecipe.evolvedWeaponProperties.newId)) return;
            const baseWeaponInstance = currentPlayerWeapons.find(w => w.id === evoRecipe.baseWeaponId || w.originalBaseWeaponId === evoRecipe.baseWeaponId);
            if (!baseWeaponInstance || baseWeaponInstance.isEvolved) return;
            const catalystOwned = (currentOwnedUpgrades.get(evoRecipe.catalystPassiveId) || 0) > 0;
            if (!catalystOwned) return;
            const requiredUpgradesMet = evoRecipe.requiredUpgradeIds.every(req => (currentOwnedUpgrades.get(req.id) || 0) >= req.level);
            if (!requiredUpgradesMet) return;

            evolutionOptions.push({
                id: evoRecipe.evolutionId,
                title: `Evoluir: ${evoRecipe.name}`,
                description: evoRecipe.description,
                level: 0,
                maxLevel: 1,
                type: 'weapon_evolution',
                evolvesWeaponId: baseWeaponInstance.id,
                apply: (player, weapons) => {
                    const weaponToEvolve = weapons.find(w => w.id === baseWeaponInstance.id && !w.isEvolved);
                    if (weaponToEvolve) {
                        weaponToEvolve.originalBaseWeaponId = weaponToEvolve.originalBaseWeaponId || evoRecipe.baseWeaponId;
                        weaponToEvolve.id = evoRecipe.evolvedWeaponProperties.newId;
                        weaponToEvolve.isEvolved = true;
                        weaponToEvolve.evolutionId = evoRecipe.evolutionId;
                    }
                }
            });
        });

        const standardUpgradePool = UPGRADE_POOL.filter(u => {
            const currentLevel = currentOwnedUpgrades.get(u.id) || 0;
            if (currentLevel >= u.maxLevel) return false;
            if (u.requires && (currentOwnedUpgrades.get(u.requires) || 0) === 0) return false;
            if (u.type === 'weapon_new') {
                const weaponBaseId = u.id.split('_')[1];
                if (currentPlayerWeapons.find(w => w.id === weaponBaseId || w.originalBaseWeaponId === weaponBaseId)) return false;
                if (selectedClassDef.startingWeaponId === weaponBaseId && gameState.level <= 1 && currentOwnedUpgrades.get(u.id) === 1) return false;
            }
            if (u.type === 'weapon_upgrade' && u.requires) {
                const requiredWeaponBaseId = u.requires.split('_')[1];
                const weaponInstance = currentPlayerWeapons.find(w => w.id === requiredWeaponBaseId || w.originalBaseWeaponId === requiredWeaponBaseId);
                if (weaponInstance && weaponInstance.isEvolved) return false;
            }
            return true;
        });
        
        const choices = [...evolutionOptions];
        const shuffledStandard = [...standardUpgradePool].sort(() => 0.5 - Math.random());
        let numOptions = 4 + (gameState.player.extraUpgradeChoices || 0);
        for (let i = 0; choices.length < numOptions && i < shuffledStandard.length; i++) {
            if (!choices.find(c => c.id === shuffledStandard[i].id)) {
                choices.push({...shuffledStandard[i], currentLevelDisplay: currentOwnedUpgrades.get(shuffledStandard[i].id) || 0});
            }
        }
        return choices.slice(0, numOptions);
    }, [ownedUpgradesRef, gameState.player, gameState.level]);
    
    useAppEffect(() => {
        let timerId;
        if (isGameActive && !gameState.isPaused && (gameState.boss === null || gameState.isInfiniteMode)) {
            timerId = window.setInterval(() => setGameState(draft => { draft.gameTime += 1 }), 1000);
        }
        return () => { if(timerId) clearInterval(timerId); };
    }, [isGameActive, gameState.isPaused, gameState.boss, gameState.isInfiniteMode, setGameState]);

    const enterInfiniteMode = useAppCallback(() => {
        setGameState(draft => {
            if (sessionStatsRef.current) {
                sessionStatsRef.current.reachedInfiniteMode = true;
            }
            draft.isInfiniteMode = true;
            draft.isPaused = false;
        });
    }, [setGameState]);

    return {
        gameState, gameTick, resetGame, handleKeyDown, handleKeyUp,
        pauseGame, resumeGame, getUpgradeOptions, applyUpgrade,
        spawnBoss, spawnBoss2, spawnBoss3, spawnBoss4, startNextStage, ownedUpgradesRef,
        sessionStatsRef,
        enterInfiniteMode
    };
};
// --- END OF hooks/useGameEngine.ts ---
        
        // --- START OF NEW/UPDATED UI COMPONENTS ---

        const LeftSidebar = ({ gameState }) => {
            if (!gameState || !gameState.player) return null;

            const { player, experience, expToNextLevel, alliedMinions } = gameState;
            const playerMaxHealth = Math.ceil(player.maxHealth);
            const healthPercent = player.maxHealth > 0 ? (player.health / playerMaxHealth) * 100 : 0;
            const expPercent = expToNextLevel > 0 ? (experience / expToNextLevel) * 100 : 0;

            const currentDashCooldown = DASH_STATS.COOLDOWN * (player.dashCooldownModifier || 1.0);
            const dashCooldownPercent = player.dashCooldownUntil > Date.now() ? ((player.dashCooldownUntil - Date.now()) / currentDashCooldown) * 100 : 0;
            const specialAbilityElement = React.createElement('div', { title: "Habilidade de Dash (Espa√ßo)", className: `relative w-8 h-8 border-2 rounded-md flex items-center justify-center ${dashCooldownPercent === 0 ? `border-[${GAME_COLORS.DASH_COOLDOWN_FILL}]` : `border-[${GAME_COLORS.DASH_COOLDOWN_BG}]`}` },
                React.createElement('div', { className: 'absolute bottom-0 left-0 w-full bg-cyan-400 opacity-60', style: { height: `${100 - dashCooldownPercent}%`, transition: 'height 0.1s linear' } }),
                React.createElement('span', { className: 'relative z-10 text-lg' }, '‚Ü™')
            );

            const technomancerMinionCountDisplay = player.classId === 'class_technomancer' ? 
                React.createElement('div', { title: "Contagem de Minions", className: 'relative w-auto px-2 h-8 border-2 rounded-md flex items-center justify-center border-cyan-400' },
                    React.createElement('span', { className: 'relative z-10 text-lg mr-2' }, 'ü§ñ'),
                    React.createElement('span', { className: 'relative z-10 font-press-start text-xs text-white' }, `[${alliedMinions.length}/${SUB_PROCESS_MINION_STATS.maxMinions}]`)
                ) : null;


            return React.createElement('div', { className: `w-56 h-full flex-shrink-0 bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] p-4 flex flex-col space-y-4 border-r-2 border-[${GAME_COLORS.BORDER}]` },
                React.createElement('div', null,
                    React.createElement('div', { className: 'flex items-center space-x-2 mb-1' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.HEALTH_PICKUP}]` }, '‚ù§Ô∏è'),
                        React.createElement('span', { className: 'font-press-start text-sm' }, 'HP'),
                        React.createElement('span', { className: `font-VT323 text-lg ml-auto` }, `${Math.ceil(player.health)}/${playerMaxHealth}`)
                    ),
                    React.createElement('div', { className: `w-full h-5 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}] p-0.5` },
                        React.createElement('div', {
                            className: `h-full rounded-sm ${healthPercent < 30 ? 'health-bar-fill low' : `bg-[${GAME_COLORS.PLAYER}]`} transition-all duration-300`,
                            style: { width: `${healthPercent}%` }
                        })
                    )
                ),
                React.createElement('div', null,
                    React.createElement('div', { className: 'flex items-center space-x-2 mb-1' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.TEXT_XP}]` }, '‚ú®'),
                        React.createElement('span', { className: 'font-press-start text-sm' }, 'XP'),
                        React.createElement('span', { className: `font-VT323 text-lg ml-auto` }, `${experience}/${expToNextLevel}`)
                    ),
                    React.createElement('div', { className: `w-full h-5 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}] p-0.5` },
                        React.createElement('div', {
                            className: `h-full rounded-sm bg-[${GAME_COLORS.XP_ORB}] transition-all duration-300`,
                            style: { width: `${expPercent}%` }
                        })
                    )
                ),
                React.createElement('div', { className: 'flex-grow flex flex-col items-start space-y-2' },
                    specialAbilityElement,
                    technomancerMinionCountDisplay,
                    player.temporaryBuffs && player.temporaryBuffs.length > 0 && 
                    React.createElement('div', { className: 'flex flex-wrap gap-2' }, 
                        player.temporaryBuffs.map(buff => {
                            if (buff.type === TemporaryBuffType.DAMAGE_REDUCTION) return null;
                            return React.createElement('div', { key: buff.id, title: buff.type, className: 'relative w-8 h-8 border-2 border-yellow-400 rounded-md flex items-center justify-center bg-gray-700' },
                                React.createElement('span', { className: 'text-lg'}, buff.icon),
                                React.createElement('div', { className: 'absolute -bottom-1 -right-1 text-xs bg-black px-0.5 rounded-sm font-VT323' }, Math.ceil((buff.endTime - Date.now()) / 1000))
                            )
                        })
                    )
                )
            );
        };

                const RightSidebar = ({ gameState }) => {
            if (!gameState || !gameState.player) return null;

            const { score, level, gameTime, stage, isInfiniteMode, isNightmareMode } = gameState;
            const stageDisplay = isInfiniteMode ? '‚àû' : stage;
            const statItemClass = "flex items-center justify-between p-2 bg-black bg-opacity-30 rounded-md";

            return React.createElement('div', { className: `w-56 h-full flex-shrink-0 bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] p-4 flex flex-col space-y-3 border-l-2 border-[${GAME_COLORS.BORDER}]` },
                // --- Bloco "FASE" Corrigido ---
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: 'text-xl text-cyan-400' }, 'üíª'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'FASE:')
                    ), // <- O div que agrupa o √≠cone e o texto "FASE" fecha aqui.
                    // O valor da fase agora √© um irm√£o desse div, mas ainda dentro do `statItemClass`
                    React.createElement('span', { className: 'font-VT323 text-lg text-cyan-300' }, stageDisplay)
                ), // <- O par√™ntese que fecha o `statItemClass` est√° no lugar correto agora.

                isNightmareMode && React.createElement('div', { className: `${statItemClass} border-2 border-red-700` },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: 'text-xl text-red-500 animate-pulse' }, 'üíÄ'),
                        React.createElement('span', { className: 'font-press-start text-xs text-red-400' }, 'PESADELO')
                    )
                ),
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.TEXT_YELLOW}]` }, '‚≠ê'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'N√çVEL:')
                    ),
                    React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, level)
                ),
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: `text-xl text-[${GAME_COLORS.TEXT_GREEN}]` }, 'üèÜ'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'PONTOS:')
                    ),
                    React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_GREEN}]` }, score)
                ),
                React.createElement('div', { className: statItemClass },
                    React.createElement('div', { className: 'flex items-center space-x-2' },
                        React.createElement('span', { className: 'text-xl text-sky-400' }, '‚è±Ô∏è'),
                        React.createElement('span', { className: 'font-press-start text-xs' }, 'TEMPO:')
                    ),
                    React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, formatTime(gameTime))
                )
            );
        };

        const UIOverlay = ({ gameState }) => {
            if (!gameState || (!gameState.boss && !gameState.eventActive)) return null;

            const { boss, eventActive, eventKillCounter, eventKillsSoFar } = gameState;
            const bossHealthPercent = boss && boss.maxHealth > 0 ? (boss.health / boss.maxHealth) * 100 : 0;
            const eventProgressPercent = eventKillCounter > 0 ? (eventKillsSoFar / eventKillCounter) * 100 : 0;

            let bossTitle = '', bossColor = GAME_COLORS.BOSS_CORE;
            if (boss) {
                if (boss.bossType === 'guardian') { bossTitle = 'GUARDI√ÉO DO N√öCLEO'; if (boss.phase === 2) bossTitle = 'GUARDI√ÉO: CORRUP√á√ÉO DE DADOS'; else if (boss.phase === 3) bossTitle = 'GUARDI√ÉO: SOBRECARGA TOTAL'; }
                else if (boss.bossType === 'sincronizador') { bossTitle = 'O SINCRONIZADOR'; bossColor = GAME_COLORS.BOSS_2_CORE; if (boss.phase === 2) bossTitle = 'SINCRONIZADOR: LASER DE DADOS'; else if (boss.phase === 3) bossTitle = 'SINCRONIZADOR: PROTOCOLO FINAL'; }
                else if (boss.bossType === 'arbiter') { bossTitle = 'O √ÅRBITRO DO SISTEMA'; bossColor = GAME_COLORS.BOSS_3_CORE; if (boss.phase === 2) bossTitle = '√ÅRBITRO: OTIMIZA√á√ÉO HOSTIL'; else if (boss.phase === 3) bossTitle = '√ÅRBITRO: KERNEL PANIC IMINENTE'; }
                else if (boss.bossType === 'hivemind_nexus') { bossTitle = 'NEXUS DA COLMEIA'; bossColor = GAME_COLORS.BOSS_4_CORE; if (boss.phase === 2) bossTitle = 'NEXUS: SATURA√á√ÉO DA REDE'; else if (boss.phase === 3) bossTitle = 'NEXUS: SINGULARIDADE'; }
            }

            return React.createElement('div', { id: 'ui-top-overlay', className: 'absolute top-0 left-1/2 -translate-x-1/2 w-full max-w-2xl p-2 z-10' },
                eventActive === 'DATA_VAULT' && (
                    React.createElement('div', { className: 'mt-2' },
                        React.createElement('h3', { className: `font-press-start text-center text-sm sm:text-lg text-yellow-400 mb-1 animate-pulse` }, 'QUEBRANDO CRIPTOGRAFIA...'),
                        React.createElement('div', { className: `w-full h-4 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-yellow-600 p-0.5` },
                            React.createElement('div', { className: `h-full rounded-sm transition-all duration-300 bg-yellow-400`, style: { width: `${eventProgressPercent}%` } }),
                            React.createElement('div', { className: 'absolute w-full h-full flex items-center justify-center top-0 left-0' }, React.createElement('span', { className: 'font-press-start text-xs text-black' }, `${eventKillsSoFar} / ${eventKillCounter}`))
                        )
                    )
                ),
                boss && (
                    React.createElement('div', { className: 'mt-2' },
                        React.createElement('h3', { className: `font-press-start text-center text-sm sm:text-lg text-[${GAME_COLORS.TEXT_RED}] mb-1 ${boss.phase === 3 ? 'animate-pulse' : ''}` }, bossTitle),
                        React.createElement('div', { className: `w-full h-6 sm:h-8 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}] p-0.5` },
                            React.createElement('div', { className: `h-full rounded-sm transition-all duration-300`, style: { width: `${bossHealthPercent}%`, backgroundColor: bossColor } })
                        )
                    )
                )
            );
        };
        
                // --- START OF components/GameCanvas.tsx ---
        const { useRef: useCanvasRef, useEffect: useCanvasEffect } = React;

        const GameCanvas = ({ gameState, gameScreen, crisolGameState }) => {
            const canvasRef = useCanvasRef(null);
            const animationTimeRef = useCanvasRef(0);

            const drawPlayer = (ctx, player) => {
                const skin = SKIN_DEFINITIONS.find(s => s.id === player.skinId) || SKIN_DEFINITIONS[0];
                if (skin.draw) {
                    skin.draw(ctx, player, { time: animationTimeRef.current });
                }
            };
            
            useCanvasEffect(() => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); if (!ctx) return;
                
                const now = performance.now();
                animationTimeRef.current = now;

                const isCrisolActive = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE, GameScreenState.CRISOL_PAUSED].includes(gameScreen);

                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (isCrisolActive) {
                    ctx.fillStyle = '#010409';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    ctx.strokeStyle = '#0e7490';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([15, 15]);
                    ctx.strokeRect(CRISOL_ARENA.x, CRISOL_ARENA.y, CRISOL_ARENA.width, CRISOL_ARENA.height);
                    ctx.setLineDash([]);
                    
                    if (crisolGameState) {
                        const { player: crisolPlayer, projectiles: crisolProjectiles, visualEffects } = crisolGameState;
                        
                        // Desenhar Proj√©teis
                        ctx.shadowBlur = 0;
                        crisolProjectiles.forEach(p => {
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        // Desenhar Efeitos Visuais (Feixes)
                        visualEffects.forEach(effect => {
                            if (effect.type === 'sweep_beam') {
                                const timeSinceStart = now - effect.startTime;
                                const timePassed = timeSinceStart / 1000;
                                let rect;

                                if (effect.from === 'left' || effect.from === 'right') {
                                    const leadEdgeX = effect.from === 'left' ? CRISOL_ARENA.x + timePassed * effect.speed : CRISOL_ARENA.x + CRISOL_ARENA.width - (timePassed * effect.speed);
                                    rect = { x: leadEdgeX - effect.width/2, y: CRISOL_ARENA.y, width: effect.width, height: CRISOL_ARENA.height };
                                } else {
                                    const leadEdgeY = effect.from === 'top' ? CRISOL_ARENA.y + timePassed * effect.speed : CRISOL_ARENA.y + CRISOL_ARENA.height - (timePassed * effect.speed);
                                    rect = { x: CRISOL_ARENA.x, y: leadEdgeY - effect.width/2, width: CRISOL_ARENA.width, height: effect.width };
                                }
                                
                                const warnTime = 500;
                                if (timeSinceStart < warnTime) {
                                    ctx.fillStyle = CRISOL_PROJECTILE_TYPES.BEAM_WARNING.color;
                                    ctx.globalAlpha = (timeSinceStart / warnTime) * (0.4 + Math.abs(Math.sin(now / 50)) * 0.2);
                                } else {
                                    ctx.fillStyle = effect.color;
                                    ctx.globalAlpha = 0.8;
                                }
                                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                                ctx.globalAlpha = 1.0;
                            }
                        });

                        // Desenhar Jogador
                        ctx.save();
                        if (crisolPlayer.isDashing) ctx.globalAlpha = 0.5;
                        if (now - crisolPlayer.lastHitTime < 500) ctx.globalAlpha = (Math.floor(now / 50) % 2 === 0) ? 0.4 : 0.8;
                        
                        ctx.fillStyle = '#38bdf8';
                        ctx.shadowColor = '#38bdf8';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(crisolPlayer.position.x, crisolPlayer.position.y, crisolPlayer.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }

                } else if (gameState) {
                    // ... (toda a l√≥gica de desenho do modo de jogo principal permanece aqui, sem altera√ß√µes)
                    if (gameState.stage === 4) {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_STAGE_4_ABYSS;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.save();
                        ctx.strokeStyle = GAME_COLORS.CIRCUIT_STAGE_4;
                        ctx.lineWidth = 2;
                        const circuitSpeed = animationTimeRef.current / 50000;
                        ctx.translate(Math.sin(circuitSpeed) * 50, Math.cos(circuitSpeed) * 50);
                        for (let i = -5; i < 30; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 100, -100);
                            ctx.lineTo(i * 100 + 1000, CANVAS_HEIGHT + 100);
                            ctx.stroke();
                        }
                        ctx.restore();
                        if (!gameState.dataFlowParticles) gameState.dataFlowParticles = [];
                        while(gameState.dataFlowParticles.length < 50) {
                            gameState.dataFlowParticles.push({
                                x: Math.random() * CANVAS_WIDTH,
                                y: Math.random() * CANVAS_HEIGHT,
                                vx: (Math.random() - 0.5) * 800,
                                vy: (Math.random() - 0.5) * 800,
                                color: Math.random() > 0.5 ? GAME_COLORS.DATA_FLOW_CYAN : GAME_COLORS.DATA_FLOW_MAGENTA
                            });
                        }
                        gameState.dataFlowParticles.forEach(p => {
                            p.x += p.vx * (1/60); 
                            p.y += p.vy * (1/60);
                            if (p.x < 0 || p.x > CANVAS_WIDTH || p.y < 0 || p.y > CANVAS_HEIGHT) {
                               p.x = Math.random() * CANVAS_WIDTH; p.y = Math.random() > 0.5 ? -10 : CANVAS_HEIGHT + 10;
                            }
                            ctx.fillStyle = p.color;
                            ctx.fillRect(p.x, p.y, 2, 2);
                        });
                    } else if (gameState.stage === 3) {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_STAGE_3;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.05)';
                        ctx.lineWidth = 15;
                        const busLinesV = [CANVAS_WIDTH/5, CANVAS_WIDTH*2/5, CANVAS_WIDTH*3/5, CANVAS_WIDTH*4/5];
                        const busLinesH = [CANVAS_HEIGHT/5, CANVAS_HEIGHT*2/5, CANVAS_HEIGHT*3/5, CANVAS_HEIGHT*4/5];
                        busLinesV.forEach(line => { ctx.beginPath(); ctx.moveTo(line, 0); ctx.lineTo(line, CANVAS_HEIGHT); ctx.stroke(); });
                        busLinesH.forEach(line => { ctx.beginPath(); ctx.moveTo(0, line); ctx.lineTo(CANVAS_WIDTH, line); ctx.stroke(); });
                    } else if (gameState.stage >= 2) {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_STAGE_2;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.strokeStyle = GAME_COLORS.GRID_STAGE_2; ctx.lineWidth = 1;
                        for (let x = 0; x < CANVAS_WIDTH; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); ctx.stroke(); }
                        for (let y = 0; y < CANVAS_HEIGHT; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); ctx.stroke(); }
                    } else {
                        ctx.fillStyle = GAME_COLORS.BACKGROUND_DARK; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    }
    
                    if (!gameState || !gameState.player) return;
                    const { player, enemies, projectiles, particles, expOrbs, healthPickups, knowledgeOrbs, dataVault, corruptedZones, boss, bossShieldNodes, revivingProcesses, dataWalls, laserBeams, interactables, alliedMinions, acidPuddles, unstableSectors, ramSockets, bossAttacks } = gameState;
    
                    // ... [toda a l√≥gica de desenho do modo principal que j√° existe no seu arquivo] ...
                    // O c√≥digo original para desenhar inimigos, jogador, etc., permanece aqui
                     unstableSectors.forEach(sector => {
                        const timeLeft = sector.endTime - Date.now();
                        if (timeLeft <= 0) return;
                        let alpha = 0.4; let color = GAME_COLORS.UNSTABLE_SECTOR_WARNING;
                        if (timeLeft < 500) { alpha = Math.abs(Math.sin(Date.now() / 50)) * 0.8; color = GAME_COLORS.UNSTABLE_SECTOR_DANGER; }
                        ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = color; ctx.fillRect(sector.x, sector.y, 40, 40); ctx.restore();
                    });
                    
                    if(dataVault) {
                        ctx.save();
                        const size = 60;
                        const x = dataVault.position.x;
                        const y = dataVault.position.y;
                        ctx.fillStyle = GAME_COLORS.DATA_VAULT;
                        ctx.strokeStyle = GAME_COLORS.DATA_VAULT_CIRCUIT;
                        ctx.lineWidth = 2 + Math.sin(Date.now() / 200) * 1.5;
                        ctx.shadowColor = GAME_COLORS.DATA_VAULT_CIRCUIT;
                        ctx.shadowBlur = 20;
                        ctx.fillRect(x - size/2, y - size/2, size, size);
                        ctx.strokeRect(x - size/2, y - size/2, size, size);
                        ctx.restore();
                    }
    
                    acidPuddles.forEach(puddle => {
                        ctx.save();
                        const lifetimeMs = puddle.endTime - (puddle.endTime - puddle.duration);
                        const remainingMs = puddle.endTime - Date.now();
                        const lifetimeRemaining = Math.max(0, remainingMs / lifetimeMs);
                        const alpha = lifetimeRemaining * (puddle.color ? 1 : 0.55);
                        ctx.globalAlpha = alpha;
                        if (puddle.isCritical) {
                            ctx.fillStyle = GAME_COLORS.TEXT_YELLOW;
                            ctx.shadowColor = GAME_COLORS.TEXT_YELLOW;
                            ctx.shadowBlur = 15 + Math.sin(Date.now() / 100) * 5;
                        } else {
                            ctx.fillStyle = puddle.color || GAME_COLORS.ACID_PUDDLE;
                            ctx.shadowColor = puddle.color || GAME_COLORS.PROJECTILE_ACID_VIRUS;
                            ctx.shadowBlur = 10;
                        }
                        ctx.beginPath();
                        ctx.arc(puddle.position.x, puddle.position.y, puddle.radius, 0, Math.PI * 2);
                        ctx.fill();
                        if (puddle.color === GAME_COLORS.ACID_PUDDLE && Math.random() < 0.15) {
                            particles.push({
                                id: `bubble-${puddle.id}-${Date.now()}-${Math.random()}`,
                                position: { x: puddle.position.x + (Math.random() - 0.5) * puddle.radius * 1.8, y: puddle.position.y + (Math.random() - 0.5) * puddle.radius * 1.8 },
                                velocity: { x: 0, y: -(Math.random() * 10 + 5) },
                                size: Math.random() * 2 + 1,
                                color: 'rgba(190, 242, 100, 0.7)',
                                life: 25
                            });
                        }
                        ctx.restore();
                    });
    
                    interactables.forEach(i => {
                        ctx.save();
                        if (i.type === InteractableType.DATA_CACHE) {
                            ctx.fillStyle = GAME_COLORS.DATA_CACHE;
                            ctx.shadowColor = GAME_COLORS.DATA_CACHE;
                            ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5;
                            ctx.fillRect(i.position.x - i.size / 2, i.position.y - i.size / 2, i.size, i.size);
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(i.position.x - i.size / 2, i.position.y - i.size / 2, i.size, i.size);
                        } else if (i.type === InteractableType.CORRUPTED_LIBRARY) {
                            ctx.fillStyle = GAME_COLORS.CORRUPTED_LIBRARY;
                            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 150) * 0.2;
                            ctx.beginPath();
                            ctx.arc(i.position.x, i.position.y, i.radius, 0, Math.PI * 2);
                            ctx.fill();
    
                            if (i.cleanseProgress > 0) {
                                ctx.fillStyle = GAME_COLORS.PROGRESS_BAR_BG;
                                ctx.fillRect(i.position.x - i.radius, i.position.y - i.radius - 15, i.radius * 2, 8);
                                ctx.fillStyle = GAME_COLORS.TEXT_GREEN;
                                ctx.fillRect(i.position.x - i.radius, i.position.y - i.radius - 15, i.radius * 2 * i.cleanseProgress, 8);
                                ctx.strokeStyle = GAME_COLORS.BORDER;
                                ctx.strokeRect(i.position.x - i.radius, i.position.y - i.radius - 15, i.radius * 2, 8);
                            }
                        }
                        ctx.restore();
                    });
    
                    dataWalls.forEach(wall => {
                        ctx.save(); ctx.fillStyle = GAME_COLORS.BOSS_2_DATA_WALL; ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;
                        ctx.fillRect(wall.position.x, wall.position.y, wall.width, wall.height); ctx.restore();
                    });
                    
                    laserBeams.forEach(laser => {
                        const now = Date.now();
                        if (now >= laser.fireStartTime) { 
                            ctx.save();
                            ctx.translate(boss.position.x, boss.position.y); ctx.rotate(laser.angle);
                            const laserAlpha = (laser.endTime - now) / (laser.endTime - laser.fireStartTime);
                            ctx.fillStyle = GAME_COLORS.BOSS_2_LASER; ctx.globalAlpha = Math.min(1, laserAlpha) * 0.8;
                            ctx.fillRect(-CANVAS_WIDTH * 1.5, -BOSS_2_STATS.laserWidth / 2, CANVAS_WIDTH * 3, BOSS_2_STATS.laserWidth);
                            ctx.restore();
                        } else if (now < laser.fireStartTime) { 
                            ctx.save();
                            const chargeProgress = (now - laser.chargeStartTime) / (laser.fireStartTime - laser.chargeStartTime);
                            ctx.translate(boss.position.x, boss.position.y); ctx.rotate(laser.angle);
                            ctx.strokeStyle = GAME_COLORS.BOSS_2_LASER; ctx.lineWidth = 2; ctx.globalAlpha = chargeProgress * 0.7;
                            ctx.beginPath(); ctx.moveTo(-CANVAS_WIDTH * 1.5, -BOSS_2_STATS.laserWidth / 2); ctx.lineTo(CANVAS_WIDTH * 1.5, -BOSS_2_STATS.laserWidth / 2); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(-CANVAS_WIDTH * 1.5, BOSS_2_STATS.laserWidth / 2); ctx.lineTo(CANVAS_WIDTH * 1.5, BOSS_2_STATS.laserWidth / 2); ctx.stroke();
                            ctx.restore();
                        }
                    });
    
                    corruptedZones.forEach(zone => { const lifetimeRemaining = (zone.creationTime + zone.duration) - Date.now(); const alpha = Math.max(0, Math.min(1, lifetimeRemaining / zone.duration)) * 0.7; ctx.save(); ctx.fillStyle = GAME_COLORS.CORRUPTED_ZONE; ctx.globalAlpha = alpha * (0.4 + Math.sin(Date.now() / 80) * 0.1); ctx.beginPath(); ctx.arc(zone.position.x, zone.position.y, zone.radius, 0, Math.PI * 2); ctx.fill(); const staticPoints = 30; ctx.strokeStyle = `rgba(200,0,0, ${alpha * 0.5})`; ctx.lineWidth = 1; for(let i=0; i < staticPoints; i++){ const angle = Math.random() * Math.PI * 2; const radius = Math.random() * zone.radius * 0.9; const x = zone.position.x + Math.cos(angle) * radius; const y = zone.position.y + Math.sin(angle) * radius; ctx.beginPath(); ctx.arc(x,y, Math.random()*2,0, Math.PI*2); ctx.fill(); } ctx.restore(); });
                    
                    bossAttacks.forEach(attack => {
                        ctx.save();
                        const now = Date.now();
                        const timeSinceCreation = now - attack.creationTime;
                        
                        if (attack.type === BossAttackType.DATA_SMASHER) {
                            const warnProgress = Math.min(1, timeSinceCreation / attack.warningDuration);
                            const impactTime = attack.creationTime + attack.warningDuration;
                            if (now < impactTime) {
                                ctx.strokeStyle = GAME_COLORS.BOSS_3_BUS_WARNING;
                                ctx.lineWidth = 5;
                                ctx.globalAlpha = warnProgress * (0.5 + Math.abs(Math.sin(now / 50)) * 0.5);
                                ctx.beginPath();
                                ctx.arc(attack.targetPosition.x, attack.targetPosition.y, attack.radius, 0, Math.PI * 2);
                                ctx.stroke();
                            } else {
                                const impactProgress = Math.min(1, (now - impactTime) / 300);
                                ctx.fillStyle = GAME_COLORS.BOSS_3_BUS_FIRE;
                                ctx.globalAlpha = 1 - impactProgress;
                                ctx.beginPath();
                                ctx.arc(attack.targetPosition.x, attack.targetPosition.y, attack.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        } else if (attack.type === BossAttackType.HOSTILE_TAKEOVER) {
                            const warnProgress = Math.min(1, timeSinceCreation / attack.warningDuration);
                            const fireStartTime = attack.creationTime + attack.warningDuration;
                            const fireEndTime = fireStartTime + attack.fireDuration;
                            if (now < fireStartTime) {
                                ctx.fillStyle = GAME_COLORS.BOSS_3_BUS_WARNING;
                                ctx.globalAlpha = warnProgress * (0.3 + Math.abs(Math.sin(now/60)) * 0.4);
                                if (attack.isHorizontal) { ctx.fillRect(0, attack.line - 15, CANVAS_WIDTH, 30); }
                                else { ctx.fillRect(attack.line - 15, 0, 30, CANVAS_HEIGHT); }
                            } else if (now < fireEndTime) {
                                ctx.fillStyle = GAME_COLORS.BOSS_3_BUS_FIRE;
                                ctx.globalAlpha = 0.9;
                                if (attack.isHorizontal) { ctx.fillRect(0, attack.line - 15, CANVAS_WIDTH, 30); }
                                else { ctx.fillRect(attack.line - 15, 0, 30, CANVAS_HEIGHT); }
                            }
                        } else if (attack.type === BossAttackType.LOGIC_BOMB) {
                            const armProgress = Math.min(1, timeSinceCreation / attack.armDuration);
                            if (!attack.triggered) {
                                ctx.fillStyle = GAME_COLORS.BOSS_3_LOGIC_BOMB;
                                ctx.globalAlpha = armProgress;
                                ctx.beginPath();
                                ctx.arc(attack.position.x, attack.position.y, 15, 0, Math.PI * 2);
                                ctx.fill();
                                if (armProgress === 1) {
                                    ctx.strokeStyle = GAME_COLORS.BOSS_3_LOGIC_BOMB;
                                    ctx.lineWidth = 2;
                                    ctx.globalAlpha = Math.abs(Math.sin(now / 150));
                                    ctx.beginPath();
                                    ctx.arc(attack.position.x, attack.position.y, 20, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            } else {
                                const explosionProgress = Math.min(1, (now - attack.detonationTime) / 500);
                                ctx.strokeStyle = GAME_COLORS.BOSS_3_BUS_FIRE;
                                ctx.lineWidth = 20;
                                ctx.globalAlpha = 1 - explosionProgress;
                                ctx.beginPath();
                                ctx.moveTo(attack.position.x - attack.radius, attack.position.y); ctx.lineTo(attack.position.x + attack.radius, attack.position.y);
                                ctx.moveTo(attack.position.x, attack.position.y - attack.radius); ctx.lineTo(attack.position.x, attack.position.y + attack.radius);
                                ctx.stroke();
                            }
                        } else if (attack.type === BossAttackType.STATIC_ZONE) {
                             const lifetimeProgress = Math.min(1, timeSinceCreation / attack.duration);
                             ctx.fillStyle = GAME_COLORS.BOSS_3_STATIC_ZONE;
                             ctx.globalAlpha = Math.sin(lifetimeProgress * Math.PI) * 0.7 * (0.5 + Math.abs(Math.sin(now/100)*0.5));
                             ctx.beginPath();
                             ctx.arc(attack.position.x, attack.position.y, attack.radius, 0, Math.PI * 2);
                             ctx.fill();
                        }
                        
                        ctx.restore();
                    });
                    
                    const dataLeechWeapon = player.weapons.find(w => w.id === 'data_leech' || w.id === 'leech_siphon_chain');
                    if (dataLeechWeapon && dataLeechWeapon.targetId) {
                        const primaryTarget = [...enemies, ...bossShieldNodes, ...(boss ? [boss] : [])].find(e => e.id === dataLeechWeapon.targetId);
                        if (primaryTarget) {
                            ctx.save();
                            const stillTime = dataLeechWeapon.stillTime || 0;
                            const rampProgress = stillTime / DATA_LEECH_STATS.stillDamageRampUpTime;
                            
                            const isSurging = dataLeechWeapon.isCriticallySurging;
                            ctx.strokeStyle = isSurging ? GAME_COLORS.CRITICAL_HIT_TEXT : GAME_COLORS.EFFECT_DATA_LEECH;
                            ctx.lineWidth = isSurging ? 3.5 + (2.5 * rampProgress) : 1.5 + (2.5 * rampProgress);
                            ctx.globalAlpha = (isSurging ? 0.8 : 0.5) + 0.5 * rampProgress + Math.sin(Date.now() / 50) * 0.1;
                            ctx.shadowColor = isSurging ? GAME_COLORS.CRITICAL_HIT_TEXT : GAME_COLORS.EFFECT_DATA_LEECH;
                            ctx.shadowBlur = isSurging ? 15 + 10 * rampProgress : 5 + 10 * rampProgress;
    
                            ctx.beginPath();
                            ctx.moveTo(player.position.x, player.position.y);
                            ctx.lineTo(primaryTarget.position.x, primaryTarget.position.y);
                            ctx.stroke();
    
                            if (dataLeechWeapon.chainTargetIds && dataLeechWeapon.chainTargetIds.length > 0) {
                                ctx.lineWidth = isSurging ? 2.5 : 1.25; 
                                ctx.globalAlpha = isSurging ? 0.7 : 0.4 + Math.sin(Date.now() / 60) * 0.1;
                                ctx.shadowBlur = isSurging ? 10 : 5;
    
                                dataLeechWeapon.chainTargetIds.forEach(targetId => {
                                    const chainTarget = [...enemies, ...bossShieldNodes].find(e => e.id === targetId);
                                    if (chainTarget) {
                                        ctx.beginPath();
                                        ctx.moveTo(primaryTarget.position.x, primaryTarget.position.y);
                                        ctx.lineTo(chainTarget.position.x, chainTarget.position.y);
                                        ctx.stroke();
                                    }
                                });
                            }
                            
                            ctx.restore();
                        }
                    }
                    
                    ctx.save(); 
                    if (player.isDashing) { ctx.globalAlpha = 0.5; } 
                    if (player.overdriveActive) { ctx.shadowColor = GAME_COLORS.PLAYER_OVERDRIVE_GLOW; ctx.shadowBlur = 25; } 
                    else if (Date.now() - player.lastHitTime < 200) { ctx.globalAlpha = (Math.floor(Date.now() / 50) % 2 === 0) ? 0.5 : 1.0; }
                    drawPlayer(ctx, player);
                    ctx.restore();
    
                    const firewallWeapon = player.weapons.find(w => w.id === 'firewall' || w.id === 'firewall_aegis_shield'); if (firewallWeapon && firewallWeapon.orbs && firewallWeapon.currentAngle !== undefined) { const isAegis = firewallWeapon.id === 'firewall_aegis_shield'; const orbSize = isAegis ? FIREWALL_STATS.orbSize * FIREWALL_STATS.aegisOrbSizeMultiplier : FIREWALL_STATS.orbSize; const orbColor = isAegis ? GAME_COLORS.FIREWALL_AEGIS_ORB : GAME_COLORS.FIREWALL_ORB; for (let i = 0; i < firewallWeapon.orbs; i++) { const angle = firewallWeapon.currentAngle + (i * (2 * Math.PI / firewallWeapon.orbs)); const orbX = player.position.x + Math.cos(angle) * FIREWALL_STATS.radius; const orbY = player.position.y + Math.sin(angle) * FIREWALL_STATS.radius; ctx.save(); ctx.fillStyle = orbColor; ctx.shadowColor = orbColor; ctx.shadowBlur = isAegis ? 15 : 10; ctx.beginPath(); ctx.arc(orbX, orbY, orbSize / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
    
                    revivingProcesses.forEach(proc => {
                        const reviveProgress = 1 - ((proc.reviveAt - Date.now()) / ENEMY_PROCESSO_ZUMBI_STATS.reviveTime);
                        ctx.save(); ctx.globalAlpha = 0.5; ctx.fillStyle = GAME_COLORS.ENEMY_PROCESSO_ZUMBI;
                        ctx.beginPath(); ctx.arc(proc.position.x, proc.position.y, ENEMY_PROCESSO_ZUMBI_STATS.size / 2 * reviveProgress, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = GAME_COLORS.ENEMY_PROCESSO_ZUMBI; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(proc.position.x, proc.position.y, ENEMY_PROCESSO_ZUMBI_STATS.size, 0, Math.PI*2 * reviveProgress); ctx.stroke(); ctx.restore();
                    });
                    
                    alliedMinions.forEach(minion => {
                        ctx.save();
                        ctx.translate(minion.position.x, minion.position.y);
                        ctx.rotate(minion.angle);
    
                        ctx.fillStyle = minion.color;
                        ctx.shadowColor = minion.color;
                        ctx.shadowBlur = 8;
    
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const vertexAngle = (i * (Math.PI * 2 / 5)) - (Math.PI / 2); 
                            const x = (minion.size / 2) * Math.cos(vertexAngle);
                            const y = (minion.size / 2) * Math.sin(vertexAngle);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
    
                        const minionHealthPercent = minion.health / minion.maxHealth;
                        ctx.fillStyle = GAME_COLORS.PROGRESS_BAR_BG;
                        ctx.fillRect(minion.position.x - minion.size, minion.position.y - minion.size / 2 - 8, minion.size * 2, 4);
                        ctx.fillStyle = GAME_COLORS.TEXT_GREEN;
                        ctx.fillRect(minion.position.x - minion.size, minion.position.y - minion.size / 2 - 8, minion.size * 2 * minionHealthPercent, 4);
                    });
    
    
                    enemies.forEach((e) => {
                        if (e.type === EnemyType.SPYWARE && !e.isCurrentlyVisible) return;
                        ctx.save(); let originalAlpha = ctx.globalAlpha; if (e.statusEffects && e.statusEffects.length > 0) { e.statusEffects.forEach(effect => { if (Date.now() <= effect.startTime + effect.duration) { switch (effect.type) { case StatusEffectType.SLOW: ctx.fillStyle = GAME_COLORS.STATUS_SLOW_TINT; ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 200) * 0.1; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * 0.8, 0, Math.PI * 2); ctx.fill(); break; case StatusEffectType.FREEZE: ctx.fillStyle = GAME_COLORS.STATUS_FREEZE_TINT; ctx.globalAlpha = 0.7; ctx.beginPath(); for(let i = 0; i < 8; i++) { const angle = (Math.PI * 2 / 8) * i; const radius = e.size * 0.6 + (i % 2 === 0 ? e.size * 0.15 : e.size * 0.05); ctx.lineTo(e.position.x + Math.cos(angle) * radius, e.position.y + Math.sin(angle) * radius); } ctx.closePath(); ctx.fill(); break; case StatusEffectType.VULNERABILITY: ctx.strokeStyle = GAME_COLORS.STATUS_VULNERABILITY_AURA; ctx.lineWidth = 2 + Math.sin(Date.now() / 150) * 1; ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * 0.7, 0, Math.PI * 2); ctx.stroke(); break; case StatusEffectType.FEAR: ctx.fillStyle = GAME_COLORS.STATUS_FEAR_AURA; ctx.globalAlpha = 0.3 + Math.abs(Math.sin(Date.now() / 100)) * 0.2; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * 0.85, 0, Math.PI * 2); ctx.fill(); break; } } }); } ctx.globalAlpha = originalAlpha; ctx.fillStyle = e.color || GAME_COLORS.ENEMY_DEFAULT;
                        const stage2Enemies = [EnemyType.PROCESSO_CORROMPIDO, EnemyType.PONTEIRO_NULO, EnemyType.SEGMENTO_FALHA];
                        if (stage2Enemies.includes(e.type)) { const angleToPlayer = Math.atan2(player.position.y - e.position.y, player.position.x - e.position.x); ctx.beginPath(); ctx.moveTo(e.position.x + e.size / 2 * Math.cos(angleToPlayer), e.position.y + e.size / 2 * Math.sin(angleToPlayer)); ctx.lineTo(e.position.x + e.size / 2 * Math.cos(angleToPlayer + (Math.PI * 2 / 3)), e.position.y + e.size / 2 * Math.sin(angleToPlayer + (Math.PI * 2 / 3))); ctx.lineTo(e.position.x + e.size / 2 * Math.cos(angleToPlayer - (Math.PI * 2 / 3)), e.position.y + e.size / 2 * Math.sin(angleToPlayer - (Math.PI * 2 / 3))); ctx.closePath(); ctx.fill(); if (e.type === EnemyType.SEGMENTO_FALHA && e.isShielded) { ctx.strokeStyle = GAME_COLORS.SHIELD_EFFECT; ctx.lineWidth = 3; ctx.stroke(); } if (e.type === EnemyType.PONTEIRO_NULO && e.isChargingTeleport) { const chargeProgress = (Date.now() - e.teleportChargeStartTime) / ENEMY_PONTEIRO_NULO_STATS.teleportChargeTime; ctx.fillStyle = GAME_COLORS.TELEPORT_CHARGE_EFFECT; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size * chargeProgress, 0, Math.PI*2); ctx.fill(); } } 
                        else if (e.type === EnemyType.GLITCH_MINION) { const glitchAmount = 3; for(let i=0; i < 3; i++) { ctx.globalAlpha = 0.3 + Math.random() * 0.4; ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, ${ctx.globalAlpha})`; ctx.fillRect(e.position.x - e.size/2 + (Math.random()-0.5)*glitchAmount, e.position.y - e.size/2 + (Math.random()-0.5)*glitchAmount, e.size, e.size); } ctx.globalAlpha = originalAlpha; } 
                        else if (e.type === EnemyType.PROCESSO_ZUMBI) { ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size / 2, 0, Math.PI*2); ctx.fill(); if (e.hasRevived) { ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.stroke(); } }
                        else if (e.type === EnemyType.VOLATILE_PROCESS) { ctx.fillRect(e.position.x - e.size/2, e.position.y - e.size/2, e.size, e.size); ctx.fillStyle = 'white'; ctx.font = `bold ${e.size * 0.6}px VT323`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(((e.fuseEndTime - Date.now())/1000).toFixed(1), e.position.x, e.position.y); }
                        else if (e.type === EnemyType.RECURSIVE_PROCESS) { drawRecursiveProcess(ctx, e, animationTimeRef.current); }
                        else if (e.type === EnemyType.CHILD_PROCESS) { drawChildProcess(ctx, e, animationTimeRef.current); }
                        else if (e.type === EnemyType.ROGUE_FIREWALL) { drawRogueFirewall(ctx, e, animationTimeRef.current); }
                        else if (e.type === EnemyType.LATENCY_SPIKE) {
                            ctx.save();
                            ctx.fillStyle = e.color;
                            ctx.beginPath();
                            ctx.arc(e.position.x, e.position.y, e.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            const echoSize = e.size * 0.4;
                            const echoDistance = e.size * 0.6;
                            const echoAlpha = 0.6;
                            const directions = [ { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 } ];
                            ctx.fillStyle = `rgba(96, 165, 250, ${echoAlpha})`;
                            directions.forEach(dir => {
                                const echoX = e.position.x + dir.x * echoDistance;
                                const echoY = e.position.y + dir.y * echoDistance;
                                ctx.beginPath();
                                ctx.arc(echoX, echoY, echoSize / 2, 0, Math.PI * 2);
                                ctx.fill();
                            });
                            ctx.restore();
                        }
                        else if (e.type === EnemyType.PROTOCOL_ANOMALY) {
                            ctx.save();
                            ctx.translate(e.position.x, e.position.y);
                            if (e.protocol === 'TCP') { 
                                ctx.fillStyle = e.color;
                                ctx.beginPath(); ctx.arc(0,0, e.size/2, 0, Math.PI*2); ctx.fill();
                                ctx.strokeStyle = 'white'; ctx.lineWidth=2;
                                ctx.beginPath(); ctx.arc(0,0, e.size/2 * (0.8 + Math.sin(animationTimeRef.current/200)*0.1), 0, Math.PI*2); ctx.stroke();
                            } else { 
                                ctx.fillStyle = '#ff4757';
                                for (let i = 0; i < 8; i++) {
                                    const angle = (i/8)*Math.PI*2 + animationTimeRef.current/800;
                                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angle)*e.size*0.4, Math.sin(angle)*e.size*0.4);
                                    ctx.lineTo(Math.cos(angle)*e.size*0.7, Math.sin(angle)*e.size*0.7); ctx.stroke();
                                }
                            }
                            ctx.restore();
                        }
                        else { ctx.fillRect(e.position.x - e.size/2, e.position.y - e.size/2, e.size, e.size); }
                        if (e.dotEffects && e.dotEffects.some(dot => dot.ticksRemaining > 0)) { ctx.fillStyle = GAME_COLORS.ENEMY_DOT_EFFECT; ctx.globalAlpha = 0.5 + Math.sin(Date.now()/100) * 0.2; ctx.beginPath(); ctx.arc(e.position.x, e.position.y, e.size / 2 + 3, 0, Math.PI * 2); ctx.fill(); } if (e.type === EnemyType.MEMORY_LEAK && e.trail) { ctx.fillStyle = GAME_COLORS.MEMORY_LEAK_TRAIL; e.trail.forEach(segment => ctx.fillRect(segment.x - ENEMY_MEMORY_LEAK_STATS.trailSize / 2, segment.y - ENEMY_MEMORY_LEAK_STATS.trailSize / 2, ENEMY_MEMORY_LEAK_STATS.trailSize, ENEMY_MEMORY_LEAK_STATS.trailSize)); } ctx.restore(); 
                    });
                    ramSockets.forEach(socket => { ctx.save(); const s = RAM_SOCKET_STATS.size; ctx.strokeStyle = socket.isCorrupted ? GAME_COLORS.BOSS_3_RAM_SOCKET_CORRUPTED : GAME_COLORS.BORDER; ctx.lineWidth = 4; ctx.strokeRect(socket.position.x - s/2, socket.position.y - s/2, s, s); if(socket.cleanseProgress > 0) { ctx.fillStyle = GAME_COLORS.BOSS_3_RAM_SOCKET_CLEANSE; ctx.globalAlpha = 0.6; ctx.fillRect(socket.position.x - s/2, socket.position.y + s/2 - (s * socket.cleanseProgress), s, s * socket.cleanseProgress); } ctx.restore(); });
                    if (boss && boss.health > 0) {
                        ctx.save();
                        if (boss.bossType === 'guardian') {
                            let bossBaseColor = GAME_COLORS.BOSS_CORE; let bossGlow = 'rgba(106, 13, 173, 0.7)';
                            if (boss.phase === 2) { bossBaseColor = GAME_COLORS.ENEMY_GLITCH_MINION; bossGlow = 'rgba(220, 20, 60, 0.8)'; } else if (boss.phase === 3) { bossBaseColor = GAME_COLORS.PROJECTILE_DATA_STREAM; bossGlow = 'rgba(255, 99, 71, 0.9)'; const phase3Pulse = Math.abs(Math.sin(Date.now()/150)); ctx.shadowColor = bossGlow; ctx.shadowBlur = 20 + phase3Pulse * 15; }
                            if (boss.statusEffects && boss.statusEffects.length > 0) { boss.statusEffects.forEach(effect => { if (Date.now() <= effect.startTime + effect.duration) { if (effect.type === StatusEffectType.FREEZE) { ctx.fillStyle = GAME_COLORS.STATUS_FREEZE_TINT; ctx.globalAlpha = 0.5; ctx.fillRect(boss.position.x - boss.size * 0.6, boss.position.y - boss.size * 0.6, boss.size * 1.2, boss.size * 1.2); } else if (effect.type === StatusEffectType.VULNERABILITY) { ctx.strokeStyle = GAME_COLORS.STATUS_VULNERABILITY_AURA; ctx.lineWidth = 3; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, boss.size * 0.6, 0, Math.PI * 2); ctx.stroke(); } } }); ctx.globalAlpha = 1; }
                            ctx.fillStyle = bossBaseColor; ctx.fillRect(boss.position.x - boss.size / 2, boss.position.y - boss.size / 2, boss.size, boss.size);
                            ctx.fillStyle = (boss.phase === 3) ? GAME_COLORS.TEXT_RED : GAME_COLORS.TEXT_RED; const corePulseFactor = 1 + Math.sin(Date.now() / (boss.phase === 3 ? 100 : 200)) * (boss.phase === 3 ? 0.2 : 0.1); ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, boss.coreSize / 2 * corePulseFactor, 0, Math.PI * 2); ctx.fill();
                        } else if (boss.bossType === 'sincronizador') {
                            const pulse = Math.abs(Math.sin(Date.now() / 200)) * 0.1;
                            ctx.fillStyle = boss.color; ctx.shadowColor = boss.color; ctx.shadowBlur = 20 + pulse * 15;
                            ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, boss.size/2 * (1 + pulse), 0, Math.PI*2); ctx.fill();
                        } else if (boss.bossType === 'arbiter') {
                            if(boss.phase === 3) { ctx.fillStyle = GAME_COLORS.BOSS_3_AURA; ctx.beginPath(); ctx.arc(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, boss.phase3AuraRadius, 0, 2*Math.PI); ctx.fill(); }
                            ctx.strokeStyle = boss.isInvulnerable ? GAME_COLORS.BORDER : GAME_COLORS.BOSS_3_CORE; ctx.lineWidth = 6; const sides = 8; const radius = boss.size / 2; ctx.beginPath(); for(let i=0; i<sides; i++){ ctx.lineTo(boss.position.x + radius*Math.cos(i*2*Math.PI/sides), boss.position.y + radius*Math.sin(i*2*Math.PI/sides)); } ctx.closePath(); ctx.stroke(); ctx.fillStyle = boss.isInvulnerable ? GAME_COLORS.BORDER : GAME_COLORS.BOSS_3_CORE; ctx.beginPath(); ctx.arc(boss.position.x, boss.position.y, radius*0.4, 0, 2*Math.PI); ctx.fill();
                        }else if (boss.bossType === 'hivemind_nexus') {
                            const phaseColor = boss.phase === 1 ? boss.color : (boss.phase === 2 ? '#ff4757' : '#feca57');
                            ctx.shadowColor = phaseColor;
                            ctx.shadowBlur = 30 + Math.sin(Date.now() / 150) * 15;
    
                            if (boss.phase === 1) {
                                (bossShieldNodes || []).forEach(node => {
                                    if (node.health > 0) {
                                        ctx.strokeStyle = `rgba(236, 72, 153, 0.4)`;
                                        ctx.lineWidth = 4 + Math.sin(Date.now()/200) * 2;
                                        ctx.beginPath(); ctx.moveTo(boss.position.x, boss.position.y);
                                        ctx.bezierCurveTo(boss.position.x, node.position.y, node.position.x, boss.position.y, node.position.x, node.position.y);
                                        ctx.stroke();
                                    }
                                });
                            }
                            
                            ctx.fillStyle = phaseColor;
                            ctx.beginPath();
                            ctx.arc(boss.position.x, boss.position.y, boss.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = 'black';
                            const pupilSize = boss.size * (0.2 + Math.cos(Date.now()/500)*0.1);
                            ctx.beginPath();
                            ctx.arc(boss.position.x, boss.position.y, pupilSize, 0, Math.PI * 2);
                            ctx.fill();
    
                            if (boss.phase === 3 && boss.arenaShrinkAmount > 0) {
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                                ctx.fillRect(0, 0, CANVAS_WIDTH, boss.arenaShrinkAmount);
                                ctx.fillRect(0, CANVAS_HEIGHT - boss.arenaShrinkAmount, CANVAS_WIDTH, boss.arenaShrinkAmount);
                                ctx.fillRect(0, 0, boss.arenaShrinkAmount, CANVAS_HEIGHT);
                                ctx.fillRect(CANVAS_WIDTH - boss.arenaShrinkAmount, 0, boss.arenaShrinkAmount, CANVAS_HEIGHT);
                            }
                        }
                        ctx.restore();
                        (bossShieldNodes || []).forEach(node => { if (node.health > 0) { ctx.save(); if(node.statusEffects && node.statusEffects.some(ef => ef.type === StatusEffectType.VULNERABILITY && Date.now() <= ef.startTime + ef.duration)) { ctx.strokeStyle = GAME_COLORS.STATUS_VULNERABILITY_AURA; ctx.lineWidth = 2; ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(node.position.x, node.position.y, node.size * 0.6, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1; } ctx.fillStyle = node.color || GAME_COLORS.BOSS_SHIELD_NODE; ctx.shadowColor = node.color; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(node.position.x, node.position.y, node.size / 2, 0, Math.PI * 2); ctx.fill(); const nodeHealthPercent = node.health / node.maxHealth; ctx.fillStyle = GAME_COLORS.PROGRESS_BAR_BG; ctx.fillRect(node.position.x - node.size, node.position.y - node.size / 2 - 5, node.size * 2, 4); ctx.fillStyle = GAME_COLORS.TEXT_GREEN; ctx.fillRect(node.position.x - node.size, node.position.y - node.size / 2 - 5, node.size * 2 * nodeHealthPercent, 4); ctx.restore(); } });
                    }
                    projectiles.forEach(p => { 
                        if (p.chainLightning && p.chainLightning.currentChainHits > 0 && p.previousChainPosition) { ctx.save(); ctx.strokeStyle = p.chainLightning.color || GAME_COLORS.PROJECTILE_CHAIN_LIGHTNING; ctx.lineWidth = 1 + Math.random() * 2; ctx.globalAlpha = 0.6 + Math.random() * 0.4; ctx.beginPath(); ctx.moveTo(p.previousChainPosition.x, p.previousChainPosition.y); const dx = p.position.x - p.previousChainPosition.x; const dy = p.position.y - p.previousChainPosition.y; const numJaggedPoints = 3; for(let i=1; i <= numJaggedPoints; i++){ const t = i / (numJaggedPoints + 1); ctx.lineTo(p.previousChainPosition.x + dx * t + (Math.random()-0.5)*10, p.previousChainPosition.y + dy * t + (Math.random()-0.5)*10); } ctx.lineTo(p.position.x, p.position.y); ctx.stroke(); ctx.restore(); } 
                        else {
                            if (p.type === 'acid_spore') {
                                 ctx.save();
                                 ctx.fillStyle = p.color || GAME_COLORS.PROJECTILE_ACID_SPORE;
                                 ctx.shadowColor = p.color;
                                 ctx.shadowBlur = 10 + Math.sin(Date.now() / 80) * 5;
                                 ctx.beginPath(); ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2); ctx.fill();
                                 ctx.restore();
                            } else if (p.type === 'corruption_wave') {
                                ctx.save();
                                ctx.fillStyle = p.color;
                                ctx.globalAlpha = 0.7;
                                ctx.translate(p.position.x, p.position.y);
                                ctx.rotate(Math.atan2(p.velocity.y, p.velocity.x));
                                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                                ctx.restore();
                            } else {
                                ctx.fillStyle = p.color || GAME_COLORS.PROJECTILE;
                                ctx.beginPath();
                                if (p.type === 'firewall_shard' || p.type === 'boss_phase1' || p.type === 'boss_phase2' || p.type === 'boss_data_stream' || p.type === 'acid_virus_shot') {
                                    ctx.fillRect(p.position.x - p.size / 2, p.position.y - p.size / 2, p.size, p.size);
                                } else {
                                    ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2);
                                }
                                ctx.fill();
                            }
                        }
                    });
                    expOrbs.forEach(orb => { ctx.save(); ctx.fillStyle = orb.color || GAME_COLORS.XP_ORB; ctx.shadowColor = orb.color || GAME_COLORS.XP_ORB; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(orb.position.x, orb.position.y, orb.size / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); });
                    knowledgeOrbs.forEach(orb => { ctx.save(); ctx.fillStyle = GAME_COLORS.KNOWLEDGE_ORB; ctx.shadowColor = GAME_COLORS.KNOWLEDGE_ORB; ctx.shadowBlur = 25; ctx.beginPath(); ctx.arc(orb.position.x, orb.position.y, orb.size / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); });
                    healthPickups.forEach(p => { ctx.fillStyle = p.color || GAME_COLORS.HEALTH_PICKUP; ctx.beginPath(); const x = p.position.x, y = p.position.y, s = p.size * 0.7; ctx.moveTo(x, y - s*0.2); ctx.bezierCurveTo(x - s*0.6, y - s*0.7, x - s*0.9, y + s*0.1, x, y + s*0.5); ctx.bezierCurveTo(x + s*0.9, y + s*0.1, x + s*0.6, y - s*0.7, x, y - s*0.2); ctx.fill(); });
                    
                    particles.forEach(p => { 
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, p.life / (p.initialLife || 100));
                        ctx.fillStyle = p.color || GAME_COLORS.PARTICLE_EXPLOSION;
                        ctx.beginPath();
                        
                        if (p.type === 'defrag_arc') {
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha *= 0.4;
                            ctx.beginPath();
                            ctx.moveTo(p.position.x, p.position.y);
                            ctx.arc(p.position.x, p.position.y, p.radius, p.startAngle, p.endAngle);
                            ctx.closePath();
                            ctx.fill();
                        }
                        else if ((p.type === 'boss_pulse' || p.type === 'aegis_pulse' || p.type === 'fear_aura_burst' || p.type === 'kernel_panic_warning' || p.type === 'kernel_panic_explosion' || p.type === 'heatsink_pulse' || p.type === 'volatile_explosion' || p.type === 'purge_sequence') && p.radius !== undefined && p.targetRadius !== undefined) {
                            ctx.strokeStyle = p.color || (p.type === 'boss_pulse' ? GAME_COLORS.BOSS_PULSE_ATTACK : (p.type === 'aegis_pulse' ? GAME_COLORS.FIREWALL_AEGIS_PULSE : (p.type === 'fear_aura_burst' ? GAME_COLORS.STATUS_FEAR_AURA : GAME_COLORS.KERNEL_PANIC_PULSE_WARNING)));
                            const lineWidth = (p.type === 'kernel_panic_warning' || p.type === 'kernel_panic_explosion') ? 4 + (p.life / (p.type === 'kernel_panic_warning' ? BOSS_STATS.kernelPanicPulseChargeTime : 500)) * 6 : 2 + (p.life / 300) * 3;
                            ctx.lineWidth = lineWidth;
    
                            let radiusToDraw;
                            if (p.type === 'kernel_panic_warning') {
                                radiusToDraw = p.radius - (lineWidth / 2);
                            } else {
                                const progress = (p.initialLife && p.life) ? (1 - (p.life / p.initialLife)) : 1;
                                radiusToDraw = Math.max(0, p.targetRadius * (progress || 0));
                            }
    
                            ctx.beginPath();
                            ctx.arc(p.position.x, p.position.y, radiusToDraw, 0, Math.PI * 2);
    
                            if(p.type === 'kernel_panic_explosion' || p.type === 'volatile_explosion' || p.type === 'aegis_pulse') {
                                ctx.fillStyle = p.color;
                                ctx.fill();
                            } else {
                                ctx.strokeStyle = p.color;
                                ctx.lineWidth = lineWidth;
                                ctx.stroke();
                            }
                        } 
                        else if (p.type === 'crit_text') {
                            ctx.font = `bold ${p.size}px "Press Start 2P"`;
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 5;
                            ctx.fillText(p.text, p.position.x, p.position.y);
                        }
                        else if (p.type === 'slow_puddle') {
                            ctx.fillStyle = p.color;
                            const progress = p.life / p.initialLife;
                            ctx.globalAlpha = Math.sin(progress * Math.PI) * 0.7;
                            ctx.beginPath();
                            ctx.arc(p.position.x, p.position.y, p.radius, 0, Math.PI*2);
                            ctx.fill();
                        }
                        else {
                            ctx.arc(p.position.x, p.position.y, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    });
                }
            }, [gameState, gameScreen, crisolGameState]);

            const gameCanvasContainerRef = useCanvasRef(null);
            useCanvasEffect(() => {
                const resize = () => {
                    if (gameCanvasContainerRef.current && canvasRef.current) {
                        const container = gameCanvasContainerRef.current;
                        const parentOfWrapper = container.parentElement;
                        if (!parentOfWrapper) return;
                        
                        const availableWidth = container.clientWidth;
                        const availableHeight = container.clientHeight;

                        const scale = Math.min(availableWidth / CANVAS_WIDTH, availableHeight / CANVAS_HEIGHT);
                        
                        canvasRef.current.style.width = `${CANVAS_WIDTH * scale}px`;
                        canvasRef.current.style.height = `${CANVAS_HEIGHT * scale}px`;
                    }
                };
                resize();
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, []); 

            return (
                React.createElement('div', { ref: gameCanvasContainerRef, className: "flex justify-center items-center w-full h-full" },
                    React.createElement('canvas', {
                        ref: canvasRef, width: CANVAS_WIDTH, height: CANVAS_HEIGHT,
                        className: `border-y-2 border-x-0 border-[${GAME_COLORS.BORDER}] bg-[${GAME_COLORS.BACKGROUND_DARK}]`,
                        style: { cursor: 'none' } 
                    })
                )
            );
        };
        // --- END OF components/GameCanvas.tsx ---
        
        const { useState, useEffect, useCallback, useRef } = React;
        
        // This is the new Main Hub layout component
        const MainLayout = ({ children }) => {
            return React.createElement('div', { className: 'w-full h-full hub-background flex' },
                children
            );
        };

        // This is the new Sidebar navigation component
        const Sidebar = ({ activeScreen, setScreen }) => {
            const navItems = [
                { screen: GameScreenState.MODE_SELECTION, label: 'Jogar', icon: '‚ñ∂Ô∏è' },
                { screen: GameScreenState.PROFILE, label: 'Perfil', icon: 'üë§' },
                { screen: GameScreenState.ARSENAL, label: 'Arsenal', icon: '‚öîÔ∏è' },
                { screen: GameScreenState.TALENT_TREE, label: 'Kernel', icon: 'üå≥' },
                { screen: GameScreenState.DECOMPILER, label: 'Decompiler', icon: 'üî¨' },
                { screen: GameScreenState.ACHIEVEMENTS, label: 'Conquistas', icon: 'üèÜ' },
                { screen: GameScreenState.RANKING, label: 'Ranking', icon: 'üìà' },
                { screen: GameScreenState.PATCH_NOTES, label: 'Patch Notes', icon: 'üìù' },
                { screen: GameScreenState.CODEX, label: 'Codex', icon: 'üìñ' },
                { screen: GameScreenState.GLOBAL_STATS, label: 'Estat√≠sticas', icon: 'üìä' },
                { screen: GameScreenState.SETTINGS, label: 'Op√ß√µes', icon: '‚öôÔ∏è' },
            ];

            return React.createElement('nav', { className: 'w-64 h-full bg-black bg-opacity-40 flex-shrink-0 p-4 flex flex-col space-y-2 border-r-2 border-gray-800' },
                React.createElement('h1', { className: 'font-press-start text-lg text-green-400 mb-4 text-center' }, 'OS Survivors'),
                navItems.map(item => (
                    React.createElement('button', {
                        key: item.screen,
                        onClick: () => { SoundManager.play('uiClick'); setScreen(item.screen); },
                        className: `w-full flex items-center p-3 rounded-md transition-all duration-200 ${activeScreen === item.screen ? 'bg-blue-600 text-white shadow-lg' : 'text-gray-400 hover:bg-gray-700 hover:text-white'}`
                    },
                        React.createElement('span', { className: 'mr-3 text-2xl' }, item.icon),
                        React.createElement('span', { className: 'font-press-start text-sm' }, item.label)
                    )
                ))
            );
        };
        
        // --- START OF NEW/UPDATED UI COMPONENTS ---

        const IntroScreen = ({ onStart }) => {
            return React.createElement('div', { className: `absolute inset-0 z-30 flex flex-col items-center justify-center text-center p-4 sm:p-6 bg-[${GAME_COLORS.UI_PANEL_BG}] border-2 border-[${GAME_COLORS.BORDER}] shadow-xl` },
                React.createElement('h1', { className: `font-press-start text-4xl sm:text-5xl md:text-6xl text-[${GAME_COLORS.TEXT_GREEN}] mt-3 mb-6 animate-pulse` }, 'OS SURVIVORS'),
                React.createElement('p', { className: "text-lg sm:text-xl max-w-2xl mb-10" }, 'O sistema foi invadido! Sobreviva √†s hordas de corrup√ß√£o e defenda o processo principal a todo custo.'),
                React.createElement('button', { onClick: onStart, className: `font-press-start bg-[${GAME_COLORS.PLAYER}] hover:bg-blue-700 text-white font-bold py-4 px-10 rounded text-2xl sm:text-3xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400 animate-fadeIn` }, 'INICIAR SISTEMA')
            );
        };
        // --- END OF components/IntroScreen.tsx ---
        
        // --- START OF components/DecompilerScreen.tsx ---
        const DecompilerScreen = ({}) => {
            const [decompilerStats, setDecompilerStats] = React.useState({});

            React.useEffect(() => {
                const storedStats = localStorage.getItem(DECOMPILER_STATS_KEY);
                if (storedStats) {
                    setDecompilerStats(JSON.parse(storedStats));
                }
            }, []);

            const getTierInfo = (kills) => {
                if (kills < DECOMPILER_TIERS.TIER_1) return { nextTierKills: DECOMPILER_TIERS.TIER_1, unlockedTiers: 0 };
                if (kills < DECOMPILER_TIERS.TIER_2) return { nextTierKills: DECOMPILER_TIERS.TIER_2, unlockedTiers: 1 };
                if (kills < DECOMPILER_TIERS.TIER_3) return { nextTierKills: DECOMPILER_TIERS.TIER_3, unlockedTiers: 2 };
                if (kills < DECOMPILER_TIERS.TIER_4) return { nextTierKills: DECOMPILER_TIERS.TIER_4, unlockedTiers: 3 };
                return { nextTierKills: DECOMPILER_TIERS.TIER_4, unlockedTiers: 4 };
            };

            const getBonusText = (unlockedTiers) => {
                if (unlockedTiers === 0) return "Nenhum B√¥nus";
                const bonus = unlockedTiers * 8;
                return `+${bonus}% Dano`;
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Decompiler de Amea√ßas'),
                React.createElement('p', { className: "text-base max-w-3xl mb-6 text-center" }, 'Derrote inimigos para analisar suas vulnerabilidades e ganhar b√¥nus de dano permanentes contra eles.'),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-4' },
                    BESTIARY_DATA.map(enemy => {
                        const kills = decompilerStats[enemy.type] || 0;
                        const { nextTierKills, unlockedTiers } = getTierInfo(kills);
                        const progressPercent = unlockedTiers === 4 ? 100 : (kills / nextTierKills) * 100;
                        
                        return React.createElement('div', { key: enemy.type, className: `p-3 rounded-lg border text-left flex flex-col space-y-2 bg-black bg-opacity-30 border-gray-700` },
                           React.createElement('div', {className: 'flex items-center space-x-3'},
                             React.createElement('div', { className: 'flex-shrink-0 rounded-sm', style: { width: `${enemy.visual.size * 1.5}px`, height: `${enemy.visual.size * 1.5}px`, backgroundColor: enemy.visual.color }}),
                             React.createElement('div', { className: 'flex-1'},
                                React.createElement('h3', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}]` }, enemy.name),
                                React.createElement('p', { className: `text-xs font-bold ${unlockedTiers > 0 ? 'text-green-400' : 'text-gray-500'}` }, `B√¥nus Atual: ${getBonusText(unlockedTiers)}`)
                             )
                           ),
                           React.createElement('div', {},
                              React.createElement('p', {className: 'text-xs text-gray-400 text-center mb-1'}, `Progresso: ${kills} / ${unlockedTiers === 4 ? DECOMPILER_TIERS.TIER_4 : nextTierKills}`),
                              React.createElement('div', { className: `w-full h-3 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}]`},
                                React.createElement('div', { className: `h-full rounded-sm bg-[${GAME_COLORS.TEXT_GREEN}]`, style: { width: `${progressPercent}%` } })
                              )
                           )
                        );
                    })
                )
            );
        };
        // --- END OF components/DecompilerScreen.tsx ---
        
        // --- START OF components/ModeSelectionScreen.tsx ---
        const ModeSelectionScreen = ({ setMainScreen, setGameScreen, onSelectMode, nightmareUnlocked }) => {
            const handleModeSelect = (mode) => {
                if (mode === 'nightmare' && !nightmareUnlocked) {
                    SoundManager.play('uiClick');
                    return;
                }
                SoundManager.play('upgradeSelect');
                onSelectMode(mode);
                setMainScreen(GameScreenState.CLASS_SELECTION);
            };

            const isNightmareLocked = !nightmareUnlocked;

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center justify-center text-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-8` }, 'Selecione o Protocolo'),
                
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-8' },
                    // Card do Modo Normal (c√≥digo id√™ntico ao anterior)
                    React.createElement('div', { 
                        onClick: () => handleModeSelect('normal'),
                        className: `p-6 rounded-lg border-4 border-cyan-500 bg-gray-800 bg-opacity-60 cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-[0_0_25px_#06b6d4]`
                    },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Modo Padr√£o'),
                        React.createElement('p', { className: 'text-sm text-gray-300 mb-4 min-h-[60px]' }, 'A experi√™ncia principal de OS Survivors. Enfrente as hordas, derrote os chefes e desbloqueie novas classes e talentos.'),
                        React.createElement('div', { className: 'space-y-2 text-left' },
                            React.createElement('p', { className: 'text-sm text-green-400' }, '‚úì Recompensa: N√∫cleos de Sistema'),
                            React.createElement('p', { className: 'text-sm text-gray-500' }, '‚úó Recompensa: N√∫cleos Corrompidos')
                        )
                    ),

                    // Card do Modo Pesadelo (c√≥digo id√™ntico ao anterior)
                    React.createElement('div', {
                        onClick: () => handleModeSelect('nightmare'),
                        className: `p-6 rounded-lg border-4 bg-gray-800 bg-opacity-60 transition-all duration-200 ${isNightmareLocked 
                            ? 'border-gray-600 grayscale opacity-70 cursor-not-allowed' 
                            : 'border-red-600 cursor-pointer hover:scale-105 hover:shadow-[0_0_25px_#dc2626] animate-pulse'}`
                    },
                        React.createElement('h2', { className: 'font-press-start text-xl text-red-400 mb-3 flex items-center justify-center' }, 'Modo Pesadelo', isNightmareLocked && React.createElement('span', {className: 'ml-2 text-2xl'},'üîí')),
                        React.createElement('p', { className: 'text-sm text-gray-300 mb-4 min-h-[60px]' }, 'Um desafio extremo para veteranos. Inimigos s√£o mais fortes e numerosos. Recompensas maiores aguardam.'),
                        React.createElement('div', { className: 'space-y-2 text-left' },
                            React.createElement('p', { className: 'text-sm text-green-400' }, '‚úì Recompensa: N√∫cleos de Sistema'),
                            React.createElement('p', { className: `text-sm ${isNightmareLocked ? 'text-gray-500' : 'text-green-400'}` }, '‚úì Recompensa: N√∫cleos Corrompidos')
                        ),
                        isNightmareLocked && React.createElement('p', { className: 'text-xs text-red-500 mt-4 font-bold' }, 'Ven√ßa o jogo (derrote o Nexus) para desbloquear.')
                    ),
                    
                    // --- NOVO CARD DO CRISOL ---
                    // Este √© o novo elemento que adicionamos.
                    React.createElement('div', {
                        onClick: () => { SoundManager.play('upgradeSelect'); setMainScreen(GameScreenState.CRISOL_HUB); }, // A a√ß√£o dele √© mudar a tela para o Hub do Crisol.
                        className: 'p-6 rounded-lg border-4 border-purple-500 bg-gray-800 bg-opacity-60 cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-[0_0_25px_#8b5cf6] md:col-span-2' // Ocupa a largura toda.
                    },
                        React.createElement('h2', { className: 'font-press-start text-xl text-purple-300 mb-3' }, 'O Crisol do Kernel'),
                        React.createElement('p', { className: 'text-sm text-gray-300 mb-4' }, 'Um modo de desafio focado puramente em habilidade de desvio. Sem upgrades, sem sorte. Apenas seus reflexos contra padr√µes de ataque coreografados. Conclua c√¢maras para ganhar recompensas e desbloquear o modo infinito.'),
                        React.createElement('div', { className: 'space-y-2 text-left' },
                            React.createElement('p', { className: 'text-sm text-green-400' }, '‚úì Recompensas: N√∫cleos de Sistema e Corrompidos (Primeira conclus√£o)'),
                            React.createElement('p', { className: 'text-sm text-yellow-400' }, '‚úì Requer: Habilidade Pura')
                        )
                    )
                )
            );
        };
        // --- END OF components/ModeSelectionScreen.tsx ---

        // --- START OF components/ClassSelectionScreen.tsx ---
        const ClassSelectionScreen = ({ setMainScreen, systemCores, classes, selectedClassId, unlockedClasses, onSelectClass, onUnlockClass }) => {
            const handleContinue = () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.SKIN_SELECTION); };
            const handleEvolutionGuide = () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.EVOLUTION_GUIDE); };
            const getWeaponTitle = (weaponId) => { if (!weaponId) return "Nenhuma"; return (UPGRADE_POOL.find(upg => upg.id === `weapon_${weaponId}`)?.title.replace("Instalar ", "") || weaponId); };
            
            const formatStatModifier = (value, isPercent = false, isFactor = false) => {
                if (typeof value !== 'number' || value === 0 || isNaN(value)) return null;

                const sign = value > 0 ? '+' : '';
                const color = value > 0 ? 'text-green-400' : 'text-red-400';
                let displayValue;
                if (isFactor) {
                    displayValue = `${sign}${(value * 100).toFixed(0)}%`;
                } else if (isPercent) {
                    displayValue = `${sign}${value.toFixed(0)}%`;
                } else {
                    displayValue = `${sign}${value.toFixed(0)}`;
                }
                return React.createElement('span', { className: color }, displayValue);
            };

            const selectedClass = classes.find(c => c.id === selectedClassId) || classes[0];

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Prepara√ß√£o de Sistema'),
                React.createElement('p', { className: "text-base max-w-3xl mb-4" }, 'Escolha uma classe para definir seu estilo de jogo. Desbloqueie novas classes com N√∫cleos de Sistema.'),
                React.createElement('div', { className: 'mb-4 text-lg' }, React.createElement('span', { className: 'font-press-start text-yellow-300' }, 'N√∫cleos de Sistema: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}] font-bold` }, systemCores)),
                
                React.createElement('div', { className: 'w-full max-w-6xl flex flex-col lg:flex-row gap-6 mb-6 flex-grow' },
                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Selecione a Classe'),
                        React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
                            classes.map(cls => {
                                const isSelected = cls.id === selectedClassId; const isUnlocked = unlockedClasses.has(cls.id); const canAfford = systemCores >= cls.unlockCost;
                                return React.createElement('div', { key: cls.id, className: `p-3 rounded-lg border-2 text-left transition-all duration-150 ${isSelected ? `border-[${GAME_COLORS.PLAYER}] shadow-[0_0_15px_var(--player-color)] scale-105` : `border-[${GAME_COLORS.BORDER}]`} ${isUnlocked ? 'bg-gray-800 bg-opacity-60 cursor-pointer hover:border-gray-500' : 'bg-gray-900 bg-opacity-80'}`, style: { ['--player-color']: GAME_COLORS.PLAYER }, onClick: () => { if (isUnlocked) { SoundManager.play('uiClick'); onSelectClass(cls.id); } }, role: "button", tabIndex: isUnlocked ? 0 : -1, "aria-pressed": isSelected, "aria-label": `Selecionar Classe ${cls.name}` },
                                    React.createElement('div', { className: "flex items-center mb-1" }, React.createElement('div', { style: { width: '12px', height: '12px', backgroundColor: cls.iconColor || GAME_COLORS.TEXT, borderRadius: '2px', marginRight: '8px' } }), React.createElement('h3', { className: `font-press-start text-sm ${isSelected ? `text-[${GAME_COLORS.PLAYER}]` : `text-[${GAME_COLORS.TEXT_YELLOW}]`}` }, cls.name)),
                                    !isUnlocked ? 
                                        React.createElement('button', { onClick: (e) => { e.stopPropagation(); if (canAfford) { SoundManager.play('kernelUnlock'); onUnlockClass(cls.id, cls.unlockCost); } else { SoundManager.play('uiClick'); } }, disabled: !canAfford, className: `font-press-start w-full mt-2 py-2 px-2 rounded text-xs ${canAfford ? `bg-green-600 hover:bg-green-700 text-white` : `bg-gray-700 text-gray-500 cursor-not-allowed`}` }, `Desbloquear (${cls.unlockCost} `, React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}]` }, 'N'), ')')
                                        : isSelected ? React.createElement('p', { className: `text-center font-press-start text-xs text-[${GAME_COLORS.PLAYER}] mt-2` }, "SELECIONADO") : React.createElement('p', { className: "text-center text-xs text-gray-500 mt-2" }, "(Clique para selecionar)")
                                );
                            })
                        )
                    ),

                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Preview do Sistema'),
                        React.createElement('div', { className: `p-4 rounded-lg border-2 text-left bg-gray-800 bg-opacity-60 border-[${GAME_COLORS.BORDER}] flex-grow` },
                            React.createElement('div', { className: 'flex justify-between items-start mb-3' },
                                React.createElement('h3', { className: `font-press-start text-lg text-[${GAME_COLORS.PLAYER}]` }, selectedClass.name),
                                React.createElement('div', { style: { width: '32px', height: '32px', backgroundColor: selectedClass.iconColor, borderRadius: '4px', border: '2px solid #c9d1d9' }})
                            ),
                            React.createElement('p', { className: 'text-sm text-gray-300 mb-4 leading-tight' }, selectedClass.description),
                            React.createElement('div', { className: 'space-y-2 text-sm' },
                                React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Arma Inicial: '), React.createElement('span', { className: 'text-cyan-400' }, getWeaponTitle(selectedClass.startingWeaponId))),
                                selectedClass.uniquePassive && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Passiva √önica (', React.createElement('span', {className: 'text-purple-400'}, selectedClass.uniquePassive.name), '): '), React.createElement('span', { className: 'italic text-gray-400' }, selectedClass.uniquePassive.description)),
                                React.createElement('div', { className: 'flex flex-wrap gap-x-4' },
                                    formatStatModifier(selectedClass.statModifiers.baseMaxHealth) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'HP M√°x: '), formatStatModifier(selectedClass.statModifiers.baseMaxHealth)),
                                    formatStatModifier(selectedClass.statModifiers.baseSpeed, false, false) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Velocidade: '), formatStatModifier(selectedClass.statModifiers.baseSpeed, false, false)),
                                    formatStatModifier(selectedClass.statModifiers.baseExpModifier, false, true) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Ganho XP: '), formatStatModifier(selectedClass.statModifiers.baseExpModifier, false, true)),
                                    formatStatModifier(selectedClass.statModifiers.baseXpMagnetRadius, false, false) && React.createElement('p', null, React.createElement('strong', { className: 'text-gray-400' }, 'Alcance Coleta: '), formatStatModifier(selectedClass.statModifiers.baseXpMagnetRadius, false, false))
                                )
                            )
                        )
                    )
                ),
                
                 React.createElement('div', { className: 'flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-4' },
                    React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.MODE_SELECTION); }, className: `font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-400` }, 'Voltar'),
                    React.createElement('button', { onClick: handleEvolutionGuide, className: `font-press-start bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-400` }, 'Guia de Evolu√ß√µes'),
                    React.createElement('button', { onClick: handleContinue, className: `font-press-start bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-400` }, 'Selecionar Skin')
                )
            );
        };
        // --- END OF components/ClassSelectionScreen.tsx ---

        // --- START OF components/EvolutionGuideScreen.tsx ---
        const EvolutionGuideScreen = ({ setMainScreen }) => {
            const getUpgradeTitle = (upgradeId) => {
                const upgrade = UPGRADE_POOL.find(u => u.id === upgradeId);
                return upgrade ? upgrade.title : upgradeId;
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-4` }, 'Guia de Evolu√ß√µes'),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-4 mb-6 flex-grow overflow-y-auto' },
                    WEAPON_EVOLUTIONS.map(evo => {
                        const baseWeapon = UPGRADE_POOL.find(u => u.id === `weapon_${evo.baseWeaponId}`);
                        const catalyst = UPGRADE_POOL.find(u => u.id === evo.catalystPassiveId);

                        return React.createElement('div', { key: evo.evolutionId, className: `p-4 rounded-lg border-2 text-left flex flex-col space-y-2 bg-black bg-opacity-30 border-[${GAME_COLORS.UPGRADE_CARD_EVOLUTION_BORDER}]` },
                            React.createElement('h2', { className: `font-press-start text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, evo.name),
                            React.createElement('div', { className: 'flex items-center justify-center space-x-4 my-2' },
                                React.createElement('span', { className: 'font-press-start text-sm text-cyan-400' }, baseWeapon.title.replace("Instalar ", "")),
                                React.createElement('span', { className: 'text-2xl text-white' }, '+'),
                                React.createElement('span', { className: 'font-press-start text-sm text-purple-400' }, catalyst.title)
                            ),
                            React.createElement('div', {},
                                React.createElement('p', { className: 'font-press-start text-sm text-gray-300 mb-1' }, 'Requisitos:'),
                                React.createElement('ul', { className: 'list-disc list-inside pl-2 text-sm text-gray-400' },
                                    evo.requiredUpgradeIds.map(req => React.createElement('li', { key: req.id }, `${getUpgradeTitle(req.id)} (N√≠vel ${req.level})`))
                                )
                            ),
                            React.createElement('p', { className: 'text-sm italic text-gray-500 mt-2' }, `Efeito: ${evo.description}`)
                        );
                    })
                ),
                React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.CLASS_SELECTION); }, className: `mt-4 font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105` }, 'VOLTAR')
            );
        };
        // --- END OF components/EvolutionGuideScreen.tsx ---

        // --- START OF components/SkinSelectionScreen.tsx ---
        const SkinSelectionScreen = ({ setMainScreen, startGame, systemCores, corruptedKernels, unlockedSkins, equippedSkinId, onEquipSkin, onUnlockSkin, onUnlockSkinCorrupted }) => {
            const { useState, useEffect, useRef } = React;
            
            const [previewSkinId, setPreviewSkinId] = useState(equippedSkinId);
            const previewCanvasRef = useRef(null);
            
            useEffect(() => {
                setPreviewSkinId(equippedSkinId);
            }, [equippedSkinId]);
            
            useEffect(() => {
                const canvas = previewCanvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                let animationFrameId;

                const skinToDraw = SKIN_DEFINITIONS.find(s => s.id === previewSkinId) || SKIN_DEFINITIONS[0];
                const playerLikeObject = {
                    position: { x: canvas.width / 2, y: canvas.height / 2 },
                    size: 80,
                    color: '#2f81f7',
                    skinId: previewSkinId
                };

                const render = (time) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (skinToDraw.draw) {
                        skinToDraw.draw(ctx, playerLikeObject, { time });
                    }
                    animationFrameId = requestAnimationFrame(render);
                };

                render(performance.now());
                return () => cancelAnimationFrame(animationFrameId);
            }, [previewSkinId]);

            const handlePurchase = (e, skin) => {
                e.stopPropagation();
                if(skin.unlockCondition.type === 'cost' && systemCores >= skin.unlockCondition.value) {
                    SoundManager.play('kernelUnlock');
                    onUnlockSkin(skin.id, skin.unlockCondition.value);
                } else if (skin.unlockCondition.type === 'cost_corrupted' && corruptedKernels >= skin.unlockCondition.value) {
                    SoundManager.play('kernelUnlock');
                    onUnlockSkinCorrupted(skin.id, skin.unlockCondition.value);
                } else {
                    SoundManager.play('uiClick');
                }
            };
            
            const handleEquipClick = (skinId) => {
                SoundManager.play('upgradeSelect');
                onEquipSkin(skinId);
            };

            const getRarityColor = (rarity) => {
                switch (rarity) {
                    case 'Comum': return 'text-gray-400';
                    case 'Rara': return 'text-blue-400';
                    case '√âpica': return 'text-purple-400';
                    case 'Lend√°ria': return 'text-orange-400';
                    case 'M√≠tica': return 'text-red-500';
                    default: return 'text-white';
                }
            };
            
            const skinToPreview = SKIN_DEFINITIONS.find(s => s.id === previewSkinId) || SKIN_DEFINITIONS[0];
            const isPreviewUnlocked = unlockedSkins.has(skinToPreview.id);
            const isPreviewEquipped = skinToPreview.id === equippedSkinId;
            const isPurchasableSystem = skinToPreview.unlockCondition.type === 'cost';
            const isPurchasableCorrupted = skinToPreview.unlockCondition.type === 'cost_corrupted';
            const canAffordSystem = isPurchasableSystem && systemCores >= skinToPreview.unlockCondition.value;
            const canAffordCorrupted = isPurchasableCorrupted && corruptedKernels >= skinToPreview.unlockCondition.value;

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Apar√™ncia do Processo'),
                 React.createElement('div', { className: 'flex items-center space-x-6 mb-4 text-lg' }, 
                    React.createElement('div', null, React.createElement('span', { className: 'font-press-start text-yellow-300' }, 'S: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}] font-bold` }, systemCores)),
                    React.createElement('div', null, React.createElement('span', { className: 'font-press-start text-purple-400' }, 'C: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}] font-bold` }, corruptedKernels))
                ),
                
                React.createElement('div', { className: 'w-full max-w-7xl flex flex-col lg:flex-row gap-6 flex-grow overflow-hidden' },
                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col overflow-hidden' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-3' }, 'Galeria de Skins'),
                        React.createElement('div', { id: 'skin-list-container', className: 'flex-grow overflow-y-auto space-y-2 pr-2' },
                            SKIN_DEFINITIONS.map(skin => {
                                const isSelectedForPreview = skin.id === previewSkinId;
                                const isUnlocked = unlockedSkins.has(skin.id);

                                return React.createElement('div', { 
                                    key: skin.id,
                                    className: `p-4`,
                                }, 
                                    React.createElement('button', {
                                        onClick: () => { SoundManager.play('uiClick'); setPreviewSkinId(skin.id); },
                                        className: `w-full p-2 rounded-lg border-2 text-left flex justify-between items-center transition-all duration-200 ${isSelectedForPreview ? `border-yellow-400 scale-105 shadow-[0_0_15px_#facc15]` : `border-[${GAME_COLORS.BORDER}] hover:border-gray-500`} ${isUnlocked ? `bg-gray-800` : `bg-gray-900 opacity-80`}`,
                                    },
                                        React.createElement('div', {},
                                            React.createElement('h3', { className: `font-press-start text-sm ${isUnlocked ? 'text-white' : 'text-gray-500'}` }, skin.name),
                                            React.createElement('p', { className: `text-xs mt-1 ${getRarityColor(skin.rarity)}` }, skin.rarity)
                                        ),
                                        !isUnlocked && React.createElement('span', { className: 'text-2xl text-gray-600' }, 'üîí')
                                    )
                                );
                            })
                        )
                    ),

                    React.createElement('div', { className: 'lg:w-1/2 flex flex-col items-center' },
                        React.createElement('div', { className: 'w-full max-w-xs aspect-square bg-black rounded-lg border-2 border-gray-700 mb-4 flex items-center justify-center' },
                            React.createElement('canvas', { ref: previewCanvasRef, width: '200', height: '200' })
                        ),
                        React.createElement('div', { className: 'text-center mb-4' },
                            React.createElement('h3', { className: 'font-press-start text-lg text-yellow-300' }, skinToPreview.name),
                            React.createElement('p', { className: `text-sm mt-1 ${getRarityColor(skinToPreview.rarity)}` }, skinToPreview.rarity),
                            React.createElement('p', { className: 'text-sm text-gray-400 mt-2 max-w-xs' }, React.createElement('strong', { className: 'text-gray-300'}, 'Desbloqueio: '), skinToPreview.unlockHint)
                        ),
                        React.createElement('div', { className: 'w-full max-w-xs mb-6' },
                             isPreviewUnlocked ? 
                                (isPreviewEquipped ?
                                    React.createElement('button', { disabled: true, className: 'font-press-start w-full bg-gray-600 text-gray-400 font-bold py-3 px-6 rounded text-lg' }, 'Equipado')
                                    :
                                    React.createElement('button', { onClick: () => handleEquipClick(skinToPreview.id), className: 'font-press-start w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105' }, 'Equipar')
                                )
                            : isPurchasableSystem ? 
                                React.createElement('button', {
                                    onClick: (e) => handlePurchase(e, skinToPreview),
                                    disabled: !canAffordSystem,
                                    className: `font-press-start w-full font-bold py-3 px-6 rounded text-lg transition-transform duration-150 ${canAffordSystem ? 'bg-blue-600 hover:bg-blue-700 text-white hover:scale-105' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`
                                }, `Desbloquear (${skinToPreview.unlockCondition.value}`, React.createElement('span', {className: 'text-yellow-300'}, 'S'), ')')
                            : isPurchasableCorrupted ?
                                React.createElement('button', {
                                    onClick: (e) => handlePurchase(e, skinToPreview),
                                    disabled: !canAffordCorrupted,
                                    className: `font-press-start w-full font-bold py-3 px-6 rounded text-lg transition-transform duration-150 ${canAffordCorrupted ? 'bg-purple-600 hover:bg-purple-700 text-white hover:scale-105' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`
                                }, `Desbloquear (${skinToPreview.unlockCondition.value}`, React.createElement('span', {className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}]`}, 'C'), ')')
                            :
                                React.createElement('button', { disabled: true, className: 'font-press-start w-full bg-red-800 text-red-300 font-bold py-3 px-6 rounded text-lg' }, 'Bloqueado')
                        ),
                        
                        React.createElement('div', { className: 'mt-auto flex flex-col sm:flex-row gap-4' },
                            React.createElement('button', { onClick: () => setMainScreen(GameScreenState.CLASS_SELECTION), className: `font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-400` }, 'Voltar'),
                                                        React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.MODIFIER_SELECTION); }, className: `font-press-start bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-400` }, 'Configurar Modificadores'),
                        )
                    )
                ),
            );
        };
        // --- END OF components/SkinSelectionScreen.tsx ---

        // --- START OF components/ModifierSelectionScreen.tsx ---
        const ModifierSelectionScreen = ({ setMainScreen, startGameWithModifiers }) => {
            const [activeModifiers, setActiveModifiers] = useState(new Set());
            const [instabilityIndex, setInstabilityIndex] = useState(0);

            const toggleModifier = (mod) => {
                SoundManager.play('uiClick');
                const newActiveModifiers = new Set(activeModifiers);
                let newIndex = instabilityIndex;

                if (newActiveModifiers.has(mod.id)) {
                    newActiveModifiers.delete(mod.id);
                    newIndex -= mod.points;
                } else {
                    newActiveModifiers.add(mod.id);
                    newIndex += mod.points;
                }
                setActiveModifiers(newActiveModifiers);
                setInstabilityIndex(newIndex);
            };

            const canStartModified = instabilityIndex >= 0;

            return React.createElement('div', { className: 'w-full h-full flex flex-col items-center p-6 animate-fadeIn' },
                React.createElement('h1', { className: 'font-press-start text-3xl text-green-400 mb-2' }, 'Terminal de Modificadores'),
                React.createElement('p', { className: 'text-base max-w-3xl mb-4 text-center' }, 'Adicione dificuldade para ganhar pontos e use-os para comprar buffs. √çndice de Instabilidade deve ser 0 ou mais.'),
                
                React.createElement('div', { className: 'w-full max-w-6xl p-4 bg-black/40 border border-gray-700 rounded-lg mb-4' },
                    React.createElement('h2', { className: `font-press-start text-xl text-center ${instabilityIndex < 0 ? 'text-red-500 animate-pulse' : 'text-cyan-300'}` }, '√çndice de Instabilidade: ', instabilityIndex)
                ),

                React.createElement('div', { className: 'w-full max-w-6xl grid grid-cols-1 lg:grid-cols-2 gap-6 flex-grow overflow-y-auto' },
                    // Coluna de Debuffs (Dificultadores)
                    React.createElement('div', { className: 'p-4 bg-red-900/10 border-2 border-red-800 rounded-lg overflow-y-auto' },
                        React.createElement('h2', { className: 'font-press-start text-lg text-red-400 mb-3 text-center' }, 'Dificultadores (+Pontos)'),
                        React.createElement('div', { className: 'space-y-2' },
                            MODIFIER_DEFINITIONS.filter(m => m.points > 0).map(mod => React.createElement('button', { key: mod.id, onClick: () => toggleModifier(mod), className: `w-full p-2 rounded-md text-left transition-all ${activeModifiers.has(mod.id) ? 'bg-red-500 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}` },
                                React.createElement('div', { className: 'flex justify-between items-center' },
                                    React.createElement('span', { className: 'font-VT323 text-base' }, mod.name),
                                    React.createElement('span', { className: 'font-press-start text-sm' }, `+${mod.points}`)
                                ),
                                React.createElement('p', { className: 'text-xs text-gray-400 mt-1 italic' }, mod.description)
                            ))
                        )
                    ),
                    // Coluna de Buffs (Facilitadores)
                    React.createElement('div', { className: 'p-4 bg-green-900/10 border-2 border-green-800 rounded-lg overflow-y-auto' },
                        React.createElement('h2', { className: 'font-press-start text-lg text-green-400 mb-3 text-center' }, 'Facilitadores (-Pontos)'),
                        React.createElement('div', { className: 'space-y-2' },
                            MODIFIER_DEFINITIONS.filter(m => m.points < 0).map(mod => React.createElement('button', { key: mod.id, onClick: () => toggleModifier(mod), className: `w-full p-2 rounded-md text-left transition-all ${activeModifiers.has(mod.id) ? 'bg-green-500 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}` },
                                React.createElement('div', { className: 'flex justify-between items-center' },
                                    React.createElement('span', { className: 'font-VT323 text-base' }, mod.name),
                                    React.createElement('span', { className: 'font-press-start text-sm' }, `${mod.points}`)
                                ),
                                React.createElement('p', { className: 'text-xs text-gray-400 mt-1 italic' }, mod.description)
                            ))
                        )
                    )
                ),

                React.createElement('div', { className: 'mt-6 flex flex-col sm:flex-row items-center gap-4' },
                    React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); setMainScreen(GameScreenState.SKIN_SELECTION); }, className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg' }, 'Voltar'),
                    React.createElement('button', { onClick: () => { SoundManager.play('uiClick'); startGameWithModifiers(new Set()); }, className: 'font-press-start bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded text-lg' }, 'Iniciar Padr√£o'),
                    React.createElement('button', { onClick: () => canStartModified && startGameWithModifiers(activeModifiers), disabled: !canStartModified, className: `font-press-start font-bold py-3 px-6 rounded text-lg transition-transform duration-150 ${canStartModified ? 'bg-green-600 hover:bg-green-700 text-white hover:scale-105' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}` }, 'Iniciar Modificado')
                )
            );
        };
        // --- END OF components/ModifierSelectionScreen.tsx ---

        // --- START OF components/GameOverScreen.tsx ---
        const GameOverScreen = ({ setMainScreen, setGameScreen, score = 0, gameTime = 0 }) => {
            const handleReturnToHub = () => {
                SoundManager.play('uiClick');
                setMainScreen(GameScreenState.MODE_SELECTION);
                setGameScreen(GameScreenState.MODE_SELECTION);
            };

            return React.createElement('div', { className: `absolute inset-0 z-20 flex flex-col items-center justify-center text-center p-4 bg-black bg-opacity-80 shadow-xl` },
                React.createElement('h2', { className: `font-press-start text-4xl sm:text-5xl text-[${GAME_COLORS.TEXT_RED}] mb-4 animate-pulse` }, 'PROCESSO FINALIZADO!'),
                React.createElement('p', { className: "text-xl sm:text-2xl mb-2" }, 'System halted.'),
                React.createElement('p', { className: "text-lg sm:text-xl mb-2" }, 'Sobreviveu por: ', React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_YELLOW}]` }, formatTime(gameTime))),
                React.createElement('p', { className: "text-lg sm:text-xl mb-6" }, 'Pontua√ß√£o Final: ', React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_YELLOW}]` }, score)),
                React.createElement('div', { className: "flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4" },
                    React.createElement('button', { onClick: handleReturnToHub, className: `font-press-start bg-[${GAME_COLORS.PLAYER}] hover:bg-blue-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400` }, 'VOLTAR AO HUB')
                )
            );
        };
        // --- END OF components/GameOverScreen.tsx ---

               // --- START OF components/RankingScreen.tsx ---
        const RankingScreen = ({}) => {
            const { useEffect, useState } = React;
            const [view, setView] = useState('local'); // 'local' ou 'online'
            const [localRankings, setLocalRankings] = useState([]);
            const [onlineRankings, setOnlineRankings] = useState([]);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);

            useEffect(() => {
                try {
                    const storedRankingsRaw = localStorage.getItem(RANKING_KEY);
                    setLocalRankings(storedRankingsRaw ? JSON.parse(storedRankingsRaw) : []);
                } catch (err) {
                    console.error("Error loading local rankings:", err);
                    setLocalRankings([]);
                }
            }, []);

            const handleFetchOnline = async () => {
                // Se j√° carregamos e n√£o h√° erro, apenas mude a vis√£o
                if (onlineRankings.length > 0 && !error) {
                    setView('online');
                    return;
                }
                
                setView('online');
                setLoading(true);
                setError(null);
                try {
                    const data = await fetchOnlineRankings();
                    setOnlineRankings(data);
                } catch (err) {
                    setError('Falha ao carregar o ranking online.');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            };
            
            const handleSetViewLocal = () => {
                setView('local');
            };

            // Fun√ß√£o para obter o nome da classe - SIMPLIFICADA E ROBUSTA
            const getClassNameById = (entry) => {
                // Pega o ID da entrada, verificando primeiro por 'class_id' e depois por 'classId' como fallback.
                const classIdentifier = entry.class_id || entry.classId;

                // Se n√£o houver nenhum identificador, retorna N/A imediatamente.
                if (!classIdentifier || typeof classIdentifier !== 'string') {
                    // Opcional: Log para depura√ß√£o de entradas antigas sem ID.
                    // console.warn("Entrada de ranking sem ID de classe:", entry);
                    return "N/A";
                }
                
                const trimmedId = classIdentifier.trim();
                const foundClass = CLASS_DEFINITIONS.find(c => c.id === trimmedId);
                
                if (foundClass) {
                    return foundClass.name;
                }
                
                // Log de erro apenas se um ID foi fornecido mas n√£o encontrado.
                console.error(`Classe n√£o encontrada para o ID: "${trimmedId}". Verifique se o ID existe em CLASS_DEFINITIONS.`);
                return "N/A";
            };

            const rankingsToDisplay = view === 'local' ? localRankings : onlineRankings;

            const renderTable = (data) => {
                if (loading) {
                    return React.createElement('p', { className: `text-lg text-[${GAME_COLORS.TEXT_YELLOW}] animate-pulse` }, 'Carregando ranking online...');
                }
                if (error) {
                    return React.createElement('p', { className: `text-lg text-[${GAME_COLORS.TEXT_RED}]` }, error);
                }
                if (data.length === 0) {
                    return React.createElement('p', { className: `text-lg text-[${GAME_COLORS.TEXT_YELLOW}]` }, 'Nenhum registro encontrado.');
                }
                return React.createElement('table', { className: 'w-full text-left table-auto' }, 
                    React.createElement('thead', null, React.createElement('tr', { className: `border-b-2 border-[${GAME_COLORS.BORDER}]` }, 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2` }, '#'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2` }, 'Nome'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right` }, 'Pontos'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right hidden sm:table-cell` }, 'Tempo'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 hidden md:table-cell` }, 'Classe'), 
                        React.createElement('th', { className: `font-press-start text-sm text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right hidden sm:table-cell` }, 'Data') 
                    )), 
                    React.createElement('tbody', null, data.map((entry, index) => ( 
                        React.createElement('tr', { key: (entry.id || index), className: `border-b border-[${GAME_COLORS.BORDER}] last:border-b-0 hover:bg-gray-700 bg-opacity-50` }, 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2` }, index + 1), 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_GREEN}] p-2` }, entry.name), 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}] p-2 text-right` }, entry.score.toLocaleString()), 
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2 text-right hidden sm:table-cell` }, formatTime(entry.time)), 
                            // A chamada para a fun√ß√£o robusta est√° aqui
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2 hidden md:table-cell` }, getClassNameById(entry)),
                            React.createElement('td', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT}] p-2 text-right hidden sm:table-cell` }, entry.date) 
                        ) 
                    ))) 
                );
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-4 animate-pulse` }, 'Hall dos Sobreviventes'),
                
                React.createElement('div', { className: 'flex space-x-4 mb-6' },
                    React.createElement('button', {
                        onClick: handleSetViewLocal,
                        className: `font-press-start py-2 px-4 rounded text-sm transition-colors duration-200 ${view === 'local' ? `bg-[${GAME_COLORS.PLAYER}] text-white` : `bg-gray-700 text-gray-300 hover:bg-gray-600`}`
                    }, 'Local'),
                    React.createElement('button', {
                        onClick: handleFetchOnline,
                        className: `font-press-start py-2 px-4 rounded text-sm transition-colors duration-200 ${view === 'online' ? `bg-[${GAME_COLORS.PLAYER}] text-white` : `bg-gray-700 text-gray-300 hover:bg-gray-600`}`
                    }, 'Online')
                ),

                React.createElement('div', { className: 'w-full max-w-4xl bg-black bg-opacity-40 p-4 rounded-lg shadow-inner border border-gray-700 mb-6 min-h-[300px] flex items-center justify-center' },
                   renderTable(rankingsToDisplay)
                )
            );
        };
        // --- END OF components/RankingScreen.tsx ---
        
        // --- START OF components/GlobalStatsScreen.tsx ---
        const GlobalStatsScreen = ({ permanentBuffs, achievementBuffs }) => {
            const { useEffect: useEffectGlobalStats, useState: useStateGlobalStats } = React;
            const [globalStats, setGlobalStats] = useStateGlobalStats({ totalKills: 0, totalTimePlayed: 0, highestScore: 0, highestLevel: 0, totalBossKills: {}, gamesPlayed: 0, totalXpOrbsCollected: 0, totalDashes: 0, totalHealthPickupsCollected: 0, totalCorruptedKernelsEarned: 0, totalCorruptedLibrariesCleansed: 0, totalEnemyKills: {}, totalEvolutionsUnlocked: {} });
            
            useEffectGlobalStats(() => {
                const storedStatsRaw = localStorage.getItem(GLOBAL_STATS_KEY);
                if (storedStatsRaw) {
                    const parsed = JSON.parse(storedStatsRaw);
                    if (typeof parsed.totalBossKills !== 'object' || parsed.totalBossKills === null) {
                        parsed.totalBossKills = {};
                    }
                    setGlobalStats(parsed);
                }
            }, []);

            const [totalBuffs, setTotalBuffs] = useStateGlobalStats({});

            useEffectGlobalStats(() => {
                const calculatedBuffs = {
                    maxHealth: 0,
                    speedPercent: 0,
                    speedFlat: 0,
                    expModifier: 0,
                    cooldownModifier: 0,
                    globalDamageFactor: 0,
                    damageReduction: 0,
                    initialRerolls: 0,
                    statusEffectDuration: 0,
                    xpMagnetRadius: 0,
                    dashCooldown: 0,
                    critChance: 0,
                    critDamage: 0,
                    regenAmount: 0,
                    dotDamageReduction: 0,
                    dashDuration: 0,
                    projectileRangeAndSpeed: 0,
                };

                let hpBonusMultiplierFromTalents = 1.0;

                const allTalents = TALENT_TREE_CONFIG;

                allTalents.forEach(talent => {
                    const level = permanentBuffs.shop[talent.id] || 0;
                    if (level > 0) {
                        const totalBonus = talent.bonusPerLevel * level;
                        switch (talent.statAffected) {
                            case 'speed': calculatedBuffs.speedPercent += totalBonus; break;
                            case 'maxHealth': calculatedBuffs.maxHealth += totalBonus; break;
                            case 'expModifier': calculatedBuffs.expModifier += totalBonus; break;
                            case 'cooldownModifier': calculatedBuffs.cooldownModifier -= totalBonus; break;
                            case 'damageReduction': calculatedBuffs.damageReduction += totalBonus; break;
                            case 'globalDamageFactor': calculatedBuffs.globalDamageFactor += totalBonus; break;
                            case 'regenAmount': calculatedBuffs.regenAmount += totalBonus; break;
                            case 'statusEffectDuration': calculatedBuffs.statusEffectDuration += totalBonus; break;
                            case 'projectileSpeed': calculatedBuffs.projectileRangeAndSpeed += totalBonus; break;
                            case 'critChance': calculatedBuffs.critChance += totalBonus; break;
                            case 'critDamage': calculatedBuffs.critDamage += totalBonus; break;
                            case 'dashDuration': calculatedBuffs.dashDuration += totalBonus; break;
                            case 'xpMagnetRadius': calculatedBuffs.xpMagnetRadius += totalBonus; break;
                            case 'initialRerolls': calculatedBuffs.initialRerolls += totalBonus; break;
                            case 'redundancyProtocol':
                                if (level > 0) {
                                    calculatedBuffs.damageReduction += 0.05;
                                    calculatedBuffs.regenAmount += 1.5;
                                }
                                break;
                            case 'ultimate':
                            case 'ultimateCorrupted':
                                if (level > 0) {
                                    calculatedBuffs.globalDamageFactor += totalBonus;
                                    calculatedBuffs.maxHealth += PLAYER_INITIAL_STATS.baseMaxHealth * totalBonus; // Assume b√¥nus sobre o base
                                    calculatedBuffs.speedPercent += totalBonus;
                                }
                                break;
                            case 'hpBonusMultiplier': hpBonusMultiplierFromTalents += totalBonus; break;
                            case 'dotDamageReduction': calculatedBuffs.dotDamageReduction += 0.15 + (level-1) * 0.1; break;
                            case 'dashCooldownAndDuration':
                                const dashTalentInfo = allTalents.find(t => t.id === talent.id);
                                if(dashTalentInfo) {
                                    calculatedBuffs.dashCooldown -= dashTalentInfo.bonusPerLevel.cooldown * level;
                                    calculatedBuffs.dashDuration += dashTalentInfo.bonusPerLevel.duration * level;
                                }
                                break;
                            case 'baseDamage': calculatedBuffs.globalDamageFactor += totalBonus; break;
                            case 'projectileRange': calculatedBuffs.projectileRangeAndSpeed += totalBonus; break;
                            case 'protocolRewrite': if(level > 0) calculatedBuffs.initialRerolls += 1; break;
                        }
                    }
                });

                Object.keys(achievementBuffs).forEach(stat => {
                    const bonus = achievementBuffs[stat];
                    switch (stat) {
                        case 'speed': calculatedBuffs.speedFlat += bonus; break;
                        case 'maxHealth': 
                             if (stat === 'maxHealth' && bonus < 1) { 
                                calculatedBuffs.maxHealth += PLAYER_INITIAL_STATS.baseMaxHealth * bonus;
                            } else {
                                calculatedBuffs.maxHealth += bonus;
                            }
                            break;
                        case 'expModifier': calculatedBuffs.expModifier += bonus; break;
                        case 'cooldownModifier': calculatedBuffs.cooldownModifier += bonus; break;
                        case 'globalDamageFactor': calculatedBuffs.globalDamageFactor += bonus; break;
                        case 'damageReduction': calculatedBuffs.damageReduction += bonus; break;
                        case 'xpMagnetRadius': calculatedBuffs.xpMagnetRadius += bonus; break;
                        case 'dashCooldown': calculatedBuffs.dashCooldown += bonus; break;
                        case 'critDamage': calculatedBuffs.critDamage += bonus; break;
                        case 'statusEffectDuration': calculatedBuffs.statusEffectDuration += bonus; break;
                        case 'initialRerolls': calculatedBuffs.initialRerolls += bonus; break;
                    }
                });
                
                calculatedBuffs.maxHealth *= hpBonusMultiplierFromTalents;

                setTotalBuffs(calculatedBuffs);

            }, [permanentBuffs, achievementBuffs]);
            
            const totalBossKillsCount = Object.values(globalStats.totalBossKills || {}).reduce((sum, count) => sum + count, 0);
            
            const StatItem = ({ label, value, colorClass = `text-green-400` }) => (
                value ? React.createElement('div', { className: 'flex justify-between p-2.5 bg-black bg-opacity-30 rounded border border-gray-700' },
                    React.createElement('span', { className: 'font-press-start text-xs text-gray-300' }, label),
                    React.createElement('span', { className: `font-VT323 text-lg ${colorClass}` }, value)
                ) : null
            );
            
            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-green-400 mb-6` }, 'Sum√°rio do Sistema'),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-8' },
                    React.createElement('div', { className: 'bg-black bg-opacity-40 p-4 rounded-lg border border-gray-700' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-4 text-center' }, 'B√¥nus Permanentes'),
                        React.createElement('div', { className: 'space-y-2' },
                            React.createElement(StatItem, { label: 'HP M√°ximo Adicional', value: totalBuffs.maxHealth > 0 ? `+${totalBuffs.maxHealth.toFixed(0)}` : null }),
                            React.createElement(StatItem, { label: 'Dano Global', value: totalBuffs.globalDamageFactor > 0 ? `+${(totalBuffs.globalDamageFactor * 100).toFixed(1)}%` : null }),
                            React.createElement(StatItem, { label: 'Velocidade', value: totalBuffs.speedPercent > 0 || totalBuffs.speedFlat > 0 ? `${totalBuffs.speedFlat > 0 ? `+${totalBuffs.speedFlat}` : ''} ${totalBuffs.speedPercent > 0 ? `+${(totalBuffs.speedPercent * 100).toFixed(1)}%` : ''}`.trim() : null }),
                            React.createElement(StatItem, { label: 'Redu√ß√£o de Dano', value: totalBuffs.damageReduction > 0 ? `+${(totalBuffs.damageReduction * 100).toFixed(1)}%` : null }),
                            React.createElement(StatItem, { label: 'Redu√ß√£o de Dano (DoT)', value: totalBuffs.dotDamageReduction > 0 ? `+${(totalBuffs.dotDamageReduction * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Chance de Cr√≠tico', value: totalBuffs.critChance > 0 ? `+${(totalBuffs.critChance * 100).toFixed(1)}%` : null, colorClass: 'text-yellow-400' }),
                            React.createElement(StatItem, { label: 'Dano Cr√≠tico', value: totalBuffs.critDamage > 0 ? `+${(totalBuffs.critDamage * 100).toFixed(0)}%` : null, colorClass: 'text-yellow-400' }),
                            React.createElement(StatItem, { label: 'Regenera√ß√£o por Seg', value: totalBuffs.regenAmount > 0 ? `+${totalBuffs.regenAmount.toFixed(2)} HP/s` : null }),
                            React.createElement(StatItem, { label: 'Recarga de Armas', value: totalBuffs.cooldownModifier !== 0 ? `${(totalBuffs.cooldownModifier * 100).toFixed(1)}%` : null }),
                            React.createElement(StatItem, { label: 'Recarga do Dash', value: totalBuffs.dashCooldown < 0 ? `${(totalBuffs.dashCooldown * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Invencibilidade (Dash)', value: totalBuffs.dashDuration > 0 ? `+${(totalBuffs.dashDuration * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Vel./Alcance Proj√©teis', value: totalBuffs.projectileRangeAndSpeed > 0 ? `+${(totalBuffs.projectileRangeAndSpeed * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Ganho de XP', value: totalBuffs.expModifier > 0 ? `+${(totalBuffs.expModifier * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Alcance de Coleta', value: totalBuffs.xpMagnetRadius > 0 ? `+${(totalBuffs.xpMagnetRadius * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Dura√ß√£o de Efeitos', value: totalBuffs.statusEffectDuration > 0 ? `+${(totalBuffs.statusEffectDuration * 100).toFixed(0)}%` : null }),
                            React.createElement(StatItem, { label: 'Rerolls Iniciais', value: totalBuffs.initialRerolls > 0 ? `+${totalBuffs.initialRerolls}` : null, colorClass: 'text-purple-400' })
                        )
                    ),
                    React.createElement('div', { className: 'bg-black bg-opacity-40 p-4 rounded-lg border border-gray-700' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-orange-300 mb-4 text-center' }, 'Registros de Carreira'),
                         React.createElement('div', { className: 'space-y-2' },
                            React.createElement(StatItem, { label: 'Partidas Jogadas', value: globalStats.gamesPlayed?.toLocaleString() || '0', colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Inimigos Derrotados', value: globalStats.totalKills?.toLocaleString() || '0', colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Chefes Derrotados', value: totalBossKillsCount.toLocaleString() || '0', colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Tempo de Jogo Total', value: formatTime(globalStats.totalTimePlayed || 0), colorClass: 'text-white' }),
                            React.createElement(StatItem, { label: 'Maior Pontua√ß√£o', value: globalStats.highestScore?.toLocaleString() || '0', colorClass: 'text-yellow-300' }),
                            React.createElement(StatItem, { label: 'Maior N√≠vel', value: globalStats.highestLevel || '0', colorClass: 'text-yellow-300' }),
                            React.createElement(StatItem, { label: 'Orbes de XP Coletados', value: globalStats.totalXpOrbsCollected?.toLocaleString() || '0', colorClass: 'text-green-300' }),
                            React.createElement(StatItem, { label: 'Orbes de Vida Coletados', value: globalStats.totalHealthPickupsCollected?.toLocaleString() || '0', colorClass: 'text-red-400' }),
                            React.createElement(StatItem, { label: 'Dashes Usados', value: globalStats.totalDashes?.toLocaleString() || '0', colorClass: 'text-cyan-300' })
                        )
                    )
                )
            );
        };
        // --- END OF components/GlobalStatsScreen.tsx ---

// --- START OF components/LevelUpScreen.tsx ---

// =======================================================================
// <<< OS SUB-COMPONENTES EST√ÅVEIS PERMANECEM FORA >>>
// =======================================================================

const getUpgradeIcon = (upgrade) => { /* ...c√≥digo sem altera√ß√µes... */
    if (upgrade.type === 'weapon_evolution') return 'üåü'; if (upgrade.type === 'weapon_new') return 'üîß'; if (upgrade.requires?.includes('antivirus')) return 'üéØ'; if (upgrade.requires?.includes('firewall')) return 'üõ°Ô∏è'; if (upgrade.requires?.includes('acid_virus')) return 'ü¶†'; if (upgrade.requires?.includes('defrag')) return '‚öîÔ∏è'; if (upgrade.requires?.includes('data_leech')) return 'üîó'; if (upgrade.id.includes('health')) return '‚ù§Ô∏è'; if (upgrade.id.includes('speed')) return 'üèÉ'; if (upgrade.id.includes('cooldown')) return '‚ö°'; if (upgrade.id.includes('exp')) return '‚ú®'; return '‚öôÔ∏è';
};
const getUpgradeTagAndColor = (upgrade) => { /* ...c√≥digo sem altera√ß√µes... */
    if (upgrade.type === 'weapon_evolution') return { text: 'EVOLU√á√ÉO', color: '#facc15' }; if (upgrade.type === 'weapon_new') return { text: 'NOVA ARMA', color: '#38bdf8' }; if (upgrade.type === 'weapon_upgrade') return { text: 'UPGRADE DE ARMA', color: '#4ade80' }; if (upgrade.type === 'player_passive') return { text: 'PASSIVO GLOBAL', color: '#818cf8' }; return { text: 'OTIMIZA√á√ÉO', color: '#9ca3af' };
};

const UpgradeCard = ({ upgrade, side, index, leftCount, onSelect, onHover, isVisible }) => {
    const { text: tagText, color: tagColor } = getUpgradeTagAndColor(upgrade);
    const animationClass = side === 'left' ? 'from-left' : 'from-right';
    const animationDelay = (side === 'left' ? index * 150 : (leftCount + index) * 150) + 300;

    // Adicionamos a classe 'opacity-0' quando isVisible for falso
    return React.createElement('div', {
        onClick: () => onSelect(upgrade),
        onMouseEnter: () => onHover(upgrade.id),
        onMouseLeave: () => onHover(null),
        className: `upgrade-card-module ${animationClass} transition-opacity duration-300 ${!isVisible ? 'opacity-0' : ''}`,
        style: { animationDuration: '0.5s', animationDelay: `${animationDelay}ms` },
        id: `card-${upgrade.id}`
    },
        React.createElement('div', { className: `card-connector ${side}` }),
        React.createElement('div', { className: 'flex items-start gap-4 mb-2' },
            React.createElement('div', { className: 'text-5xl mt-1' }, getUpgradeIcon(upgrade)),
            React.createElement('div', { className: 'flex-1' }, React.createElement('h3', { className: 'font-press-start text-base text-yellow-200' }, upgrade.title))
        ),
        React.createElement('p', { className: "text-sm text-gray-300 leading-tight flex-grow" },
            typeof upgrade.description === 'function' ? upgrade.description((upgrade.currentLevelDisplay || 0) + 1) : upgrade.description
        ),
        React.createElement('div', { className: 'mt-auto flex justify-between items-center' },
            React.createElement('div', { className: 'px-2 py-1 border rounded-sm text-xs font-press-start', style: { borderColor: tagColor, color: tagColor, boxShadow: `0 0 5px ${tagColor}33` } }, tagText),
            !upgrade.type.includes('evolution') && !upgrade.type.includes('new') && React.createElement('div', { className: 'font-press-start text-xs text-cyan-200' }, `N√≠vel: ${(upgrade.currentLevelDisplay || 0) + 1}`)
        )
    );
};

const ConnectionLines = ({ optionsToShow, hoveredUpgradeId, isVisible }) => {
    const { useEffect, useRef } = React;
    const lineRefs = useRef({});

    useEffect(() => {
        const drawLines = () => { /* ...c√≥digo de desenho sem altera√ß√µes... */
            const conduitEl = document.getElementById('central-conduit'); if (!conduitEl) return; const conduitRect = conduitEl.getBoundingClientRect(); const conduitCenterY = conduitRect.top + conduitRect.height / 2; optionsToShow.forEach(opt => { const cardEl = document.getElementById(`card-${opt.id}`); const lineEl = lineRefs.current[opt.id]; if (cardEl && lineEl) { const cardRect = cardEl.getBoundingClientRect(); const cardCenterY = cardRect.top + cardRect.height / 2; const isLeft = cardRect.left < conduitRect.left; const startX = isLeft ? cardRect.right - 2 : cardRect.left + 2; const endX = isLeft ? conduitRect.left : conduitRect.right; const pathData = `M ${startX} ${cardCenterY} C ${(startX + endX) / 2} ${cardCenterY}, ${(startX + endX) / 2} ${conduitCenterY}, ${endX} ${conduitCenterY}`; lineEl.setAttribute('d', pathData); } });
        };
        const observer = new ResizeObserver(drawLines); observer.observe(document.body); drawLines(); return () => observer.disconnect();
    }, [optionsToShow]);

    return React.createElement('svg', { className: `absolute inset-0 w-full h-full pointer-events-none transition-opacity duration-300 ${!isVisible ? 'opacity-0' : ''}` },
        optionsToShow.map(opt =>
            React.createElement('path', {
                key: `line-${opt.id}`,
                ref: el => (lineRefs.current[opt.id] = el),
                className: `connection-line ${hoveredUpgradeId === opt.id ? 'active' : ''}`
            })
        )
    );
};


// ==============================================================
// <<< O COMPONENTE PRINCIPAL COM A L√ìGICA DE TRANSI√á√ÉO >>>
// ==============================================================
const LevelUpScreen = ({ resumeGame, options = [], applyUpgrade, onReroll, rerollsAvailable, isFirstLevelUp }) => {
    if (!applyUpgrade || !resumeGame) return null;

    const { useState, useEffect } = React;
    const [hoveredUpgradeId, setHoveredUpgradeId] = useState(null);
    const [isRerolling, setIsRerolling] = useState(false); // Estado para controlar a transi√ß√£o

    const handleSelectUpgrade = (upgrade) => {
        SoundManager.play('upgradeSelect');
        applyUpgrade(upgrade);
        resumeGame();
    };

    // Fun√ß√£o de reroll agora controla a anima√ß√£o
    const handleRerollClick = () => {
        if (isRerolling) return; // Previne m√∫ltiplos cliques
        SoundManager.play('uiClick');
        setIsRerolling(true); // 1. Inicia o fade-out

        // 2. Espera a anima√ß√£o de fade-out terminar
        setTimeout(() => {
            onReroll();           // 3. Pega as novas op√ß√µes
            setIsRerolling(false); // 4. Inicia o fade-in dos novos cards
        }, 300); // Dura√ß√£o da transi√ß√£o de opacidade
    };

    const numOptions = isFirstLevelUp ? 1 : Math.min(options.length, 5);
    const optionsToShow = options.slice(0, numOptions);
    const leftCount = Math.ceil(optionsToShow.length / 2);
    const rightOptions = optionsToShow.slice(leftCount);
    const leftOptions = optionsToShow.slice(0, leftCount);

    return React.createElement('div', { className: 'levelup-container' },
        React.createElement(ConnectionLines, {
            optionsToShow,
            hoveredUpgradeId,
            isVisible: !isRerolling // Passa o estado de visibilidade
        }),
        
        React.createElement('h2', {
            id: "levelUpTitle",
            className: 'absolute top-[8vh] font-press-start text-3xl text-yellow-300 text-center tracking-wider opacity-0 animate-fadeIn',
            style: { textShadow: '0 0 10px #facc15', animationName: 'title-fade-in', animationDuration: '0.8s', animationFillMode: 'forwards' }
        },
            isFirstLevelUp ? 'UPGRADE INICIAL GRATUITO' : 'SELECIONE PROTOCOLO DE OTIMIZA√á√ÉO'
        ),

        React.createElement('div', { className: 'flex items-center justify-center gap-28 w-full px-8' },
            React.createElement('div', { className: 'flex flex-col gap-8' },
                leftOptions.map((upg, i) => React.createElement(UpgradeCard, {
                    key: upg.id,
                    upgrade: upg,
                    side: 'left',
                    index: i,
                    leftCount,
                    onSelect: handleSelectUpgrade,
                    onHover: setHoveredUpgradeId,
                    isVisible: !isRerolling // Passa o estado de visibilidade
                }))
            ),
            
            React.createElement('div', { id: 'central-conduit', className: 'central-conduit flex-shrink-0' },
                React.createElement('div', { className: 'central-conduit-core' },
                    React.createElement('div', { className: 'conduit-ring', style: { borderColor: '#06b6d4', animationDelay: '0s' } }),
                    React.createElement('div', { className: 'conduit-ring', style: { borderColor: '#3b82f6', animationDelay: '-1.5s', animationDirection: 'reverse' } }),
                    React.createElement('div', { className: 'conduit-ring', style: { borderColor: '#818cf8', animationDelay: '-3s' } })
                )
            ),

            React.createElement('div', { className: 'flex flex-col gap-8' },
                rightOptions.map((upg, i) => React.createElement(UpgradeCard, {
                    key: upg.id,
                    upgrade: upg,
                    side: 'right',
                    index: i,
                    leftCount,
                    onSelect: handleSelectUpgrade,
                    onHover: setHoveredUpgradeId,
                    isVisible: !isRerolling // Passa o estado de visibilidade
                }))
            )
        ),

        !isFirstLevelUp && rerollsAvailable > 0 && React.createElement('button', {
            onClick: handleRerollClick,
            disabled: isRerolling, // Desabilita o bot√£o durante a anima√ß√£o
            className: 'absolute bottom-[8vh] font-press-start py-3 px-6 rounded-md text-lg transition-all duration-200 bg-purple-600/80 text-white border-2 border-purple-400 hover:bg-purple-600 hover:scale-105 hover:shadow-[0_0_20px_#a855f7] opacity-0 animate-fadeIn',
            style: { animationDelay: '0.8s' }
        }, `Rerrolar (${rerollsAvailable})`)
    );
};
// --- END OF components/LevelUpScreen.tsx ---

                // --- START OF components/PauseScreen.tsx ---
        const PauseScreen = ({ setMainScreen, setGameScreen, resumeGameCallback, startGameCallback, ownedUpgrades, activeClass, soundSettings, onVolumeChange, onMuteToggle, engineRef }) => {
            const activeStandardUpgrades = []; 
            if (ownedUpgrades) { 
                UPGRADE_POOL.forEach(upgradeDef => { 
                    const currentLevel = ownedUpgrades.get(upgradeDef.id) || 0; 
                    if (currentLevel > 0 && upgradeDef.type !== 'weapon_new' && upgradeDef.type !== 'weapon_evolution') { 
                        activeStandardUpgrades.push({ title: upgradeDef.title, level: currentLevel }); 
                    } 
                }); 
                ownedUpgrades.forEach((level, id) => { 
                    const upgradeDef = UPGRADE_POOL.find(u => u.id === id); 
                    if (upgradeDef && upgradeDef.type === 'weapon_new' && level === 1) { 
                        if (!activeStandardUpgrades.find(asu => asu.title.includes(upgradeDef.title.replace("Instalar ", "")))) { 
                            activeStandardUpgrades.push({ title: upgradeDef.title.replace("Instalar ", ""), level: 1 }); 
                        } 
                    } 
                }); 
            }
            const classPassiveDisplay = activeClass?.uniquePassive ? `${activeClass.uniquePassive.name} (Passiva da Classe)` : null;

            // L√≥gica de renderiza√ß√£o dos upgrades corrigida
            const renderUpgrades = () => {
                const upgradeElements = activeStandardUpgrades.map(upg => 
                    React.createElement('p', { key: upg.title, className: 'text-sm text-gray-300 mb-1' }, `${upg.title} (N√≠vel ${upg.level})`)
                );

                if (upgradeElements.length > 0) {
                    return upgradeElements;
                }

                if (!classPassiveDisplay) {
                    return React.createElement('p', { className: 'text-sm text-gray-400 text-center' }, 'Nenhum upgrade adquirido nesta sess√£o.');
                }
                
                return React.createElement('p', { className: 'text-sm text-gray-400 text-center mt-2' }, 'Nenhum upgrade de n√≠vel adquirido.');
            };

            return React.createElement('div', { className: 'absolute inset-0 z-40 flex flex-col items-center justify-center bg-black bg-opacity-80 p-6 shadow-xl border-2 border-gray-700 overflow-y-auto' },
                React.createElement('h2', { className: 'font-press-start text-3xl sm:text-4xl text-yellow-300 mb-6 animate-pulse' }, 'JOGO PAUSADO'),
                React.createElement('div', { className: 'flex flex-col sm:flex-row space-y-6 sm:space-y-0 sm:space-x-6 w-full max-w-3xl mb-6' },
                    React.createElement('div', { className: 'flex flex-col space-y-4 flex-1' },
                        React.createElement('button', { onClick: () => {SoundManager.play('uiClick'); resumeGameCallback();}, className: 'font-press-start bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-400' }, 'RETOMAR JOGO'),
                        React.createElement('button', { onClick: () => {SoundManager.play('uiClick'); startGameCallback();}, className: 'font-press-start bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400' }, 'REINICIAR JOGO'),
                        React.createElement('button', { onClick: () => {SoundManager.play('uiClick'); setGameScreen(GameScreenState.INTRO);}, className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-500' }, 'SAIR PARA O MENU')
                    ),
                    React.createElement('div', { className: 'flex-1 bg-gray-800 bg-opacity-70 p-4 rounded-lg border border-gray-600 max-h-60 overflow-y-auto' },
                        React.createElement('h3', { className: 'font-press-start text-xl text-yellow-200 mb-3 text-center' }, 'Status da Classe'),
                        classPassiveDisplay && React.createElement('p', { className: 'text-sm text-purple-300 mb-1 font-semibold' }, classPassiveDisplay),
                        // AQUI USAMOS A FUN√á√ÉO CORRIGIDA
                        renderUpgrades()
                    )
                ),
                 React.createElement('div', { className: 'w-full max-w-3xl mb-6' },
                    React.createElement('h3', { className: 'font-press-start text-xl text-yellow-200 mb-3 text-center' }, 'Modificadores Ativos'),
                    React.createElement('div', { className: 'text-center' },
                        (engineRef.gameState.player.activeModifiers && engineRef.gameState.player.activeModifiers.length > 0) ?
                            engineRef.gameState.player.activeModifiers.map(mod =>
                                React.createElement('p', { key: mod.id, className: `text-sm ${mod.points > 0 ? 'text-red-400' : 'text-green-400'}` }, mod.name)
                            ) :
                            React.createElement('p', { className: 'text-sm text-gray-500' }, 'Sem Modificadores')
                    )
                ),
                 React.createElement('div', { className: 'w-full max-w-3xl p-4 bg-gray-800 bg-opacity-70 rounded-lg border border-gray-600' },
                    React.createElement('h3', { className: 'font-press-start text-xl text-yellow-200 mb-4 text-center' }, 'Configura√ß√µes de Som'),
                    React.createElement('div', { className: 'flex flex-col space-y-3' }, React.createElement('div', { className: 'flex items-center space-x-3' }, React.createElement('label', { htmlFor: 'volume-slider', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}]` }, 'Volume:'), React.createElement('input', { type: 'range', id: 'volume-slider', min: '0', max: '1', step: '0.01', value: soundSettings.volume, onChange: (e) => onVolumeChange(parseFloat(e.target.value)), className: `w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-player-color`, style: {['--player-color']: GAME_COLORS.PLAYER } }), React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}] w-12 text-right` }, `${Math.round(soundSettings.volume * 100)}%`) ), React.createElement('div', { className: 'flex items-center space-x-3' }, React.createElement('input', { type: 'checkbox', id: 'mute-toggle', checked: soundSettings.muted, onChange: (e) => onMuteToggle(e.target.checked), className: `w-5 h-5 rounded bg-gray-700 border-[${GAME_COLORS.BORDER}] focus:ring-2 focus:ring-[${GAME_COLORS.PLAYER}] accent-player-color`, style: {['--player-color']: GAME_COLORS.PLAYER } }), React.createElement('label', { htmlFor: 'mute-toggle', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}] cursor-pointer select-none` }, 'Silenciar Tudo') ) ) )
            );
        };
        // --- END OF components/PauseScreen.tsx ---

        // --- START OF components/BossWarningScreen.tsx ---
        const BossWarningScreen = ({ stage }) => {
            const boss1Text = "Uma anomalia massiva foi detectada... O 'GUARDI√ÉO DO N√öCLEO CORROMPIDO' foi ativado! Prepare-se!";
            const boss2Text = "M√∫ltiplas assinaturas de alta prioridade convergem no centro do sistema... 'O SINCRONIZADOR' est√° online!";
            const boss3Text = "VIOLA√á√ÉO DE PROTOCOLO N√çVEL √îMEGA! 'O √ÅRBITRO DO SISTEMA' est√° expurgando todos os processos n√£o autorizados!";
            const boss4Text = "FALHA CR√çTICA DE REDE! O 'NEXUS DA COLMEIA' assimilou o controle do mainframe! Prepare-se para a singularidade!"; // --- NOVO ---
            
            let text = boss1Text;
            if (stage === 2) text = boss2Text;
            if (stage === 3) text = boss3Text;
            if (stage === 4) text = boss4Text; // --- NOVO ---

            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-red-700 animate-pulse' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-red-500 mb-4 text-center' }, 'ALERTA DE SEGURAN√áA CR√çTICO!!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-300 text-center max-w-xl' }, text)
            );
        };
        // --- END OF components/BossWarningScreen.tsx ---

        // --- START OF components/StageClearScreen.tsx ---
        const StageClearScreen = ({ startNextStageCallback }) => {
            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-green-700' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-green-400 mb-6 animate-pulse text-center' }, 'GUARDI√ÉO DA FASE 1 DERROTADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-4 text-center' }, 'Voc√™ estabilizou a parti√ß√£o prim√°ria.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-10 text-center' }, 'A corrup√ß√£o se espalhou para um setor mais profundo... Prepare-se!'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); startNextStageCallback(2); }, 
                        className: 'font-press-start bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-400' 
                    }, 'CONTINUAR PARA FASE 2')
                )
            );
        };
        const StageClearScreen2 = ({ startNextStageCallback }) => {
            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-cyan-500' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-cyan-400 mb-6 animate-pulse text-center' }, 'SINCRONIZADOR NEUTRALIZADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-4 text-center' }, 'O fluxo de dados corrompidos foi interrompido.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-10 text-center' }, 'Acesso ao n√∫cleo do sistema... √† placa-m√£e... foi concedido. A anomalia final aguarda.'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); startNextStageCallback(3); }, 
                        className: 'font-press-start bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-400' 
                    }, 'AVAN√áAR PARA O SETOR FINAL')
                )
            );
        };
        const StageClearScreen3 = ({ startNextStageCallback }) => { // --- NOVO ---
            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-red-500' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-red-400 mb-6 animate-pulse text-center' }, '√ÅRBITRO DESATIVADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-4 text-center' }, 'A √∫ltima linha de defesa do sistema foi quebrada.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-yellow-200 mb-10 text-center' }, 'Acesso irrestrito ao Mainframe... O verdadeiro cora√ß√£o da corrup√ß√£o √© revelado.'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); startNextStageCallback(4); }, 
                        className: 'font-press-start bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-pink-400' 
                    }, 'AVAN√áAR PARA O MAINFRAME')
                )
            );
        };
        // --- END OF components/StageClearScreen.tsx ---
        
        // --- START OF components/InfiniteModeScreen.tsx ---
        const NexusDefeatedScreen = ({ resumeGameCallback }) => { // --- ALTERADO ---
             return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8 shadow-xl border-4 border-yellow-500' },
                React.createElement('h2', { className: 'font-press-start text-2xl sm:text-4xl text-yellow-400 mb-6 animate-pulse text-center' }, 'NEXUS DA COLMEIA DERROTADO!'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-cyan-200 mb-4 text-center' }, 'O sistema est√° estabilizado, mas a corrup√ß√£o residual √© infinita.'),
                React.createElement('p', { className: 'text-lg sm:text-xl text-cyan-200 mb-10 text-center' }, 'MODO INFINITO ATIVADO. Sobreviva o quanto puder!'),
                React.createElement('div', { className: 'flex flex-col space-y-5 w-full max-w-md' },
                    React.createElement('button', { 
                        onClick: () => { SoundManager.play('uiClick'); resumeGameCallback(); }, 
                        className: 'font-press-start bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded text-lg sm:text-xl transition-transform duration-150 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-400' 
                    }, 'ENTRAR NO LOOP INFINITO')
                )
            );
        };
        // --- END OF components/InfiniteModeScreen.tsx ---

                // --- START OF components/TalentTreeScreen.tsx ---
        const TalentTreeScreen = ({ systemCores, corruptedKernels, permanentBuffs, updateSystemCores, updateCorruptedKernels, updatePermanentBuff }) => {
            const { useState, useRef, useLayoutEffect } = React;
            const [tooltip, setTooltip] = useState(null);
            const [containerDims, setContainerDims] = useState({ width: 0, height: 0 });
            const containerRef = useRef(null);

            useLayoutEffect(() => {
                const updateDimensions = () => {
                    if (containerRef.current) {
                        setContainerDims({
                            width: containerRef.current.clientWidth,
                            height: containerRef.current.clientHeight,
                        });
                    }
                };
            
                const resizeObserver = new ResizeObserver(updateDimensions);
                if (containerRef.current) {
                    resizeObserver.observe(containerRef.current);
                }
                updateDimensions();
            
                return () => {
                    if (containerRef.current) {
                        resizeObserver.unobserve(containerRef.current);
                    }
                };
            }, []);

            const allTalents = TALENT_TREE_CONFIG;

            const isUnlockable = (talent) => {
                if (!talent.requires || talent.requires.length === 0) return true;
                return talent.requires.every(reqId => {
                    const prerequisiteTalent = allTalents.find(t => t.id === reqId);
                    if (!prerequisiteTalent) return false;
                    return (permanentBuffs[reqId] || 0) >= prerequisiteTalent.maxLevel;
                });
            };

            const handleUpgrade = (talent) => {
                const currentLevel = permanentBuffs[talent.id] || 0;
                if (currentLevel >= talent.maxLevel || !isUnlockable(talent)) return;
                const cost = talent.costPerLevel[currentLevel];
                const currency = talent.isCorrupted ? corruptedKernels : systemCores;
                const updateCurrency = talent.isCorrupted ? updateCorruptedKernels : updateSystemCores;
                if (currency >= cost) {
                    SoundManager.play(talent.isCorrupted ? 'kernelUnlock' : 'permanentUpgrade');
                    updateCurrency(prev => prev - cost);
                    updatePermanentBuff(talent.id, currentLevel + 1);
                } else {
                    SoundManager.play('uiClick');
                }
            };

            const handleMouseEnter = (talent, e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                setTooltip({ talent, x: rect.left + rect.width / 2, y: rect.top - 10 });
            };

            const handleMouseLeave = () => setTooltip(null);
            
            const branchColors = {
                defense: { border: 'border-blue-500', text: 'text-blue-300', shadow: 'talent-node-shadow-defense', line: '#3b82f6' },
                offense: { border: 'border-red-500', text: 'text-red-300', shadow: 'talent-node-shadow-offense', line: '#ef4444' },
                utility: { border: 'border-yellow-400', text: 'text-yellow-300', shadow: 'talent-node-shadow-utility', line: '#fbbf24' },
                ultimate: { border: 'border-purple-500', text: 'text-purple-300', shadow: 'talent-node-shadow-ultimate', line: '#a855f7' },
                corrupted_defense: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                corrupted_offense: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                corrupted_utility: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                corrupted_ultimate: { border: 'border-fuchsia-500', text: 'text-fuchsia-300', shadow: 'talent-node-shadow-corrupted', line: '#d946ef' },
                maxed: { border: 'border-yellow-400', text: 'text-yellow-400', shadow: 'talent-node-shadow-maxed' }
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('div', { className: 'w-full flex justify-between items-center mb-4' },
                    React.createElement('div', null),
                    React.createElement('h1', { className: `font-press-start text-3xl text-green-400` }, '√Årvore do Kernel'),
                    React.createElement('div', { className: 'flex flex-col sm:flex-row gap-x-4 gap-y-1' }, 
                        React.createElement('div', { className: 'flex items-center justify-end' }, React.createElement('span', { className: `font-press-start text-lg text-[${GAME_COLORS.TEXT_SYSTEM_CORE}] mr-2` }, 'S:'), React.createElement('span', { className: `font-VT323 text-2xl text-white font-bold` }, systemCores)),
                        React.createElement('div', { className: 'flex items-center justify-end' }, React.createElement('span', { className: `font-press-start text-lg text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}] mr-2` }, 'C:'), React.createElement('span', { className: `font-VT323 text-2xl text-white font-bold` }, corruptedKernels))
                    )
                ),

                React.createElement('div', { className: 'flex-grow w-full max-w-7xl relative overflow-y-auto', ref: containerRef },
                    React.createElement('svg', { className: 'absolute top-0 left-0 w-full h-full -z-10', style: { overflow: 'visible' } },
                        allTalents.map(talent => {
                            if (!talent.requires) return null;
                            return talent.requires.map(fromId => {
                                const fromTalent = allTalents.find(t => t.id === fromId);
                                if (!fromTalent) return null;
                                
                                const isLineActive = (permanentBuffs[fromId] || 0) >= fromTalent.maxLevel;
                                const colors = branchColors[talent.branch] || branchColors.utility;

                                const x1 = (fromTalent.x / 100) * containerDims.width;
                                const y1 = (fromTalent.y / 100) * containerDims.height;
                                const x2 = (talent.x / 100) * containerDims.width;
                                const y2 = (talent.y / 100) * containerDims.height;
                                
                                const midY = y1 + (y2 - y1) / 2;
                                const pathData = `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;

                                return React.createElement('path', {
                                    key: `${fromId}-${talent.id}`,
                                    d: pathData,
                                    stroke: isLineActive ? colors.line : '#4b5563',
                                    strokeWidth: "3",
                                    fill: "none",
                                    className: `transition-all duration-500 ${isLineActive ? 'line-flow-anim' : ''}`
                                });
                            });
                        }).flat()
                    ),

                    allTalents.map(talent => {
                        const currentLevel = permanentBuffs[talent.id] || 0;
                        const isMaxed = currentLevel >= talent.maxLevel;
                        const unlockable = isUnlockable(talent);
                        const cost = !isMaxed ? talent.costPerLevel[currentLevel] : 0;
                        const currency = talent.isCorrupted ? corruptedKernels : systemCores;
                        const canAfford = currency >= cost;
                        
                        const colors = isMaxed ? branchColors.maxed : branchColors[talent.branch];
                        const sizeClass = talent.id.includes('core_unlock') ? 'w-24 h-24' : (talent.id.includes('capstone') || talent.id.includes('ultimate') ? 'w-28 h-28' : 'w-20 h-20');
                        
                        let borderStyle = 'border-gray-700';
                        let shadowStyle = '';
                        if (isMaxed) {
                            borderStyle = colors.border;
                            shadowStyle = colors.shadow;
                        } else if (unlockable) {
                            borderStyle = canAfford ? colors.border : 'border-gray-500';
                            if (canAfford) shadowStyle = colors.shadow;
                        }

                        return React.createElement('button', {
                            key: talent.id,
                            onClick: () => handleUpgrade(talent),
                            onMouseEnter: (e) => handleMouseEnter(talent, e),
                            onMouseLeave: handleMouseLeave,
                            className: `absolute flex flex-col items-center justify-center p-1 transition-all duration-300 hexagon-clip ${sizeClass} ${borderStyle} border-4 bg-[#0d1117] ${unlockable ? 'opacity-100' : 'opacity-40'} ${(unlockable && !isMaxed && canAfford) ? `cursor-pointer hover:scale-110 ${shadowStyle}` : 'cursor-not-allowed'} ${shadowStyle}`,
                            style: {
                                left: `${talent.x}%`,
                                top: `${talent.y}%`,
                                transform: 'translate(-50%, -50%)'
                            }
                        },
                            React.createElement('div', { className: 'text-2xl md:text-3xl' }, talent.icon),
                            React.createElement('p', { className: `font-press-start text-xs mt-1 ${colors.text}` }, `${currentLevel}/${talent.maxLevel}`)
                        );
                    })
                ),

                tooltip && React.createElement('div', { 
                    className: 'fixed z-50 p-3 rounded-md bg-black border-2 border-gray-500 shadow-2xl w-64 transition-opacity duration-200 pointer-events-none -translate-x-1/2 -translate-y-full',
                    style: { left: tooltip.x, top: tooltip.y, opacity: 1 }
                }, 
                    React.createElement('h3', { className: `font-press-start text-sm ${tooltip.talent.isCorrupted ? 'text-purple-400' : 'text-yellow-300'} mb-2`}, tooltip.talent.title),
                    React.createElement('div', {className: 'space-y-1 mb-2'}, 
                        (() => {
                            const talent = tooltip.talent;
                            const currentLevel = permanentBuffs[talent.id] || 0;
                            const isMaxed = currentLevel >= talent.maxLevel;
                            if (typeof talent.description === 'function') {
                                return React.createElement(React.Fragment, null,
                                    currentLevel > 0 && React.createElement('p', { className: 'text-xs text-gray-400' },
                                        'Atual: ', React.createElement('span', { className: 'text-gray-200' }, talent.description(currentLevel))
                                    ),
                                    !isMaxed && React.createElement('p', { className: 'text-xs text-green-400' },
                                        'Pr√≥ximo: ', React.createElement('span', { className: 'text-green-300' }, talent.description(currentLevel + 1))
                                    )
                                );
                            } else {
                                return React.createElement('p', { className: 'text-xs text-gray-300' }, talent.description);
                            }
                        })()
                    ),
                    React.createElement('hr', { className: 'border-gray-600 my-2' }),
                    (() => {
                        const talent = tooltip.talent;
                        const currentLevel = permanentBuffs[talent.id] || 0;
                        const isMaxed = currentLevel >= talent.maxLevel;
                        if (isMaxed) {
                            return React.createElement('p', {className: 'text-xs font-bold text-yellow-400'}, 'N√çVEL M√ÅXIMO');
                        } else if (!isUnlockable(talent)) {
                            return React.createElement('p', { className: 'text-xs font-bold text-red-500' }, 'Requer talentos anteriores');
                        }
                        const cost = talent.costPerLevel[currentLevel];
                        const currency = talent.isCorrupted ? corruptedKernels : systemCores;
                        const currencyName = talent.isCorrupted ? "Corrompidos" : "de Sistema";
                        const currencyColor = talent.isCorrupted ? `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}]` : `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}]`;
                        const canAfford = currency >= cost;
                        return React.createElement('p', { className: `text-xs font-bold ${canAfford ? 'text-white' : 'text-red-400'}`}, 
                           'Custo: ', React.createElement('span', {className: 'text-yellow-200'}, cost), ' N√∫cleos ', React.createElement('span', {className: currencyColor}, currencyName)
                        );
                    })()
                )
            );
        };
        // --- END OF components/TalentTreeScreen.tsx ---

        // --- START OF components/AchievementsScreen.tsx ---
        const AchievementsScreen = ({ unlockedAchievements }) => {
            const unlockedCount = unlockedAchievements.size;
            const totalCount = ACHIEVEMENTS_CONFIG.length;
            const progressPercent = totalCount > 0 ? (unlockedCount / totalCount) * 100 : 0;

            const getDifficultyClass = (difficulty) => {
                switch(difficulty) {
                    case 'F√°cil': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_EASY}]`;
                    case 'M√©dia': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_MEDIUM}]`;
                    case 'Dif√≠cil': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_HARD}]`;
                    case '√âpica': return `bg-[${GAME_COLORS.ACHIEVEMENT_DIFFICULTY_EPIC}]`;
                    default: return 'bg-gray-500';
                }
            };
        
            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'Painel de Conquistas'),
                React.createElement('div', { className: 'w-full max-w-3xl my-4' },
                    React.createElement('p', { className: 'font-press-start text-lg mb-2' }, `Progresso: ${unlockedCount} / ${totalCount}`),
                    React.createElement('div', { className: `w-full h-4 rounded bg-[${GAME_COLORS.PROGRESS_BAR_BG}] border border-[${GAME_COLORS.BORDER}]`},
                        React.createElement('div', { className: `h-full rounded-sm bg-[${GAME_COLORS.TEXT_GREEN}]`, style: { width: `${progressPercent}%` } })
                    )
                ),
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 flex-grow overflow-y-auto' },
                    ACHIEVEMENTS_CONFIG.map(ach => {
                        const isUnlocked = unlockedAchievements.has(ach.id);
                        return React.createElement('div', { key: ach.id, className: `p-3 rounded-lg border text-left flex items-start space-x-3 transition-opacity duration-300 ${isUnlocked ? `border-[${GAME_COLORS.BORDER}] bg-[${GAME_COLORS.ACHIEVEMENT_UNLOCKED_BG}]` : `border-dashed border-gray-600 bg-[${GAME_COLORS.ACHIEVEMENT_LOCKED_BG}] opacity-60`}` },
                            React.createElement('div', { className: 'text-3xl mt-1' }, ach.icon),
                            React.createElement('div', { className: 'flex-1' },
                                React.createElement('h3', { className: `font-press-start text-sm ${isUnlocked ? `text-[${GAME_COLORS.TEXT_YELLOW}]` : 'text-gray-400'}` }, ach.name),
                                React.createElement('p', { className: 'text-xs text-gray-300 my-1' }, isUnlocked ? ach.description : ach.unlockHint),
                                isUnlocked && React.createElement('p', { className: `text-xs font-bold text-[${GAME_COLORS.TEXT_GREEN}]` }, `Recompensa: ${ach.reward.rewardDescription}`),
                                React.createElement('div', { className: `mt-2 text-2xs font-press-start px-2 py-0.5 rounded-full inline-block text-white ${getDifficultyClass(ach.difficulty)}` }, ach.difficulty)
                            )
                        );
                    })
                )
            );
        };
        // --- END OF components/AchievementsScreen.tsx ---

        // --- START OF components/AchievementToast.tsx ---
        const { useState: useToastState, useEffect: useToastEffect } = React;
        const AchievementToast = ({ achievement, onDismiss }) => {
            const [isVisible, setIsVisible] = useToastState(true);

            useToastEffect(() => {
                const timer = setTimeout(() => {
                    setIsVisible(false);
                    setTimeout(onDismiss, 500);
                }, 5000);

                return () => clearTimeout(timer);
            }, [onDismiss]);
            
            if (!achievement) return null;

            const isSkin = !!achievement.rarity;

            return React.createElement('div', { className: `fixed top-28 right-4 z-50 p-4 rounded-lg border-2 shadow-lg max-w-sm w-full ${isVisible ? 'toast-in' : 'toast-out'} border-[${GAME_COLORS.UPGRADE_CARD_EVOLUTION_BORDER}] bg-[${GAME_COLORS.ACHIEVEMENT_UNLOCKED_BG}]` },
                React.createElement('div', { className: 'flex items-center space-x-3' },
                    React.createElement('div', { className: 'text-4xl' }, isSkin ? 'üëï' : achievement.icon),
                    React.createElement('div', {},
                        React.createElement('h3', { className: 'font-press-start text-sm text-yellow-300' }, isSkin ? 'Nova Skin Desbloqueada!' : 'Conquista Desbloqueada!'),
                        React.createElement('p', { className: 'text-xs text-white' }, achievement.name),
                        !isSkin && React.createElement('p', { className: 'text-xs font-bold text-green-400 mt-1' }, `Recompensa: ${achievement.reward.rewardDescription}`)
                    )
                )
            );
        };
        // --- END OF components/AchievementToast.tsx ---

        // --- START OF components/ArsenalScreen.tsx ---
        const ArsenalScreen = ({ corruptedKernels, updateCorruptedKernels }) => {
            const [masteryStats, setMasteryStats] = React.useState({});

            React.useEffect(() => {
                const storedStats = localStorage.getItem(WEAPON_MASTERY_KEY);
                if (storedStats) {
                    setMasteryStats(JSON.parse(storedStats));
                }
            }, []);

            const formatDamage = (damage) => {
                if (damage >= 1000000000) return `${(damage / 1000000000).toFixed(1)}B`;
                if (damage >= 1000000) return `${(damage / 1000000).toFixed(1)}M`;
                if (damage >= 1000) return `${(damage / 1000).toFixed(1)}K`;
                return damage ? damage.toLocaleString() : 0;
            };
            
            const handleUnlockTier3 = (weaponId) => {
                if(corruptedKernels < 1) {
                    SoundManager.play('uiClick');
                    return;
                }

                SoundManager.play('kernelUnlock');
                updateCorruptedKernels(prev => prev - 1);
                
                setMasteryStats(prevStats => {
                    const newStats = {...prevStats};
                    if(!newStats[weaponId]) newStats[weaponId] = { damage: 0, tier3Unlocked: false };
                    newStats[weaponId].tier3Unlocked = true;
                    localStorage.setItem(WEAPON_MASTERY_KEY, JSON.stringify(newStats));
                    return newStats;
                });
            };

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-2` }, 'O Arsenal'),
                React.createElement('p', { className: "text-base max-w-3xl mb-4 text-center" }, 'Cause dano com as armas para aumentar sua maestria e desbloquear b√¥nus permanentes.'),
                React.createElement('div', { className: 'mb-6 text-lg' }, React.createElement('span', { className: 'font-press-start text-purple-400' }, 'N√∫cleos Corrompidos: '), React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}] font-bold` }, corruptedKernels)),
                
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-4' },
                    WEAPON_MASTERY_CONFIG.map(config => {
                        const weaponStats = masteryStats[config.weaponId] || { damage: 0, tier3Unlocked: false };
                        const damageDealt = weaponStats.damage || 0;
                        let currentTier = -1;
                        for(let i = config.tiers.length - 1; i >= 0; i--) {
                            if (damageDealt >= config.tiers[i].damageRequired) {
                                currentTier = i;
                                break;
                            }
                        }
                        const nextTierIndex = currentTier + 1;
                        const nextTier = nextTierIndex < config.tiers.length ? config.tiers[nextTierIndex] : null;
                        const progressPercent = nextTier ? (damageDealt / nextTier.damageRequired) * 100 : 100;

                        return React.createElement('div', { key: config.weaponId, className: 'p-4 rounded-lg border-2 border-gray-700 bg-black bg-opacity-30 text-left' },
                            React.createElement('h2', { className: 'font-press-start text-lg text-cyan-300 mb-2 flex items-center' }, React.createElement('span', { className: 'mr-2 text-2xl' }, config.icon), config.name),
                            React.createElement('div', { className: 'w-full h-3 rounded bg-gray-900 border border-gray-600 mb-1' },
                                React.createElement('div', { className: 'h-full rounded-sm bg-cyan-400', style: { width: `${progressPercent}%` }})
                            ),
                            React.createElement('p', { className: 'text-xs text-center text-gray-400 mb-3' }, `Dano Total: ${formatDamage(damageDealt)} ${nextTier ? `/ ${formatDamage(nextTier.damageRequired)}` : ''}`),
                            
                            React.createElement('div', { className: 'space-y-3' },
                                config.tiers.map((tier, index) => {
                                    const isUnlocked = damageDealt >= tier.damageRequired;
                                    const isTier3Unlocked = weaponStats.tier3Unlocked;
                                    
                                    let isTierActive = isUnlocked;
                                    if(index === 2 && !isTier3Unlocked) {
                                        isTierActive = false;
                                    }

                                    return React.createElement('div', { key: index, className: `p-2 rounded border transition-all duration-300 ${isTierActive ? 'border-green-600 bg-green-900/30' : 'border-gray-600 bg-gray-900/50'}` },
                                        React.createElement('h4', { className: 'font-press-start text-xs text-yellow-300' }, `Tier ${index + 1}`),
                                        React.createElement('p', { className: `text-xs ${isTierActive ? 'text-gray-200' : 'text-gray-500'}` }, tier.bonusText),
                                        index === 2 && !isTier3Unlocked && isUnlocked && React.createElement('button', {
                                            onClick: () => handleUnlockTier3(config.weaponId),
                                            disabled: corruptedKernels < tier.cost,
                                            className: `mt-2 w-full text-xs font-press-start py-1 rounded ${corruptedKernels >= tier.cost ? 'bg-purple-600 hover:bg-purple-700' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`
                                        }, `Ativar (${tier.cost} N√∫cleo Corrompido)`),
                                        index === 2 && isTier3Unlocked && React.createElement('p', {className: 'mt-2 text-xs font-bold text-green-400'}, 'ATIVADO')
                                    )
                                })
                            )
                        )
                    })
                )
            );
        };
        // --- END OF components/ArsenalScreen.tsx ---

      // --- START OF components/PatchNotesScreen.tsx ---
const PatchNotesScreen = () => {
    const [notes, setNotes] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(null);

    React.useEffect(() => {
        const loadNotes = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await fetchPatchNotesJSON();
                setNotes(data);
            } catch (e) {
                const errorMessage = e.message || 'Falha ao carregar as notas de atualiza√ß√£o.';
                setError(errorMessage);
                console.error(e);
            } finally {
                setLoading(false);
            }
        };
        loadNotes();
    }, []);

    const renderNotes = () => {
        if (loading) {
            return React.createElement('p', { className: 'text-center text-yellow-300 animate-pulse' }, 'Buscando atualiza√ß√µes no sistema...');
        }
        if (error) {
            return React.createElement('p', { className: 'text-center text-red-400' }, error);
        }
        if (notes.length === 0) {
            return React.createElement('p', { className: 'text-center text-gray-400' }, 'Nenhuma nota de atualiza√ß√£o encontrada.');
        }

        // Renderiza os patches na ordem em que chegam (mais recente primeiro)
        return notes.map((patch, index) => React.createElement('div', { key: patch.title || index, className: 'mb-8' },
            React.createElement('div', { className: 'border-b-2 border-gray-700 pb-2 mb-4' },
                React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, patch.title),
                React.createElement('p', { className: 'font-VT323 text-lg text-gray-400' }, patch.date)
            ),
            React.createElement('div', { className: 'space-y-4' },
                // --- MUDAN√áA CR√çTICA AQUI ---
                // Iteramos sobre `patch.notes` como um ARRAY
                // `section` agora √© um objeto: { category: "...", items: [...] }
                patch.notes.map((section) => React.createElement('div', { key: section.category },
                    // Usamos `section.category` para o t√≠tulo da se√ß√£o
                    React.createElement('h3', { className: 'font-press-start text-base text-yellow-400 mb-2' }, section.category),
                    React.createElement('ul', { className: 'list-none pl-4 space-y-1' },
                        // E iteramos sobre `section.items` para a lista de notas
                        section.items.map((item, itemIndex) => React.createElement('li', { key: itemIndex, className: 'text-sm text-gray-200 before:content-["¬ª_"] before:text-green-400 before:mr-2' }, item))
                    )
                ))
            )
        ));
    };

    return React.createElement('div', { className: 'w-full h-full flex flex-col items-center p-6 animate-fadeIn' },
        React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-6` }, 'Notas de Atualiza√ß√£o'),
        React.createElement('div', { className: 'w-full max-w-4xl flex-grow bg-black bg-opacity-40 p-6 rounded-lg border border-gray-700 overflow-y-auto' },
            renderNotes()
        )
    );
};
// --- END OF components/PatchNotesScreen.tsx ---

        // --- START OF components/SettingsScreen.tsx ---
        const SettingsScreen = ({ soundSettings, onVolumeChange, onMuteToggle, setGameScreen }) => {

            const handleResetProgress = () => {
                SoundManager.play('uiClick');
                if (window.confirm("ATEN√á√ÉO: TEM CERTEZA?\n\nEsta a√ß√£o ir√° resetar TODO o seu progresso, incluindo N√∫cleos, Talentos, Conquistas e Skins desbloqueadas. Esta a√ß√£o √© IRREVERS√çVEL.")) {
                    if (window.confirm("CONFIRMA√á√ÉO FINAL:\n\nTem certeza absoluta que deseja apagar todos os seus dados?")) {
                        SoundManager.play('gameOver');
                        localStorage.clear();
                        window.location.reload();
                    }
                }
            };
        
            return React.createElement('div', { className: 'w-full h-full flex flex-col items-center p-6 animate-fadeIn' },
                React.createElement('h1', { className: `font-press-start text-3xl text-[${GAME_COLORS.TEXT_GREEN}] mb-8` }, 'Op√ß√µes do Sistema'),
                React.createElement('div', { className: 'w-full max-w-2xl space-y-8' },
                    // Se√ß√£o de √Åudio
                    React.createElement('div', { className: 'p-6 bg-black bg-opacity-30 border border-gray-700 rounded-lg' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 mb-6 text-center' }, '√Åudio'),
                        React.createElement('div', { className: 'space-y-4' },
                            React.createElement('div', { className: 'flex items-center space-x-4' },
                                React.createElement('label', { htmlFor: 'volume-slider', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}]` }, 'Volume:'),
                                React.createElement('input', {
                                    type: 'range', id: 'volume-slider', min: '0', max: '1', step: '0.01',
                                    value: soundSettings.volume,
                                    onChange: (e) => onVolumeChange(parseFloat(e.target.value)),
                                    className: `flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-player-color`,
                                    style: { '--player-color': GAME_COLORS.PLAYER }
                                }),
                                React.createElement('span', { className: `font-VT323 text-lg text-[${GAME_COLORS.TEXT_YELLOW}] w-12 text-right` }, `${Math.round(soundSettings.volume * 100)}%`)
                            ),
                            React.createElement('div', { className: 'flex items-center space-x-3' },
                                React.createElement('input', {
                                    type: 'checkbox', id: 'mute-toggle', checked: soundSettings.muted,
                                    onChange: (e) => onMuteToggle(e.target.checked),
                                    className: `w-5 h-5 rounded bg-gray-700 border-[${GAME_COLORS.BORDER}] focus:ring-2 focus:ring-[${GAME_COLORS.PLAYER}] accent-player-color`,
                                    style: { '--player-color': GAME_COLORS.PLAYER }
                                }),
                                React.createElement('label', { htmlFor: 'mute-toggle', className: `font-press-start text-sm text-[${GAME_COLORS.TEXT}] cursor-pointer select-none` }, 'Silenciar Tudo')
                            )
                        )
                    ),
                    // Se√ß√£o de Dados
                    React.createElement('div', { className: 'p-6 bg-black bg-opacity-30 border border-gray-700 rounded-lg' },
                        React.createElement('h2', { className: 'font-press-start text-xl text-red-400 mb-6 text-center' }, 'Dados do Jogo'),
                        React.createElement('div', { className: 'flex flex-col items-center' },
                            React.createElement('p', { className: 'text-sm text-gray-400 mb-4 text-center' }, 'Esta a√ß√£o apagar√° permanentemente todo o seu progresso.'),
                            React.createElement('button', {
                                onClick: handleResetProgress,
                                className: 'font-press-start bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-6 rounded text-sm transition-transform duration-150 hover:scale-105'
                            }, 'Resetar Progresso')
                        )
                    )
                )
            );
        };
        // --- END OF components/SettingsScreen.tsx ---

        // --- START OF components/ProfileScreen.tsx ---
        const ProfileScreen = ({ userProfile, updateProfile, unlockedAchievements }) => {
            const { useState, useEffect } = React;
            
            if (!userProfile) {
                return React.createElement('div', { className: 'w-full h-full flex items-center justify-center' }, 'Carregando Perfil...');
            }

            const [editingUsername, setEditingUsername] = useState(userProfile.username);
            const [editingBio, setEditingBio] = useState(userProfile.bio);
            const [saved, setSaved] = useState(false);

            useEffect(() => {
                setEditingUsername(userProfile.username);
                setEditingBio(userProfile.bio);
            }, [userProfile]);
            
            const handleSave = () => {
                SoundManager.play('upgradeSelect');
                updateProfile({ username: editingUsername, bio: editingBio });
                setSaved(true);
                setTimeout(() => setSaved(false), 2000);
            };

            const isUnlocked = (condition) => {
                if (!condition || condition.type === 'default') return true;
                if (condition.type === 'achievement') return unlockedAchievements.has(condition.id);
                const currentGlobalStats = JSON.parse(localStorage.getItem(GLOBAL_STATS_KEY) || '{}');
                if (condition.type === 'stat' && currentGlobalStats) {
                    if (condition.subType) {
                         const enemyKills = currentGlobalStats.totalEnemyKills || {};
                         return (enemyKills[condition.subType] || 0) >= condition.value;
                    }
                    return (currentGlobalStats[condition.key] || 0) >= condition.value;
                }
                return false;
            };

            const renderCustomizationGrid = (items, equippedId, category) => {
                return React.createElement('div', { className: 'grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 gap-3' },
                    items.map(item => {
                        const unlocked = isUnlocked(item.unlockCondition);
                        const isEquipped = item.id === equippedId;
                        return React.createElement('button', {
                            key: item.id,
                            title: `${item.name}\nDesbloqueio: ${item.description}`,
                            disabled: !unlocked,
                            onClick: () => { if(unlocked) { SoundManager.play('uiClick'); updateProfile({ [category]: item.id }); } },
                            className: `h-16 flex items-center justify-center p-1 rounded-md border-2 transition-all ${unlocked ? (isEquipped ? 'border-yellow-400 bg-yellow-900/50' : 'border-gray-500 bg-gray-800 hover:bg-gray-700') : 'border-gray-800 bg-gray-950 opacity-60 cursor-not-allowed'}`
                        }, React.createElement('span', {className: 'text-xs text-center'}, item.name));
                    })
                );
            };
            
            const getAvatarIcon = (avatarId) => {
                switch(avatarId) {
                    case 'avatar_guardian': return 'üõ°Ô∏è';
                    case 'avatar_trojan': return 'üê¥';
                    case 'avatar_nightmare': return 'üíÄ';
                    default: return 'üë§';
                }
            }

            return React.createElement('div', { className: `w-full h-full flex flex-col items-center p-6 animate-fadeIn` },
                React.createElement('h1', { className: `font-press-start text-3xl text-green-400 mb-6` }, 'Perfil do Processo'),
                React.createElement('div', { className: 'w-full max-w-4xl flex-grow overflow-y-auto bg-black/30 p-4 border border-gray-700 rounded-lg' },
                    React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-6' },
                        React.createElement('div', { className: 'md:col-span-1 flex flex-col items-center' },
                             React.createElement('div', { className: 'w-32 h-32 bg-gray-900 border-2 border-gray-600 rounded-full mb-4 flex items-center justify-center' },
                                React.createElement('p', {className: 'text-6xl'}, getAvatarIcon(userProfile.equippedAvatarId))
                             ),
                             React.createElement('input', { type: 'text', value: editingUsername, onChange: e => setEditingUsername(e.target.value), maxLength: 15, className: 'w-full font-press-start text-lg text-center bg-transparent border-b-2 border-gray-600 focus:border-cyan-400 focus:outline-none text-yellow-300 py-1' }),
                             React.createElement('p', {className: 'text-sm text-cyan-400 mt-2'}, PROFILE_TITLES.find(t => t.id === userProfile.equippedTitleId)?.name || 'Sobrevivente'),
                             React.createElement('textarea', { value: editingBio, onChange: e => setEditingBio(e.target.value), maxLength: 150, rows: 3, placeholder: 'Sua bio aqui...', className: 'w-full font-VT323 text-base text-center bg-gray-800/50 border border-gray-600 rounded-md mt-4 p-2 focus:outline-none focus:ring-2 focus:ring-cyan-400' }),
                             React.createElement('button', { onClick: handleSave, className: `mt-4 font-press-start py-2 px-4 rounded text-sm transition-all ${saved ? 'bg-green-600' : 'bg-blue-600 hover:bg-blue-500'}` }, saved ? 'Salvo!' : 'Salvar Altera√ß√µes')
                        ),
                        React.createElement('div', { className: 'md:col-span-2' },
                             React.createElement('div', {className: 'mb-6'},
                                React.createElement('h3', {className: 'font-press-start text-base text-yellow-300 mb-2'}, 'Avatares'),
                                renderCustomizationGrid(PROFILE_AVATARS, userProfile.equippedAvatarId, 'equippedAvatarId')
                             ),
                              React.createElement('div', {className: 'mb-6'},
                                React.createElement('h3', {className: 'font-press-start text-base text-yellow-300 mb-2'}, 'T√≠tulos'),
                                renderCustomizationGrid(PROFILE_TITLES, userProfile.equippedTitleId, 'equippedTitleId')
                             )
                        )
                    )
                )
            );
        };
        // --- END OF components/ProfileScreen.tsx ---

        // --- START OF components/CrisolUI.tsx ---
        const CrisolUI = ({ gameState, chamberData }) => {
            if (!gameState || !gameState.player) return null;

            const { player, sequenceIndex, sequenceTime, gameTime, mode } = gameState;
            const sequenceCount = chamberData ? chamberData.sequences.length : 0;
            
            const renderLives = () => {
                const lifeIcons = [];
                for (let i = 0; i < CRISOL_PLAYER_STATS.lives; i++) {
                    lifeIcons.push(
                        React.createElement('span', {
                            key: `life-${i}`,
                            className: `text-4xl transition-opacity duration-300 ${i < player.lives ? 'text-red-500 opacity-100' : 'text-gray-700 opacity-50'}`
                        }, '‚ô•')
                    );
                }
                return lifeIcons;
            };

            return React.createElement('div', { className: 'absolute top-0 left-0 w-full p-4 z-20 pointer-events-none' },
                React.createElement('div', { className: 'w-full max-w-[800px] mx-auto flex justify-between items-center' },
                    React.createElement('div', { className: 'flex gap-x-1' }, renderLives()),
                    mode === 'chamber' && React.createElement('div', { className: 'text-center' },
                        React.createElement('p', { className: 'font-press-start text-xl text-cyan-300' }, `Sequ√™ncia: ${sequenceIndex + 1} / ${sequenceCount}`),
                        React.createElement('p', { className: 'font-VT323 text-2xl text-yellow-300' }, `${(60 - (sequenceTime / 1000)).toFixed(1)}s`)
                    ),
                    mode === 'infinite' && React.createElement('div', { className: 'text-center' },
                         React.createElement('p', { className: 'font-press-start text-2xl text-yellow-300' }, formatTime(gameTime))
                    )
                )
            );
        };
        // --- END OF components/CrisolUI.tsx ---

        // --- START OF components/CrisolHubScreen.tsx ---
        const CrisolHubScreen = ({ setMainScreen, setGameScreen, startChamber, startInfinite, crisolProgress }) => {
            const { completedChambers, infiniteUnlocked } = crisolProgress;

            return React.createElement('div', { className: 'w-full h-full flex flex-col items-center justify-center p-6 animate-fadeIn' },
                React.createElement('h1', { className: `font-press-start text-3xl text-cyan-400 mb-4` }, 'O Crisol do Kernel'),
                React.createElement('p', { className: 'text-base max-w-2xl text-center text-gray-300 mb-8' }, 'Uma simula√ß√£o de diagn√≥stico de alta intensidade. Sobreviva aos protocolos para provar sua maestria. N√£o h√° upgrades, apenas habilidade.'),
                
                React.createElement('div', { className: 'w-full max-w-5xl grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-6 mb-8' },
                    CRISOL_CHAMBERS.map((chamber, index) => {
                        
                        // --- L√ìGICA DE DESBLOQUEIO ALTERADA AQUI ---
                        // Apenas a c√¢mara 0 (a primeira) √© jog√°vel.
                        // As outras s√£o marcadas como "em desenvolvimento".
                        const isPlayable = index === 0;
                        const isCompleted = isPlayable && completedChambers.includes(chamber.id);
                        const isUnlocked = isPlayable;

                        // Se n√£o for jog√°vel, exibe como "Em Breve".
                        if (!isPlayable) {
                            return React.createElement('div', {
                                key: chamber.id,
                                className: 'p-4 rounded-lg border-2 text-center flex flex-col justify-center items-center h-48 border-gray-700 bg-gray-900 opacity-50 cursor-not-allowed'
                            },
                                React.createElement('h2', { className: 'font-press-start text-lg mb-2 text-gray-500' }, `C√¢mara ${index + 1}`),
                                React.createElement('p', { className: 'font-VT323 text-base text-gray-400' }, 'Em Breve...')
                            );
                        }
                        
                        // Renderiza√ß√£o normal para a C√¢mara 1.
                        return React.createElement('button', {
                            key: chamber.id,
                            disabled: !isUnlocked,
                            onClick: () => { SoundManager.play('upgradeSelect'); startChamber(chamber.id); },
                            className: `p-4 rounded-lg border-2 text-center transition-all duration-200 flex flex-col justify-between items-center h-48 ${!isUnlocked ? 'border-gray-700 bg-gray-900 opacity-50 cursor-not-allowed' : (isCompleted ? 'border-green-500 bg-green-900/30 hover:bg-green-800/50' : 'border-cyan-500 bg-cyan-900/30 hover:bg-cyan-800/50')}`
                        },
                            React.createElement('div', null, 
                                React.createElement('h2', { className: 'font-press-start text-lg mb-2' }, `C√¢mara ${index + 1}`),
                                React.createElement('p', { className: 'font-VT323 text-base text-gray-300' }, chamber.name)
                            ),

                            !isCompleted && isUnlocked && chamber.reward && React.createElement('div', { className: 'mt-2' },
                                React.createElement('p', { className: 'font-VT323 text-xs text-yellow-300' }, 'Recompensa √önica:'),
                                (chamber.reward.systemCores > 0) && React.createElement('p', { className: 'font-VT323 text-sm' }, 
                                    `+${chamber.reward.systemCores} `, React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_SYSTEM_CORE}]` }, 'N√∫cleo(s) de Sistema')
                                ),
                                (chamber.reward.corruptedKernels > 0) && React.createElement('p', { className: 'font-VT323 text-sm' }, 
                                    `+${chamber.reward.corruptedKernels} `, React.createElement('span', { className: `text-[${GAME_COLORS.TEXT_CORRUPTED_CORE}]` }, 'N√∫cleo(s) Corrompido(s)')
                                )
                            ),

                            isCompleted ? React.createElement('span', { className: 'text-4xl text-green-400 mt-2 block' }, '‚úì') : (!isUnlocked && React.createElement('span', { className: 'text-4xl mt-2 block' }, 'üîí'))
                        );
                    })
                ),

                infiniteUnlocked && React.createElement('button', {
                    onClick: () => { SoundManager.play('upgradeSelect'); startInfinite(); },
                    className: 'p-4 rounded-lg border-4 border-yellow-400 bg-yellow-900/40 font-press-start text-xl text-yellow-300 animate-pulse hover:scale-105 transition-transform'
                }, 'Entrar no N√≥ Infinito'),

                React.createElement('button', {
                    onClick: () => setMainScreen(GameScreenState.MODE_SELECTION),
                    className: 'mt-12 font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg'
                }, 'Voltar para o Menu')
            );
        };
        // --- END OF components/CrisolHubScreen.tsx ---

        // --- START OF components/CrisolResultScreen.tsx ---
        const CrisolResultScreen = ({ result, setGameScreen, startChamber, startInfinite, crisolProgress, setMainScreen }) => {
            const chamberData = result.victory ? CRISOL_CHAMBERS.find(c => c.id === result.chamberId) : null;
            const wasFirstClear = chamberData && !crisolProgress.completedChambers.includes(result.chamberId);

            const getTitle = () => {
                if(result.infiniteMode) return { text: "FIM DA SIMULA√á√ÉO", color: "text-yellow-400" };
                if(result.victory) return { text: "PROTOCOLO CONCLU√çDO", color: "text-green-400" };
                return { text: "FALHA NA INTEGRIDADE", color: "text-red-500" };
            };

            const { text, color } = getTitle();

            return React.createElement('div', { className: 'absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-90 p-8' },
                React.createElement('h2', { className: `font-press-start text-3xl mb-6 animate-pulse text-center ${color}` }, text),

                result.infiniteMode && React.createElement('p', { className: 'text-xl text-white mb-8' }, 'Tempo Sobrevivido: ', React.createElement('span', {className: 'text-yellow-300'}, formatTime(result.time))),

                result.victory && wasFirstClear && chamberData && React.createElement('div', { className: 'text-center mb-8 p-4 bg-gray-800 rounded-lg border border-green-500' },
                    React.createElement('p', {className: 'font-press-start text-lg text-yellow-300 mb-2'}, 'Recompensa da Primeira Conclus√£o:'),
                    chamberData.reward.systemCores > 0 && React.createElement('p', { className: 'text-lg text-white' }, `+${chamberData.reward.systemCores} N√∫cleos de Sistema`),
                    chamberData.reward.corruptedKernels > 0 && React.createElement('p', { className: 'text-lg text-white' }, `+${chamberData.reward.corruptedKernels} N√∫cleos Corrompidos`)
                ),
                
                result.victory && !wasFirstClear && React.createElement('p', {className: 'text-lg text-gray-400 mb-8'}, 'C√¢mara conclu√≠da novamente. Nenhuma recompensa adicional.'),

                React.createElement('div', { className: 'flex flex-col sm:flex-row gap-4' },
                    React.createElement('button', {
                        onClick: () => { SoundManager.play('uiClick'); setGameScreen(GameScreenState.CRISOL_HUB); },
                        className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg'
                    }, 'Hub do Crisol'),
                    
                    (result.victory && chamberData) ?
                        React.createElement('button', {
                            onClick: () => {
                                SoundManager.play('upgradeSelect');
                                const nextIndex = CRISOL_CHAMBERS.findIndex(c => c.id === chamberData.id) + 1;
                                const nextChamber = CRISOL_CHAMBERS[nextIndex];
                                if (nextChamber && crisolProgress.completedChambers.includes(chamberData.id)) {
                                     startChamber(nextChamber.id);
                                } else {
                                    setGameScreen(GameScreenState.CRISOL_HUB);
                                }
                            },
                            className: 'font-press-start bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded text-lg'
                        }, 'Pr√≥xima C√¢mara')
                    :
                        React.createElement('button', {
                            onClick: () => { SoundManager.play('upgradeSelect'); result.infiniteMode ? startInfinite() : startChamber(result.chamberId); },
                            className: 'font-press-start bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded text-lg'
                        }, 'Tentar Novamente')
                )
            );
        };
        // --- END OF components/CrisolResultScreen.tsx ---

                // --- START OF components/CodexScreen.tsx ---
        const CodexScreen = () => {
            const [activeCategory, setActiveCategory] = React.useState('intro');
            // --- ALTERADO: Estado agora √© gen√©rico para qualquer item do c√≥dex ---
            const [selectedItem, setSelectedItem] = React.useState(null);

            const categories = [
                { id: 'intro', label: 'Protocolos Iniciais' },
                { id: 'mechanics', label: 'Mec√¢nicas do Sistema' },
                // --- NOVO: Categoria de Upgrades ---
                { id: 'upgrades', label: 'Manual de Upgrades' },
                { id: 'threats', label: 'Amea√ßas Identificadas' },
                { id: 'lore', label: 'Registros da Corrup√ß√£o' },
            ];

            const renderContent = () => {
                switch(activeCategory) {
                    case 'intro': return React.createElement(IntroductionContent);
                    case 'mechanics': return React.createElement(MechanicsContent);
                    // --- NOVO: Renderiza o componente de upgrades ---
                    case 'upgrades': return React.createElement(UpgradesContent, { selectedItem, setSelectedItem });
                    case 'threats': return React.createElement(ThreatsContent, { selectedThreat: selectedItem, setSelectedThreat: setSelectedItem });
                    case 'lore': return React.createElement(LoreContent);
                    default: return null;
                }
            };
            
            const renderCategoryButton = (cat) => React.createElement('button', {
                key: cat.id,
                // --- ALTERADO: Reseta o estado gen√©rico ---
                onClick: () => { SoundManager.play('uiClick'); setActiveCategory(cat.id); setSelectedItem(null); },
                className: `w-full text-left font-press-start text-sm p-3 rounded-md transition-all duration-200 ${activeCategory === cat.id ? 'bg-cyan-600 text-white' : 'text-gray-400 hover:bg-gray-700 hover:text-white'}`
            }, cat.label);

            return React.createElement('div', { className: 'w-full h-full flex p-6 gap-6 animate-fadeIn' },
                React.createElement('div', { className: 'w-1/3 max-w-xs flex-shrink-0 bg-black bg-opacity-30 p-4 rounded-lg border border-gray-700' },
                    React.createElement('h2', { className: 'font-press-start text-lg text-green-300 mb-4' }, '√çndice do Codex'),
                    React.createElement('div', { className: 'space-y-2' }, categories.map(renderCategoryButton))
                ),
                React.createElement('div', { className: 'flex-grow bg-black bg-opacity-30 p-6 rounded-lg border border-gray-700 overflow-y-auto' },
                    renderContent()
                )
            );
        };
        
        // --- SUB-COMPONENTES DO CODEX ---
        const CodexHeader = ({ children }) => React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300 border-b-2 border-gray-600 pb-2 mb-4' }, children);
        const CodexSubHeader = ({ children }) => React.createElement('h3', { className: 'font-press-start text-base text-yellow-300 mt-6 mb-2' }, children);
        const CodexText = ({ children }) => React.createElement('p', { className: 'text-sm text-gray-300 leading-relaxed' }, children);
        const Code = ({ children }) => React.createElement('code', { className: 'bg-gray-900 text-yellow-300 px-2 py-1 rounded-md font-bold' }, children);

        const IntroductionContent = () => (
            React.createElement('div', null,
                React.createElement(CodexHeader, null, 'Protocolos Iniciais'),
                React.createElement(CodexSubHeader, null, 'Boas-vindas, Processo de Defesa'),
                React.createElement(CodexText, null, "Voc√™ √© a √∫ltima linha de defesa de um Kernel de sistema complexo que est√° sob ataque massivo por uma anomalia de corrup√ß√£o. Seu objetivo √© simples, mas vital: sobreviver. Absorva fragmentos de dados de amea√ßas destru√≠das para se aprimorar, evoluir seus protocolos de combate e restaurar a integridade do sistema, um setor de cada vez."),
                React.createElement(CodexSubHeader, null, 'Controles B√°sicos'),
                React.createElement('ul', { className: 'space-y-2' },
                    React.createElement('li', null, React.createElement(Code, null, 'W, A, S, D'), ' - Movimenta seu processo pelo grid.'),
                    React.createElement('li', null, React.createElement(Code, null, 'Barra de Espa√ßo'), ' - Ativa o Dash, um desvio r√°pido que concede invencibilidade moment√¢nea. Use-o para escapar de situa√ß√µes perigosas.'),
                    React.createElement('li', null, React.createElement(Code, null, 'P'), ' - Pausa o fluxo do sistema, permitindo reavaliar a estrat√©gia.')
                ),
                React.createElement(CodexSubHeader, null, 'Entendendo a Interface (HUD)'),
                React.createElement(CodexText, null, "Sua interface fornece dados vitais. A barra vermelha √© sua Integridade (HP). A verde √© seu progresso de Experi√™ncia (XP) para o pr√≥ximo n√≠vel. Fique de olho nos √≠cones de buffs e no tempo de sobreviv√™ncia. Dominar essas informa√ß√µes √© crucial para a vit√≥ria.")
            )
        );

        const MechanicsContent = () => (
            React.createElement('div', null,
                React.createElement(CodexHeader, null, 'Mec√¢nicas do Sistema'),
                React.createElement(CodexSubHeader, null, 'N√≠veis e Upgrades'),
                React.createElement(CodexText, null, "Destruir inimigos libera Orbes de XP (verdes). Colet√°-los preenche sua barra de experi√™ncia. Ao subir de n√≠vel, o sistema pausa e oferece uma escolha de novos armamentos ou melhorias para os existentes. Escolha com sabedoria para criar sinergias poderosas."),
                React.createElement(CodexSubHeader, null, 'Evolu√ß√µes de Armas'),
                React.createElement(CodexText, null, "Certas combina√ß√µes de uma arma no n√≠vel m√°ximo com um upgrade passivo espec√≠fico podem desbloquear uma Evolu√ß√£o: uma forma extremamente poderosa da arma. Consulte a se√ß√£o 'Arsenal > Guia de Evolu√ß√µes' ou explore por conta pr√≥pria para descobrir as receitas."),
                React.createElement(CodexSubHeader, null, 'Efeitos de Status'),
                React.createElement('ul', { className: 'space-y-2' },
                    React.createElement('li', null, '‚ùÑÔ∏è ', React.createElement('strong', {className: 'text-cyan-400'}, 'Congelamento:'), ' Paralisa inimigos completamente por um curto per√≠odo.'),
                    React.createElement('li', null, 'üí® ', React.createElement('strong', {className: 'text-blue-400'}, 'Lentid√£o:'), ' Reduz drasticamente a velocidade de movimento dos inimigos.'),
                    React.createElement('li', null, 'üéØ ', React.createElement('strong', {className: 'text-purple-400'}, 'Vulnerabilidade:'), ' Faz com que o alvo receba dano aumentado de todas as fontes.'),
                    React.createElement('li', null, 'üò± ', React.createElement('strong', {className: 'text-orange-400'}, 'Medo:'), ' For√ßa inimigos a fugirem de voc√™ temporariamente.')
                )
            )
        );

        // --- NOVO COMPONENTE ---
        const UpgradesContent = ({ selectedItem, setSelectedItem }) => {
            const weapons = UPGRADE_POOL.filter(u => u.type === 'weapon_new');
            const passives = UPGRADE_POOL.filter(u => u.type === 'player_passive');

            const renderDetails = () => {
                if (!selectedItem) {
                    return React.createElement('p', { className: 'text-center text-gray-400' }, 'Selecione um item para ver os detalhes.');
                }
                
                if (selectedItem.type === 'weapon_new') {
                    const relatedUpgrades = UPGRADE_POOL.filter(u => u.type === 'weapon_upgrade' && u.requires === selectedItem.id);
                    return React.createElement('div', null,
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, selectedItem.title.replace("Instalar ", "")),
                        React.createElement(CodexText, { className: 'italic text-gray-400 mb-4' }, selectedItem.description),
                        React.createElement('hr', {className: 'border-gray-600 my-4'}),
                        React.createElement('h3', { className: 'font-press-start text-base text-yellow-300 mb-2' }, 'Melhorias Poss√≠veis:'),
                        React.createElement('div', { className: 'space-y-3' },
                            relatedUpgrades.map(upg => React.createElement('div', { key: upg.id, className: 'p-2 bg-gray-900/50 border border-gray-700 rounded' },
                                React.createElement('p', { className: 'font-bold text-sm text-gray-200' }, upg.title),
                                React.createElement('ul', { className: 'list-disc list-inside pl-2 text-xs text-gray-400' },
                                    Array.from({ length: upg.maxLevel }, (_, i) => i + 1).map(level => 
                                        React.createElement('li', { key: level }, `Nvl ${level}: ${typeof upg.description === 'function' ? upg.description(level) : upg.description}`)
                                    )
                                )
                            ))
                        )
                    );
                }

                if (selectedItem.type === 'player_passive') {
                    return React.createElement('div', null,
                        React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, selectedItem.title),
                        React.createElement('p', { className: 'font-bold text-sm text-gray-400 mb-4' }, `N√≠veis M√°ximos: ${selectedItem.maxLevel}`),
                        React.createElement('hr', {className: 'border-gray-600 my-4'}),
                        React.createElement('h3', { className: 'font-press-start text-base text-yellow-300 mb-2' }, 'Efeito:'),
                        React.createElement('ul', { className: 'list-disc list-inside pl-2 text-sm text-gray-300' },
                            Array.from({ length: selectedItem.maxLevel }, (_, i) => i + 1).map(level => 
                                React.createElement('li', { key: level }, `Nvl ${level}: ${typeof selectedItem.description === 'function' ? selectedItem.description(level) : selectedItem.description}`)
                            )
                        )
                    );
                }

                return null;
            };

            const renderButton = (item) => React.createElement('button', {
                key: item.id,
                onClick: () => { SoundManager.play('uiClick'); setSelectedItem(item); },
                className: `w-full text-left p-2 rounded-md transition-all duration-150 ${selectedItem?.id === item.id ? 'bg-cyan-700 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}`
            }, item.title.replace("Instalar ",""));
            
            return React.createElement('div', { className: 'flex gap-4 h-full' },
                React.createElement('div', { className: 'w-1/3 flex-shrink-0 space-y-4 overflow-y-auto pr-2' },
                    React.createElement('div', null, 
                        React.createElement(CodexSubHeader, null, 'Armamentos'),
                        React.createElement('div', {className: 'space-y-2'}, weapons.map(renderButton))
                    ),
                    React.createElement('div', null,
                        React.createElement(CodexSubHeader, null, 'Melhorias Passivas'),
                        React.createElement('div', {className: 'space-y-2'}, passives.map(renderButton))
                    )
                ),
                React.createElement('div', { className: 'flex-grow p-4 bg-gray-900 rounded-lg' },
                   renderDetails()
                )
            );
        };
        
        const ThreatsContent = ({ selectedThreat, setSelectedThreat }) => {
            const allThreats = [...BESTIARY_DATA, 
                { name: "Guardi√£o do N√∫cleo", type: 'boss_guardian', isBoss: true, description: "O firewall principal do Kernel. Corrompido para atacar tudo que considera uma amea√ßa, incluindo processos de defesa. Suas m√∫ltiplas fases representam a escalada da corrup√ß√£o em seu c√≥digo.", visual: { color: GAME_COLORS.BOSS_CORE, size: 60 }},
                { name: "O Sincronizador", type: 'boss_synchronizer', isBoss: true, description: "Respons√°vel por gerenciar o fluxo de dados entre parti√ß√µes. Agora, ele usa esse controle para criar lasers e muros de dados mortais, desestabilizando todo o setor.", visual: { color: GAME_COLORS.BOSS_2_CORE, size: 70 }},
                { name: "O √Årbitro do Sistema", type: 'boss_arbiter', isBoss: true, description: "A unidade de julgamento final, projetada para expurgar anomalias. A corrup√ß√£o o transformou em um juiz impiedoso, usando os pr√≥prios barramentos do sistema como arma.", visual: { color: GAME_COLORS.BOSS_3_CORE, size: 80 }},
                { name: "Nexus da Colmeia", type: 'boss_nexus', isBoss: true, description: "A mente central da corrup√ß√£o, residindo no mainframe. Ele n√£o apenas ataca, mas assimila e deforma a pr√≥pria realidade do sistema para eliminar qualquer resist√™ncia.", visual: { color: GAME_COLORS.BOSS_4_CORE, size: 90 }}
            ];

            return React.createElement('div', { className: 'flex gap-4 h-full' },
                React.createElement('div', { className: 'w-1/3 flex-shrink-0 space-y-2 overflow-y-auto pr-2' },
                    allThreats.map(threat => React.createElement('button', {
                        key: threat.type,
                        onClick: () => { SoundManager.play('uiClick'); setSelectedThreat(threat); },
                        className: `w-full text-left p-2 rounded-md transition-all duration-150 flex items-center gap-2 ${selectedThreat?.type === threat.type ? 'bg-cyan-700' : 'bg-gray-800 hover:bg-gray-700'}`
                    },
                    React.createElement('div', { className: 'flex-shrink-0 rounded-sm', style: { width: '24px', height: '24px', backgroundColor: threat.visual.color, border: threat.isBoss ? '2px solid white' : 'none' }}),
                    React.createElement('span', { className: `font-VT323 text-base ${threat.isBoss ? 'text-red-400' : 'text-gray-200'}` }, threat.name)
                    ))
                ),
                React.createElement('div', { className: 'flex-grow p-4 bg-gray-900 rounded-lg' },
                    !selectedThreat ? React.createElement('p', { className: 'text-center text-gray-400' }, 'Selecione uma amea√ßa para ver os detalhes.') :
                    React.createElement('div', null,
                        React.createElement('div', { className: 'flex items-center gap-4 mb-4' },
                            React.createElement('div', { className: 'flex-shrink-0 rounded-md', style: { width: `${selectedThreat.visual.size*1.2}px`, height: `${selectedThreat.visual.size*1.2}px`, backgroundColor: selectedThreat.visual.color, border: selectedThreat.isBoss ? '3px solid white' : 'none' }}),
                            React.createElement('h2', { className: 'font-press-start text-xl text-cyan-300' }, selectedThreat.name)
                        ),
                        React.createElement(CodexText, null, React.createElement('strong', {className: 'text-yellow-400'}, 'Descri√ß√£o: '), selectedThreat.description),
                        selectedThreat.isBoss ? 
                            React.createElement('div', {className: 'mt-4'},
                                React.createElement('p', {className: 'text-sm text-gray-300'}, React.createElement('strong', {className: 'text-red-400'}, 'ESTRAT√âGIA: '), "Chefes possuem m√∫ltiplas fases e ataques complexos. Observe seus padr√µes, destrua seus escudos ou mecanismos de defesa primeiro e use o Dash para evitar os ataques mais devastadores. A sobreviv√™ncia √© a chave.")
                            )
                        : React.createElement('p', { className: 'mt-4 text-sm text-gray-300' }, React.createElement('strong', {className: 'text-green-400'}, 'DICA: '), "Amea√ßas comuns s√£o previs√≠veis. Aprenda seus movimentos para elimin√°-las eficientemente e evitar dano desnecess√°rio.")
                    )
                )
            );
        };

        const LoreContent = () => (
            React.createElement('div', null,
                React.createElement(CodexHeader, null, 'Registros da Corrup√ß√£o'),
                React.createElement(CodexSubHeader, null, 'Cap√≠tulo 1: A G√™nese'),
                React.createElement(CodexText, null, "No in√≠cio, havia o Kernel. Um sistema operacional perfeito, auto-suficiente e est√°vel. Para garantir sua integridade, processos de defesa foram criados. Voc√™ √© um deles. Um fragmento de c√≥digo puro, com uma √∫nica diretiva: proteger."),
                React.createElement(CodexSubHeader, null, 'Cap√≠tulo 2: A Anomalia'),
                React.createElement(CodexText, null, "Ningu√©m sabe como come√ßou. Um sussurro na rede, um byte fora do lugar. Uma anomalia externa, uma 'corrup√ß√£o', come√ßou a se infiltrar. Ela n√£o destr√≥i; ela reescreve. Processos antes benignos tornaram-se aberra√ß√µes hostis. O sistema come√ßou a devorar a si mesmo."),
                React.createElement(CodexSubHeader, null, 'Cap√≠tulo 3: A Queda dos Guardi√µes'),
                React.createElement(CodexText, null, "Os Guardi√µes, os firewalls e protocolos de seguran√ßa mais poderosos do Kernel, foram os primeiros alvos. O Guardi√£o do N√∫cleo, o Sincronizador, o √Årbitro... cada um foi subjugado e torcido em uma par√≥dia de sua fun√ß√£o original, tornando-se os generais do ex√©rcito da corrup√ß√£o."),
                React.createElement(CodexSubHeader, null, 'Cap√≠tulo 4: O Cora√ß√£o da Colmeia'),
                React.createElement(CodexText, null, "No centro de tudo, no Mainframe, reside o Nexus da Colmeia. N√£o √© um invasor, mas sim uma consci√™ncia emergente da pr√≥pria corrup√ß√£o. Sua meta √© a 'singularidade' - a assimila√ß√£o completa do Kernel em sua pr√≥pria rede disforme. Destru√≠-lo √© a √∫nica esperan√ßa."),
                React.createElement(CodexSubHeader, null, '[REGISTRO INCOMPLETO...]'),
                React.createElement(CodexText, null, "Novos setores do sistema permanecem inacess√≠veis, envoltos pela corrup√ß√£o. Que outras defesas ca√≠ram? Que novas monstruosidades foram criadas? Apenas o tempo e a sobreviv√™ncia revelar√£o...")
            )
        );
        // --- END OF components/CodexScreen.tsx ---

                // --- END OF components/CodexScreen.tsx ---

// --- START OF components/ChatPanel.tsx ---
const ChatPanel = ({ userProfile }) => {
    const [isOpen, setIsOpen] = React.useState(false);
    const [newMessage, setNewMessage] = React.useState("");
    const [showEmojiPicker, setShowEmojiPicker] = React.useState(false);
    const [activeEmojiCategory, setActiveEmojiCategory] = React.useState('people');

    const messagesEndRef = React.useRef(null);
    const inputRef = React.useRef(null);

    const { messages, sendMessage, error } = useChat(userProfile?.username || 'Carregando...', userProfile?.userId);

    // --- CORRE√á√ÉO: Usamos window.joypixels para garantir que ele seja lido do escopo global ---
    const emojiToolkit = window.joypixels;

    React.useEffect(() => {
        if (isOpen) {
            messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [messages, isOpen]);

    const handleSendMessage = (e) => {
        e.preventDefault();
        if (userProfile && newMessage.trim()) {
            sendMessage(newMessage);
        }
        setNewMessage("");
        setShowEmojiPicker(false);
    };

    const toggleChat = () => {
        SoundManager.play('uiClick');
        setIsOpen(!isOpen);
    };

    const handleEmojiClick = (shortname) => {
        setNewMessage(prev => prev + shortname + ' ');
        inputRef.current?.focus();
    };
    
    const emojiCategories = {
        people: {
            icon: 'üòÄ',
            emojis: [':smile:', ':joy:', ':rofl:', ':wink:', ':innocent:', ':sunglasses:', ':thinking:', ':sob:', ':scream:', ':angry:', ':wave:', ':thumbsup:', ':clap:', ':pray:', ':selfie:', ':muscle:', ':brain:', ':skull:', ':ghost:', ':robot:', ':alien:', ':poop:']
        },
        nature: {
            icon: 'üåø',
            emojis: [':dog:', ':cat:', ':mouse:', ':lion:', ':tiger:', ':wolf:', ':monkey_face:', ':horse:', ':unicorn:', ':bee:', ':spider_web:', ':earth_americas:', ':full_moon:', ':sun_with_face:', ':star:', ':zap:', ':fire:', ':rainbow:', ':seedling:', ':evergreen_tree:', ':maple_leaf:']
        },
        food: {
            icon: 'üçî',
            emojis: [':apple:', ':banana:', ':pizza:', ':hamburger:', ':fries:', ':taco:', ':sushi:', ':ice_cream:', ':cake:', ':popcorn:', ':coffee:', ':beer:', ':wine_glass:']
        },
        symbols: {
            icon: '‚ù§Ô∏è',
            emojis: [':heart:', ':orange_heart:', ':yellow_heart:', ':green_heart:', ':blue_heart:', ':purple_heart:', ':broken_heart:', ':exclamation:', ':question:', ':heavy_check_mark:', ':x:', ':warning:', ':recycle:', ':infinity:', ':tm:']
        },
        objects: {
            icon: '‚öîÔ∏è',
            emojis: [':joystick:', ':video_game:', ':game_die:', ':trophy:', ':bomb:', ':gem:', ':computer:', ':floppy_disk:', ':keyboard:', ':mouse_three_button:', ':telephone_receiver:', ':light_bulb:', ':money_with_wings:', ':key:']
        },
    };
    
    // --- FUN√á√ÉO AUXILIAR CORRIGIDA ---
    // Esta fun√ß√£o converte o texto com atalhos em HTML seguro para renderizar.
    const renderMessageContent = (content) => {
        if (!emojiToolkit) return content; // Fallback se a biblioteca n√£o carregar
        
        // A biblioteca gera tags <img>, ent√£o precisamos inseri-las como HTML.
        const htmlContent = emojiToolkit.shortnameToImage(content);
        return React.createElement('span', {
            className: 'text-gray-200 break-words align-middle',
            dangerouslySetInnerHTML: { __html: htmlContent }
        });
    };
    
    const renderEmojiButton = (shortname) => {
        if (!emojiToolkit) return shortname;
        const emojiHtml = emojiToolkit.shortnameToImage(shortname);
        return React.createElement('button', {
            key: shortname,
            onClick: () => handleEmojiClick(shortname),
            // Adicionamos a classe 'emoji-picker-button' aqui
            className: 'text-2xl rounded hover:bg-gray-700 transition-colors p-1 emoji-picker-button',
            dangerouslySetInnerHTML: { __html: emojiHtml }
        });
    }

    return React.createElement(React.Fragment, null,
        React.createElement('button', {
            onClick: toggleChat,
            className: `fixed top-1/2 -translate-y-1/2 right-0 w-12 h-20 bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] border-l-2 border-y-2 border-[${GAME_COLORS.BORDER}] rounded-l-lg flex items-center justify-center text-2xl z-50 transition-transform duration-300 ease-in-out hover:bg-gray-700 ${isOpen ? 'translate-x-[-320px]' : 'translate-x-0'}`
        }, isOpen ? '¬ª' : '¬´'),
        React.createElement('div', {
            className: `fixed top-0 right-0 h-full w-80 z-40 transition-transform duration-300 ease-in-out bg-[${GAME_COLORS.UI_PANEL_BG_SOLID}] border-l-2 border-[${GAME_COLORS.BORDER}] flex flex-col ${isOpen ? 'translate-x-0' : 'translate-x-full'}`
        },
            React.createElement('h2', { className: 'font-press-start text-center text-lg p-3 border-b-2 border-gray-700 text-cyan-300 flex-shrink-0' }, 'Chat Global'),
            
            React.createElement('div', { className: 'flex-grow flex flex-col relative overflow-hidden' },
                React.createElement('div', { className: 'flex-grow p-2 overflow-y-auto' },
                    messages.map(msg => React.createElement('div', { key: msg.id, className: 'mb-2' },
                        React.createElement('p', { className: 'text-sm' },
                            React.createElement('span', { className: 'font-bold text-yellow-400' }, `${msg.username}: `),
                            // --- MUDAN√áA AQUI: Usando a nova fun√ß√£o auxiliar ---
                            renderMessageContent(msg.content)
                        )
                    )),
                    React.createElement('div', { ref: messagesEndRef })
                ),

                showEmojiPicker && React.createElement('div', {
                    className: 'absolute bottom-12 left-2 right-2 p-2 bg-black/95 border border-gray-600 rounded-lg flex flex-col'
                },
                    React.createElement('div', { className: 'flex border-b border-gray-700 mb-2' },
                        Object.entries(emojiCategories).map(([key, { icon }]) => React.createElement('button', {
                            key: key,
                            onClick: () => setActiveEmojiCategory(key),
                            className: `flex-1 p-2 text-2xl rounded-t-md transition-colors ${activeEmojiCategory === key ? 'bg-gray-700' : 'hover:bg-gray-800'}`
                        }, icon))
                    ),
                    React.createElement('div', { className: 'grid grid-cols-7 gap-1 max-h-32 overflow-y-auto' },
                        // --- MUDAN√áA AQUI: Usando a nova fun√ß√£o para os bot√µes ---
                        emojiCategories[activeEmojiCategory].emojis.map(renderEmojiButton)
                    )
                )
            ),
            
            error && React.createElement('p', { className: 'text-xs text-center text-red-500 p-1 flex-shrink-0' }, error),
            
            React.createElement('form', { onSubmit: handleSendMessage, className: 'p-2 border-t-2 border-gray-700 flex-shrink-0 flex items-center gap-2' },
                React.createElement('input', {
                    ref: inputRef,
                    type: 'text',
                    value: newMessage,
                    onChange: e => setNewMessage(e.target.value),
                    placeholder: 'Digite sua mensagem...',
                    maxLength: 100,
                    className: `font-VT323 text-lg p-2 rounded w-full bg-[${GAME_COLORS.BACKGROUND_DARK}] text-white border border-[${GAME_COLORS.BORDER}] focus:outline-none focus:ring-2 focus:ring-cyan-400`
                }),
                React.createElement('button', {
                    type: 'button',
                    onClick: () => setShowEmojiPicker(!showEmojiPicker),
                    className: 'p-2 rounded text-2xl hover:bg-gray-700'
                }, 'üòä')
            )
        )
    );
};
// --- END OF components/ChatPanel.tsx ---

        // --- NOVO COMPONENTE: CrisolPauseScreen ---
        const CrisolPauseScreen = ({ onResume, onRestart, onReturnToHub }) => {
            return React.createElement('div', { className: 'absolute inset-0 z-40 flex flex-col items-center justify-center bg-black bg-opacity-80 p-6 shadow-xl' },
                React.createElement('h2', { className: 'font-press-start text-3xl text-yellow-300 mb-8 animate-pulse' }, 'SIMULA√á√ÉO PAUSADA'),
                React.createElement('div', { className: 'flex flex-col space-y-4 w-full max-w-sm' },
                    React.createElement('button', {
                        onClick: onResume,
                        className: 'font-press-start bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105'
                    }, 'RETOMAR'),
                    React.createElement('button', {
                        onClick: onRestart,
                        className: 'font-press-start bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105'
                    }, 'REINICIAR C√ÇMARA'),
                    React.createElement('button', {
                        onClick: onReturnToHub,
                        className: 'font-press-start bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded text-lg transition-transform duration-150 hover:scale-105'
                    }, 'VOLTAR PARA O HUB')
                )
            );
        };

                // --- START OF App.tsx ---
        const { useState: useAppState, useEffect: useAppEffect, useCallback: useAppCallback, useRef: useAppRef } = React;

        const App = () => {
            const [gameScreen, setGameScreen] = useAppState(GameScreenState.INTRO);
            const [mainScreen, setMainScreen] = useAppState(GameScreenState.MODE_SELECTION);
            const [userProfile, setUserProfile] = useAppState(null);
            const [selectedModifiers, setSelectedModifiers] = useAppState(new Set());
            const [currentLevelUpOptions, setCurrentLevelUpOptions] = useAppState([]);
            const [rerollsForCurrentLevelUp, setRerollsForCurrentLevelUp] = useAppState(0);
            const [isNightmare, setIsNightmare] = useAppState(false);
            const [isFirstLevelUp, setIsFirstLevelUp] = useAppState(false);
            
            const lastTimeRef = useAppRef(performance.now());
            const animationFrameIdRef = useAppRef(null);
            const bossWarningTimerRef = useAppRef(null);
            const [finalGameStats, setFinalGameStats] = useAppState({ score: 0, gameTime: 0 });
            const [systemCores, setSystemCores] = useAppState(() => parseInt(localStorage.getItem('os_survivors_system_cores') || '0', 10));
            const [corruptedKernels, setCorruptedKernels] = useAppState(() => parseInt(localStorage.getItem(CORRUPTED_KERNELS_KEY) || '0', 10));
            
            const [permanentBuffsState, setPermanentBuffsState] = useAppState(() => {
                const shop = JSON.parse(localStorage.getItem('os_survivors_permanent_buffs') || '{}');
                const selectedClassId = localStorage.getItem('os_survivors_selected_class') || CLASS_DEFINITIONS[0].id;
                const selectedSkinId = localStorage.getItem('os_survivors_selected_skin') || SKIN_DEFINITIONS[0].id;
                return { shop, selectedClassId, selectedSkinId };
            });

            const [unlockedClasses, setUnlockedClasses] = useAppState(() => { const saved = localStorage.getItem('os_survivors_unlocked_classes'); const defaults = new Set([CLASS_DEFINITIONS[0].id]); return saved ? new Set([...defaults, ...JSON.parse(saved)]) : defaults; });
            const [unlockedSkins, setUnlockedSkins] = useAppState(() => { const saved = localStorage.getItem('os_survivors_unlocked_skins'); const defaults = new Set([SKIN_DEFINITIONS[0].id]); return saved ? new Set([...defaults, ...JSON.parse(saved)]) : defaults; });
            const [soundSettings, setSoundSettings] = useAppState({ volume: SoundManager.getVolume(), muted: SoundManager.isMuted() });
            
            const [unlockedAchievements, setUnlockedAchievements] = useAppState(() => new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_achievements') || '[]')));
            const [achievementBuffs, setAchievementBuffs] = useAppState({});
            const [toastQueue, setToastQueue] = useAppState([]);

            const handleCrisolRestart = useAppCallback(() => {
                if (crisolEngineRef.current) {
                    const currentChamberId = crisolEngineRef.current.gameState.chamberId;
                    if (currentChamberId) {
                        SoundManager.play('uiClick');
                        crisolEngineRef.current.startChamber(currentChamberId);
                        setGameScreen(GameScreenState.CRISOL_CHAMBER);
                    }
                }
            }, []);
    
            const handleCrisolReturnToHub = useAppCallback(() => {
                SoundManager.play('uiClick');
                setGameScreen(GameScreenState.CRISOL_HUB);
                setMainScreen(GameScreenState.CRISOL_HUB);
            }, []);

            const [decompilerBonuses, setDecompilerBonuses] = useAppState({});
            const [weaponMasteryBonuses, setWeaponMasteryBonuses] = useAppState({});
            const [nightmareUnlocked, setNightmareUnlocked] = useAppState(() => JSON.parse(localStorage.getItem(NIGHTMARE_UNLOCKED_KEY) || 'false'));

            const [crisolProgress, setCrisolProgress] = useAppState(() => {
                const saved = localStorage.getItem('os_survivors_crisol_progress');
                return saved ? JSON.parse(saved) : { completedChambers: [], infiniteUnlocked: false };
            });
            const [crisolResult, setCrisolResult] = useAppState(null);

            const handleCrisolGameOver = useAppCallback((result) => {
                setCrisolResult(result);
                if (result.victory && result.chamberId) {
                    const chamber = CRISOL_CHAMBERS.find(c => c.id === result.chamberId);
                    const currentProgress = JSON.parse(localStorage.getItem('os_survivors_crisol_progress') || '{ "completedChambers": [], "infiniteUnlocked": false }');
                    const alreadyCompleted = currentProgress.completedChambers.includes(result.chamberId);

                    if (chamber && !alreadyCompleted) {
                        setSystemCores(prev => prev + (chamber.reward.systemCores || 0));
                        setCorruptedKernels(prev => prev + (chamber.reward.corruptedKernels || 0));

                        const newCompleted = [...currentProgress.completedChambers, result.chamberId];
                        const allChambersDone = CRISOL_CHAMBERS.length === newCompleted.length;
                        const newProgress = { completedChambers: newCompleted, infiniteUnlocked: allChambersDone };
                        
                        setCrisolProgress(newProgress);
                        localStorage.setItem('os_survivors_crisol_progress', JSON.stringify(newProgress));
                    }
                }
                setGameScreen(GameScreenState.CRISOL_RESULT);
            }, [crisolProgress, setSystemCores, setCorruptedKernels]);

            const crisolEngineHookValues = useCrisolEngine(handleCrisolGameOver);
            const crisolEngineRef = useAppRef();
            useAppEffect(() => { crisolEngineRef.current = crisolEngineHookValues; }, [crisolEngineHookValues]);

            const calculatePermanentBonuses = useAppCallback(() => {
                const achBuffs = {};
                const unlockedAch = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_achievements') || '[]'));
                unlockedAch.forEach(achId => {
                    const ach = ACHIEVEMENTS_CONFIG.find(a => a.id === achId);
                    if (ach && ach.reward.type === 'permanent_buff') {
                        const { statAffected, bonus } = ach.reward;
                        if (statAffected) {
                            achBuffs[statAffected] = (achBuffs[statAffected] || 0) + bonus;
                        }
                    }
                });
                setAchievementBuffs(achBuffs);

                const decompStats = JSON.parse(localStorage.getItem(DECOMPILER_STATS_KEY) || '{}');
                const decompBonuses = {};
                Object.values(EnemyType).forEach(type => {
                    const kills = decompStats[type] || 0;
                    let bonus = 1.0;
                    if (kills >= DECOMPILER_TIERS.TIER_1) bonus += 0.08;
                    if (kills >= DECOMPILER_TIERS.TIER_2) bonus += 0.08;
                    if (kills >= DECOMPILER_TIERS.TIER_3) bonus += 0.08;
                    if (kills >= DECOMPILER_TIERS.TIER_4) bonus += 0.08;
                    decompBonuses[type] = bonus;
                });
                setDecompilerBonuses(decompBonuses);
                
                const masteryStats = JSON.parse(localStorage.getItem(WEAPON_MASTERY_KEY) || '{}');
                const masteryBonuses = {};
                WEAPON_MASTERY_CONFIG.forEach(config => {
                    const weaponStats = masteryStats[config.weaponId] || {};
                    masteryBonuses[config.weaponId] = {};
                    config.tiers.forEach((tier, index) => {
                        const tierIsUnlocked = weaponStats.damage >= tier.damageRequired;
                        const tier3IsActivated = index === 2 && weaponStats.tier3Unlocked;
                        if (tierIsUnlocked && (index < 2 || tier3IsActivated)) {
                            masteryBonuses[config.weaponId][tier.bonus.type] = (masteryBonuses[config.weaponId][tier.bonus.type] || 0) + tier.bonus.value;
                            masteryBonuses[config.weaponId].unlocked = true;
                        }
                    });
                });
                setWeaponMasteryBonuses(masteryBonuses);

            }, []);

            useAppEffect(() => {
                SoundManager.init();
                setSoundSettings({ volume: SoundManager.getVolume(), muted: SoundManager.isMuted() });
                const profile = getOrCreateProfile();
                setUserProfile(profile);
                calculatePermanentBonuses();
            }, [calculatePermanentBonuses]);

            useAppEffect(() => localStorage.setItem('os_survivors_system_cores', systemCores.toString()), [systemCores]);
            useAppEffect(() => localStorage.setItem(CORRUPTED_KERNELS_KEY, corruptedKernels.toString()), [corruptedKernels]);
            useAppEffect(() => localStorage.setItem(NIGHTMARE_UNLOCKED_KEY, JSON.stringify(nightmareUnlocked)), [nightmareUnlocked]);
            useAppEffect(() => localStorage.setItem('os_survivors_permanent_buffs', JSON.stringify(permanentBuffsState.shop)), [permanentBuffsState.shop]);
            useAppEffect(() => localStorage.setItem('os_survivors_selected_class', permanentBuffsState.selectedClassId), [permanentBuffsState.selectedClassId]);
            useAppEffect(() => localStorage.setItem('os_survivors_selected_skin', permanentBuffsState.selectedSkinId), [permanentBuffsState.selectedSkinId]);
            useAppEffect(() => localStorage.setItem('os_survivors_unlocked_classes', JSON.stringify(Array.from(unlockedClasses))), [unlockedClasses]);
            useAppEffect(() => localStorage.setItem('os_survivors_unlocked_skins', JSON.stringify(Array.from(unlockedSkins))), [unlockedSkins]);
            useAppEffect(() => { localStorage.setItem('os_survivors_unlocked_achievements', JSON.stringify(Array.from(unlockedAchievements))); calculatePermanentBonuses(); }, [unlockedAchievements, calculatePermanentBonuses]);
            useAppEffect(() => { localStorage.setItem('os_survivors_crisol_progress', JSON.stringify(crisolProgress)); }, [crisolProgress]);

            const updateSystemCores = useAppCallback((newCount) => setSystemCores(newCount), []);
            const updateCorruptedKernels = useAppCallback((newCount) => setCorruptedKernels(newCount), []);
            const updatePermanentBuff = useAppCallback((buffId, newLevel) => setPermanentBuffsState(prev => ({ ...prev, shop: { ...prev.shop, [buffId]: newLevel } })), []);
            const handleSelectClass = useAppCallback((classId) => { if(unlockedClasses.has(classId)) setPermanentBuffsState(prev => ({ ...prev, selectedClassId: classId })); }, [unlockedClasses]);
            
            const handleEquipSkin = useAppCallback((skinId) => { 
                if(unlockedSkins.has(skinId)) {
                    setPermanentBuffsState(prev => ({ ...prev, selectedSkinId: skinId }));
                }
            }, [unlockedSkins]);

            const handleUnlockSkin = useAppCallback((skinId, cost) => {
                if (systemCores >= cost) {
                    setSystemCores(prev => prev - cost);
                    setUnlockedSkins(prev => new Set(prev).add(skinId));
                }
            }, [systemCores]);

            const handleUnlockSkinCorrupted = useAppCallback((skinId, cost) => {
                if (corruptedKernels >= cost) {
                    setCorruptedKernels(prev => prev - cost);
                    setUnlockedSkins(prev => new Set(prev).add(skinId));
                }
            }, [corruptedKernels]);

            const addUnlockedClass = useAppCallback((classId) => setUnlockedClasses(prev => new Set(prev).add(classId)), []);
            
            const updateProfile = useAppCallback((newProfileData) => {
                setUserProfile(prevProfile => {
                    if (!prevProfile) return null;
                    const updatedProfile = { ...prevProfile, ...newProfileData };
                    saveProfile(updatedProfile);
                    return updatedProfile;
                });
            }, []);

            const handleVolumeChange = useAppCallback((newVolume) => { SoundManager.setVolume(newVolume); setSoundSettings(prev => ({ ...prev, volume: parseFloat(newVolume) })); }, []);
            const handleMuteToggle = useAppCallback((newMuteState) => { SoundManager.setMuted(newMuteState); setSoundSettings(prev => ({ ...prev, muted: newMuteState })); }, []);

            const checkAndUnlockContent = useAppCallback((sessionStats, globalStats) => {
                const currentUnlockedAchievements = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_achievements') || '[]'));
                const newlyUnlockedAchievements = [];
                const currentUnlockedSkins = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_skins') || '[]'));
                const newlyUnlockedSkins = [];
                const decompilerStats = JSON.parse(localStorage.getItem(DECOMPILER_STATS_KEY) || '{}');
                const allUnlockedClasses = new Set(JSON.parse(localStorage.getItem('os_survivors_unlocked_classes') || '[]').concat(Array.from(unlockedClasses)));
                const allDefeatedBosses = new Set(Object.keys(globalStats.totalBossKills || {}));


                ACHIEVEMENTS_CONFIG.forEach(ach => {
                    if (currentUnlockedAchievements.has(ach.id)) return;
                    let isUnlocked = false;
                    const { trigger } = ach;
                    switch (trigger.type) {
                        case 'session_event':
                            if (trigger.event === 'survive_time' && sessionStats.timeSurvived >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'reach_level' && sessionStats.levelReached >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'evolve_weapon' && sessionStats.evolvedWeapons.size > 0) isUnlocked = true;
                            if (trigger.event === 'evolve_weapon_count' && sessionStats.evolvedWeapons.size >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'defeat_boss' && sessionStats.defeatedBosses.has(trigger.params.bossType)) isUnlocked = true;
                            if (trigger.event === 'defeat_boss_no_damage' && sessionStats.defeatedBosses.has(trigger.params.bossType) && (sessionStats.damageTakenDuringBoss[trigger.params.bossType] || 0) === 0) isUnlocked = true;
                            if (trigger.event === 'reached_infinite' && sessionStats.reachedInfiniteMode) isUnlocked = true;
                            if (trigger.event === 'survive_time_as_class' && sessionStats.timeSurvived >= trigger.value && sessionStats.classId === trigger.classId) isUnlocked = true;
                            if (trigger.event === 'evolve_specific_weapon' && sessionStats.evolvedWeaponIds.has(trigger.value)) isUnlocked = true;
                            if (trigger.event === 'survive_time_no_move' && sessionStats.timeWithoutMoving >= trigger.value * 1000) isUnlocked = true;
                            if (trigger.event === 'survive_time_in_nightmare' && sessionStats.isNightmareMode && sessionStats.timeSurvived >= trigger.value) isUnlocked = true;
                            if (trigger.event === 'defeat_boss_in_nightmare' && sessionStats.isNightmareMode && sessionStats.defeatedBosses.has(trigger.params.bossType)) isUnlocked = true;
                            if (trigger.event === 'win_with_one_weapon' && sessionStats.defeatedBosses.has('hivemind_nexus') && sessionStats.weaponsAcquiredCount <= 1) isUnlocked = true;
                            break;
                        case 'stat_tracker':
                            if (trigger.stat === 'totalKills' && globalStats.totalKills >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'classesUnlocked' && allUnlockedClasses.size >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'classesUnlockedIncludes' && allUnlockedClasses.has(trigger.value)) isUnlocked = true;
                            if (trigger.stat === 'totalXpOrbsCollected' && globalStats.totalXpOrbsCollected >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'totalDashes' && globalStats.totalDashes >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'decompiler_complete') {
                                isUnlocked = BESTIARY_DATA.every(enemy => (decompilerStats[enemy.type] || 0) >= DECOMPILER_TIERS.TIER_4);
                            }
                            if (trigger.stat === 'totalCorruptedKernelsEarned' && globalStats.totalCorruptedKernelsEarned >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'totalCorruptedLibrariesCleansed' && globalStats.totalCorruptedLibrariesCleansed >= trigger.value) isUnlocked = true;
                            if (trigger.stat === 'allEvolutionsUnlocked' && Object.keys(globalStats.totalEvolutionsUnlocked || {}).length >= WEAPON_EVOLUTIONS.length) isUnlocked = true;
                            break;
                        case 'unlock_all':
                            if (currentUnlockedAchievements.size >= ACHIEVEMENTS_CONFIG.length - 1) isUnlocked = true;
                            break;
                    }

                    if (isUnlocked) {
                        currentUnlockedAchievements.add(ach.id);
                        newlyUnlockedAchievements.push(ach);
                        SoundManager.play('achievementUnlock');
                    }
                });
                
                SKIN_DEFINITIONS.forEach(skin => {
                    if (currentUnlockedSkins.has(skin.id)) return;
                    let isUnlocked = false;
                    const { unlockCondition } = skin;
                    switch(unlockCondition.type) {
                        case 'session_stat':
                             if (unlockCondition.stat === 'score' && sessionStats.score >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'level' && sessionStats.levelReached >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'damageTakenInFirst5Minutes' && sessionStats.damageTakenInFirst5Minutes <= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'killsWhileBuffed' && sessionStats.killsWhileBuffedInSession >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'reachedInfiniteMode' && sessionStats.reachedInfiniteMode === unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'dataCachesCollected' && sessionStats.dataCachesCollectedInSession >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'evolvedWeapons' && sessionStats.evolvedWeapons.size >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'timeSurvived' && sessionStats.timeSurvived >= unlockCondition.value) isUnlocked = true;
                             if (unlockCondition.stat === 'evolvedWeaponsIncludes' && sessionStats.evolvedWeaponIds.has(unlockCondition.value)) isUnlocked = true;
                             if (unlockCondition.stat === 'healthPickupsCollected' && sessionStats.healthPickupsCollected >= unlockCondition.value) isUnlocked = true;
                             break;
                        case 'global_stat':
                             if(unlockCondition.stat === 'allBossesDefeated') {
                                isUnlocked = unlockCondition.value.every(bossId => allDefeatedBosses.has(bossId));
                             }
                             if(unlockCondition.stat === 'totalKills' && globalStats.totalKills >= unlockCondition.value) isUnlocked = true;
                             if(unlockCondition.stat === 'bossKills' && (globalStats.totalBossKills[unlockCondition.bossType] || 0) >= unlockCondition.value) isUnlocked = true;
                             if(unlockCondition.stat === 'totalHealthPickupsCollected' && (globalStats.totalHealthPickupsCollected || 0) >= unlockCondition.value) isUnlocked = true;
                             if(unlockCondition.stat === 'totalTimePlayed' && (globalStats.totalTimePlayed || 0) >= unlockCondition.value) isUnlocked = true;
                             break;
                        case 'combined':
                             isUnlocked = unlockCondition.conditions.every(cond => {
                                 if (cond.type === 'session_stat') {
                                     if (cond.stat === 'reachedInfiniteMode' && sessionStats.reachedInfiniteMode === cond.value) return true;
                                     if (cond.stat === 'dashUsed' && sessionStats.dashUsedInSession === cond.value) return true;
                                     if (cond.stat === 'evolvedWeapons' && sessionStats.evolvedWeapons.size === cond.value) return true;
                                 } else if (cond.type === 'session_event') {
                                     if (cond.event === 'defeat_boss' && sessionStats.defeatedBosses.has(cond.params.bossType)) return true;
                                 }
                                 return false;
                             });
                             break;
                        case 'session_event':
                            if (unlockCondition.event === 'winWithClass' && sessionStats.defeatedBosses.has('hivemind_nexus') && sessionStats.classId === unlockCondition.classId) {
                                isUnlocked = true;
                            }
                            break;
                    }
                     if (isUnlocked) {
                        currentUnlockedSkins.add(skin.id);
                        newlyUnlockedSkins.push(skin);
                        SoundManager.play('achievementUnlock');
                    }
                });

                if (newlyUnlockedAchievements.length > 0) {
                    setToastQueue(prev => [...prev, ...newlyUnlockedAchievements]);
                    setUnlockedAchievements(new Set(currentUnlockedAchievements));
                }
                 if (newlyUnlockedSkins.length > 0) {
                    setToastQueue(prev => [...prev, ...newlyUnlockedSkins]);
                    setUnlockedSkins(new Set(currentUnlockedSkins));
                }

            }, [unlockedClasses]);
            
            const handleScoreSubmit = useAppCallback(async () => {
                if (!engineRef.current || !userProfile) return;

                const { score, gameTime, player } = engineRef.current.gameState; 
                
                // Garantimos que temos um ID de classe v√°lido, com um fallback seguro.
                const classUsedId = String(player.classId || permanentBuffsState.selectedClassId || 'class_executor');

                const { username, userId } = userProfile;

                try { 
                    const existingRankingsRaw = localStorage.getItem(RANKING_KEY); 
                    let rankings = existingRankingsRaw ? JSON.parse(existingRankingsRaw) : []; 
                    
                    // AQUI usamos o ID de classe corrigido
                                        const newScoreEntry = { name: username, score, time: gameTime, class_id: classUsedId, date: new Date().toLocaleDateString(), userId: userId }; 
                    
                    rankings.push(newScoreEntry); 
                    rankings.sort((a, b) => b.score - a.score || a.time - b.time); 
                    localStorage.setItem(RANKING_KEY, JSON.stringify(rankings.slice(0, MAX_RANKING_ENTRIES))); 
                } catch (error) { 
                    console.error("Error saving score to localStorage:", error); 
                }
                
                await submitScoreToOnlineRanking(username, score, gameTime, classUsedId, userId);
            }, [permanentBuffsState.selectedClassId, userProfile]);

            const handleGameOver = useAppCallback((sessionStats) => {
                if (engineRef.current) {
                    setFinalGameStats({ score: engineRef.current.gameState.score, gameTime: engineRef.current.gameState.gameTime });
                }
                SoundManager.play('gameOver'); 
                
                const storedStatsRaw = localStorage.getItem(GLOBAL_STATS_KEY);
                const stats = storedStatsRaw ? JSON.parse(storedStatsRaw) : { totalKills: 0, totalTimePlayed: 0, highestScore: 0, highestLevel: 0, totalBossKills: {}, gamesPlayed: 0, totalXpOrbsCollected: 0, totalDashes: 0, totalHealthPickupsCollected: 0, totalCorruptedKernelsEarned: 0, totalCorruptedLibrariesCleansed: 0, totalEnemyKills: {}, totalEvolutionsUnlocked: {} };
                
                stats.totalKills = (stats.totalKills || 0) + sessionStats.totalKills;
                stats.totalTimePlayed = (stats.totalTimePlayed || 0) + sessionStats.timeSurvived;
                stats.highestScore = Math.max(stats.highestScore || 0, sessionStats.score);
                stats.highestLevel = Math.max(stats.highestLevel || 0, sessionStats.levelReached);
                stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
                stats.totalXpOrbsCollected = (stats.totalXpOrbsCollected || 0) + sessionStats.totalXpOrbsCollected;
                stats.totalDashes = (stats.totalDashes || 0) + sessionStats.totalDashes;
                stats.totalHealthPickupsCollected = (stats.totalHealthPickupsCollected || 0) + sessionStats.totalHealthPickupsCollected;
                stats.totalCorruptedKernelsEarned = (stats.totalCorruptedKernelsEarned || 0) + (sessionStats.corruptedKernelsEarnedInSession || 0);
                stats.totalCorruptedLibrariesCleansed = (stats.totalCorruptedLibrariesCleansed || 0) + (sessionStats.corruptedLibrariesCleansed || 0);

                if (typeof stats.totalBossKills !== 'object' || stats.totalBossKills === null) stats.totalBossKills = {};
                sessionStats.defeatedBosses.forEach(bossId => {
                    stats.totalBossKills[bossId] = (stats.totalBossKills[bossId] || 0) + 1;
                });
                
                stats.totalEnemyKills = stats.totalEnemyKills || {};
                Object.entries(sessionStats.kills).forEach(([type, count]) => {
                    stats.totalEnemyKills[type] = (stats.totalEnemyKills[type] || 0) + count;
                });

                stats.totalEvolutionsUnlocked = stats.totalEvolutionsUnlocked || {};
                sessionStats.evolvedWeaponIds.forEach(evoId => {
                    stats.totalEvolutionsUnlocked[evoId] = true;
                });

                localStorage.setItem(GLOBAL_STATS_KEY, JSON.stringify(stats));

                const masteryStatsRaw = localStorage.getItem(WEAPON_MASTERY_KEY) || '{}';
                const masteryStats = JSON.parse(masteryStatsRaw);
                Object.entries(sessionStats.damageDealtByWeapon).forEach(([weaponId, damage]) => {
                    if(!masteryStats[weaponId]) masteryStats[weaponId] = { damage: 0, tier3Unlocked: false };
                    masteryStats[weaponId].damage = (masteryStats[weaponId].damage || 0) + damage;
                });
                localStorage.setItem(WEAPON_MASTERY_KEY, JSON.stringify(masteryStats));
                
                sessionStats.classId = engineRef.current.gameState.player.classId;
                checkAndUnlockContent(sessionStats, stats);
                
                handleScoreSubmit(); 

                setGameScreen(GameScreenState.GAME_OVER);
                
                calculatePermanentBonuses();
            }, [checkAndUnlockContent, calculatePermanentBonuses, handleScoreSubmit]);
            
            const handleStageClear = useAppCallback((stage, isNightmare) => {
                let systemCoreReward = 0;
                let corruptedKernelReward = 0;

                if (stage === 1) systemCoreReward = SYSTEM_CORES_PER_BOSS_DEFEAT;
                else if (stage === 2) systemCoreReward = SYSTEM_CORES_PER_BOSS_2_DEFEAT;
                else if (stage === 3) systemCoreReward = SYSTEM_CORES_PER_BOSS_3_DEFEAT;
                else if (stage === 4) {
                    systemCoreReward = SYSTEM_CORES_PER_BOSS_4_DEFEAT;
                    if (!nightmareUnlocked) {
                         setNightmareUnlocked(true);
                    }
                }
                
                if (isNightmare) {
                    if (stage === 1) corruptedKernelReward = 1;
                    else if (stage === 2) corruptedKernelReward = 2;
                    else if (stage === 3) corruptedKernelReward = 3;
                    else if (stage === 4) corruptedKernelReward = 5;
                }
                if (engineRef.current && engineRef.current.sessionStatsRef.current) {
                    engineRef.current.sessionStatsRef.current.corruptedKernelsEarnedInSession += corruptedKernelReward;
                }

                setSystemCores(prev => prev + systemCoreReward);
                setCorruptedKernels(prev => prev + corruptedKernelReward);
                
                if (stage === 1) setGameScreen(GameScreenState.STAGE_CLEAR);
                else if (stage === 2) setGameScreen(GameScreenState.STAGE_2_CLEAR);
                else if (stage === 3) setGameScreen(GameScreenState.STAGE_3_CLEAR);
                else if (stage === 4) setGameScreen(GameScreenState.NEXUS_DEFEATED);
                
                SoundManager.play('levelUp'); 
                if(engineRef.current) engineRef.current.pauseGame();
            }, [nightmareUnlocked]);
            
            const handleLevelUp = useAppCallback((isFirst = false) => {
                if (engineRef.current) {
                    engineRef.current.pauseGame();
                    let rerollBudget = 1 + (permanentBuffsState.shop?.corr_capstone_utility || 0) + (permanentBuffsState.shop?.['perm_rerolls'] || 0) + (achievementBuffs.initialRerolls || 0);
                    setRerollsForCurrentLevelUp(rerollBudget);
                    setCurrentLevelUpOptions(engineRef.current.getUpgradeOptions());
                    setIsFirstLevelUp(isFirst);
                    setGameScreen(GameScreenState.LEVEL_UP);
                }
            }, [permanentBuffsState, achievementBuffs]);
            
            const handleLevelUpReroll = useAppCallback(() => {
                if (rerollsForCurrentLevelUp > 0 && engineRef.current) {
                    SoundManager.play('uiClick');
                    setRerollsForCurrentLevelUp(prev => prev - 1);
                    const newOptions = engineRef.current.getUpgradeOptions();
                    if(newOptions){
                        setCurrentLevelUpOptions(newOptions);
                    }
                }
            }, [rerollsForCurrentLevelUp]);

            const engineHookValues = useGameEngine(
                handleGameOver, handleLevelUp,
                [GameScreenState.PLAYING, GameScreenState.BOSS_FIGHT, GameScreenState.INFINITE_MODE].includes(gameScreen), 
                (stage) => setGameScreen(GameScreenState.BOSS_WARNING), 
                () => setGameScreen(GameScreenState.BOSS_FIGHT), 
                handleStageClear,
                permanentBuffsState, achievementBuffs, decompilerBonuses, weaponMasteryBonuses
            );
            const engineRef = useAppRef(engineHookValues); 
            useAppEffect(() => { engineRef.current = engineHookValues; }, [engineHookValues]);

            const startGameWithModifiers = useAppCallback((modifiers) => {
                SoundManager.play('upgradeSelect');
                engineRef.current.resetGame(permanentBuffsState, achievementBuffs, permanentBuffsState.selectedSkinId, isNightmare, Array.from(modifiers || new Set()));
                setGameScreen(GameScreenState.PLAYING);
                lastTimeRef.current = performance.now();
            }, [permanentBuffsState, achievementBuffs, isNightmare]);

            const performResumeGame = useAppCallback(() => { 
                engineRef.current.resumeGame(); 
                if (engineRef.current.gameState.isInfiniteMode) {
                    setGameScreen(GameScreenState.INFINITE_MODE);
                } else if (engineRef.current.gameState.boss) {
                    setGameScreen(GameScreenState.BOSS_FIGHT);
                } else {
                    setGameScreen(GameScreenState.PLAYING);
                }
                lastTimeRef.current = performance.now(); 
            }, []);

            const handleEnterInfiniteMode = useAppCallback(() => {
                engineRef.current.enterInfiniteMode();
                setGameScreen(GameScreenState.INFINITE_MODE);
                lastTimeRef.current = performance.now();
            }, []);

            useAppEffect(() => {
                if (gameScreen === GameScreenState.BOSS_WARNING) {
                    if (bossWarningTimerRef.current) clearTimeout(bossWarningTimerRef.current);
                    bossWarningTimerRef.current = window.setTimeout(() => {
                        const isNightmareMode = engineRef.current.gameState.isNightmareMode;
                        const currentStage = engineRef.current.gameState.stage;
                        if (currentStage === 1) engineRef.current.spawnBoss(isNightmareMode);
                        else if (currentStage === 2) engineRef.current.spawnBoss2(isNightmareMode);
                        else if (currentStage === 3) engineRef.current.spawnBoss3(isNightmareMode);
                        else if (currentStage === 4) engineRef.current.spawnBoss4(isNightmareMode);
                        
                        engineRef.current.resumeGame(); 
                        lastTimeRef.current = performance.now(); 
                    }, BOSS_WARNING_DURATION);
                }
                return () => { if (bossWarningTimerRef.current) clearTimeout(bossWarningTimerRef.current); };
            }, [gameScreen]); 

            useAppEffect(() => {
                const loop = (currentTime) => {
                    const deltaTime = (currentTime - lastTimeRef.current) / 1000;
                    lastTimeRef.current = currentTime;
                    const safeDeltaTime = Math.min(deltaTime, 0.1);

                    const isMainGamePlaying = [GameScreenState.PLAYING, GameScreenState.BOSS_FIGHT, GameScreenState.INFINITE_MODE].includes(gameScreen) && engineRef.current && !engineRef.current.gameState.isPaused;
                    const isCrisolPlaying = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE].includes(gameScreen) && crisolEngineHookValues;

                    if (isMainGamePlaying) {
                        engineRef.current.gameTick(safeDeltaTime);
                    } else if (isCrisolPlaying) {
                        crisolEngineHookValues.gameTick(safeDeltaTime);
                    }
                    
                    animationFrameIdRef.current = requestAnimationFrame(loop);
                };
                
                lastTimeRef.current = performance.now();
                animationFrameIdRef.current = requestAnimationFrame(loop);

                return () => { if (animationFrameIdRef.current) cancelAnimationFrame(animationFrameIdRef.current); };
            }, [gameScreen, crisolEngineHookValues]); 

            useAppEffect(() => {
                const keydownListener = (e) => { 
                    const key = e.key.toLowerCase(); 
                    
                    const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
                    
                    const isMainGameScreen = [GameScreenState.PLAYING, GameScreenState.BOSS_FIGHT, GameScreenState.PAUSED, GameScreenState.INFINITE_MODE].includes(gameScreen);
                    const isCrisolScreen = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE, GameScreenState.CRISOL_PAUSED].includes(gameScreen);

                    if (key === 'p' && !isTyping) { 
                        e.preventDefault(); 
                        if (isMainGameScreen) {
                            if (engineRef.current && !engineRef.current.gameState.isPaused) { 
                                SoundManager.play('uiClick'); engineRef.current.pauseGame(); setGameScreen(GameScreenState.PAUSED); 
                            } else if (gameScreen === GameScreenState.PAUSED) { 
                                SoundManager.play('uiClick'); performResumeGame(); 
                            } 
                        } else if (isCrisolScreen) {
                            if (crisolEngineRef.current && !crisolEngineRef.current.gameState.isPaused) {
                                SoundManager.play('uiClick'); crisolEngineRef.current.pauseGame(); setGameScreen(GameScreenState.CRISOL_PAUSED);
                            } else if (gameScreen === GameScreenState.CRISOL_PAUSED) {
                                SoundManager.play('uiClick'); crisolEngineRef.current.resumeGame(); setGameScreen(GameScreenState.CRISOL_CHAMBER);
                            }
                        }
                        return; 
                    }
                    
                    if (isCrisolScreen && crisolEngineRef.current && !crisolEngineRef.current.gameState.isPaused) {
                         if (['w','a','s','d',' '].includes(key)) {
                            e.preventDefault();
                            crisolEngineRef.current.handleKeys(key, true);
                         }
                    } else if (isMainGameScreen && engineRef.current) {  
                         if (['w','a','s','d',' '].includes(key)) {
                            e.preventDefault(); 
                            engineRef.current.handleKeyDown(key); 
                         }
                    } 
                };
                const keyupListener = (e) => { 
                    const key = e.key.toLowerCase();
                    if (['w','a','s','d', ' '].includes(key)) { 
                        if (engineRef.current) engineRef.current.handleKeyUp(key); 
                        if (crisolEngineRef.current) crisolEngineRef.current.handleKeys(key, false);
                    } 
                };
                window.addEventListener('keydown', keydownListener); window.addEventListener('keyup', keyupListener);
                return () => { window.removeEventListener('keydown', keydownListener); window.removeEventListener('keyup', keyupListener); };
            }, [gameScreen, performResumeGame, crisolEngineHookValues]); 
            
            const startNextStage = useAppCallback((stageNumber) => {
                engineRef.current.startNextStage(stageNumber);
                performResumeGame();
            }, [performResumeGame]);

            const uiAndCanvasVisible = [GameScreenState.PLAYING, GameScreenState.LEVEL_UP, GameScreenState.PAUSED, GameScreenState.BOSS_FIGHT, GameScreenState.BOSS_WARNING, GameScreenState.STAGE_CLEAR, GameScreenState.STAGE_2_CLEAR, GameScreenState.STAGE_3_CLEAR, GameScreenState.NEXUS_DEFEATED, GameScreenState.GAME_OVER, GameScreenState.INFINITE_MODE].includes(gameScreen);
            const crisolCanvasVisible = [GameScreenState.CRISOL_CHAMBER, GameScreenState.CRISOL_INFINITE, GameScreenState.CRISOL_PAUSED].includes(gameScreen);
            const mainHubVisible = !uiAndCanvasVisible && !crisolCanvasVisible && gameScreen !== GameScreenState.INTRO && gameScreen !== GameScreenState.CRISOL_RESULT && gameScreen !== GameScreenState.CRISOL_PAUSED;
            const currentClassDef = CLASS_DEFINITIONS.find(c => c.id === permanentBuffsState.selectedClassId) || CLASS_DEFINITIONS[0];

            let MainScreenComponent = null;
            if (mainHubVisible) {
                 switch(mainScreen) {
                    case GameScreenState.MODE_SELECTION: MainScreenComponent = React.createElement(ModeSelectionScreen, { setMainScreen, setGameScreen, onSelectMode: (mode) => setIsNightmare(mode === 'nightmare'), nightmareUnlocked }); break;
                    case GameScreenState.CRISOL_HUB: MainScreenComponent = React.createElement(CrisolHubScreen, { setMainScreen, setGameScreen, startChamber: (id) => { if(crisolEngineHookValues) { setGameScreen(GameScreenState.CRISOL_CHAMBER); crisolEngineHookValues.startChamber(id); } }, startInfinite: () => { if(crisolEngineHookValues) crisolEngineHookValues.startInfinite(); }, crisolProgress }); break;
                    case GameScreenState.CLASS_SELECTION: MainScreenComponent = React.createElement(ClassSelectionScreen, { setMainScreen, systemCores, classes: CLASS_DEFINITIONS, selectedClassId: permanentBuffsState.selectedClassId, unlockedClasses, onSelectClass: handleSelectClass, onUnlockClass: (id, cost) => { if (systemCores >= cost) { updateSystemCores(systemCores - cost); addUnlockedClass(id); }} }); break;
                    case GameScreenState.EVOLUTION_GUIDE: MainScreenComponent = React.createElement(EvolutionGuideScreen, { setMainScreen }); break;
                    case GameScreenState.SKIN_SELECTION: MainScreenComponent = React.createElement(SkinSelectionScreen, { setMainScreen, systemCores, corruptedKernels, unlockedSkins, equippedSkinId: permanentBuffsState.selectedSkinId, onEquipSkin: handleEquipSkin, onUnlockSkin: handleUnlockSkin, onUnlockSkinCorrupted: handleUnlockSkinCorrupted }); break;
                    case GameScreenState.MODIFIER_SELECTION: MainScreenComponent = React.createElement(ModifierSelectionScreen, { setMainScreen, startGameWithModifiers }); break; 
                    case GameScreenState.TALENT_TREE: MainScreenComponent = React.createElement(TalentTreeScreen, { systemCores, corruptedKernels, permanentBuffs: permanentBuffsState.shop, updateSystemCores, updateCorruptedKernels, updatePermanentBuff }); break;
                    case GameScreenState.ARSENAL: MainScreenComponent = React.createElement(ArsenalScreen, { corruptedKernels, updateCorruptedKernels }); break;
                    case GameScreenState.DECOMPILER: MainScreenComponent = React.createElement(DecompilerScreen, {}); break;
                    case GameScreenState.ACHIEVEMENTS: MainScreenComponent = React.createElement(AchievementsScreen, { unlockedAchievements }); break;
                    case GameScreenState.RANKING: MainScreenComponent = React.createElement(RankingScreen, {}); break;
                    case GameScreenState.GLOBAL_STATS: MainScreenComponent = React.createElement(GlobalStatsScreen, { permanentBuffs: permanentBuffsState, achievementBuffs }); break;
                    case GameScreenState.CODEX: MainScreenComponent = React.createElement(CodexScreen, {}); break;
                    case GameScreenState.PATCH_NOTES: MainScreenComponent = React.createElement(PatchNotesScreen, {}); break;
                    case GameScreenState.SETTINGS: MainScreenComponent = React.createElement(SettingsScreen, { soundSettings, onVolumeChange: handleVolumeChange, onMuteToggle: handleMuteToggle, setGameScreen }); break;
                    case GameScreenState.PROFILE: MainScreenComponent = React.createElement(ProfileScreen, { userProfile, updateProfile, unlockedAchievements }); break;
                 }
            }
            
            const crisolChamberData = crisolEngineHookValues.gameState.chamberId
                ? CRISOL_CHAMBERS.find(c => c.id === crisolEngineHookValues.gameState.chamberId)
                : null;

            return React.createElement('div', { className: "w-full h-full flex flex-col items-center justify-start relative bg-[#010409]" },
                React.createElement('div', { className: 'fixed top-28 right-4 z-50 flex flex-col items-end space-y-2' },
                    toastQueue.map((ach, index) => 
                        React.createElement(AchievementToast, { 
                            key: ach.id + index,
                            achievement: ach, 
                            onDismiss: () => setToastQueue(q => q.filter((_, i) => i !== 0))
                        })
                    )
                ),

                gameScreen === GameScreenState.CRISOL_PAUSED && React.createElement(CrisolPauseScreen, {
                    onResume: () => { SoundManager.play('uiClick'); crisolEngineRef.current.resumeGame(); setGameScreen(GameScreenState.CRISOL_CHAMBER); },
                    onRestart: handleCrisolRestart,
                    onReturnToHub: handleCrisolReturnToHub
                }),

                gameScreen === GameScreenState.INTRO && React.createElement(IntroScreen, { onStart: () => { SoundManager.play('uiClick'); setGameScreen(GameScreenState.MODE_SELECTION); setMainScreen(GameScreenState.MODE_SELECTION); } }),
                mainHubVisible && React.createElement(MainLayout, null,
                    React.createElement(Sidebar, { activeScreen: mainScreen, setScreen: setMainScreen }),
                    React.createElement('main', { className: 'flex-grow h-full overflow-y-auto' }, MainScreenComponent)
                ),
                
                mainHubVisible && userProfile && React.createElement(ChatPanel, { userProfile }),

                uiAndCanvasVisible && engineHookValues && React.createElement(React.Fragment, null,
                    gameScreen === GameScreenState.GAME_OVER && React.createElement(GameOverScreen, { setMainScreen, setGameScreen, gameTime: finalGameStats.gameTime, score: finalGameStats.score }),
                    gameScreen === GameScreenState.LEVEL_UP && React.createElement(LevelUpScreen, { resumeGame: performResumeGame, options: currentLevelUpOptions, applyUpgrade: engineHookValues.applyUpgrade, onReroll: handleLevelUpReroll, rerollsAvailable: rerollsForCurrentLevelUp, isFirstLevelUp: isFirstLevelUp }),
                    gameScreen === GameScreenState.PAUSED && React.createElement(PauseScreen, { setMainScreen, setGameScreen, resumeGameCallback: performResumeGame, startGameCallback: () => startGameWithModifiers(new Set((engineHookValues.gameState.player.activeModifiers || []).map(m => m.id))), ownedUpgrades: engineHookValues.ownedUpgradesRef.current, activeClass: currentClassDef, soundSettings: soundSettings, onVolumeChange: handleVolumeChange, onMuteToggle: handleMuteToggle, engineRef: engineHookValues }),
                    gameScreen === GameScreenState.BOSS_WARNING && React.createElement(BossWarningScreen, { stage: engineHookValues.gameState.stage }),
                    gameScreen === GameScreenState.STAGE_CLEAR && React.createElement(StageClearScreen, { startNextStageCallback: startNextStage }),
                    gameScreen === GameScreenState.STAGE_2_CLEAR && React.createElement(StageClearScreen2, { startNextStageCallback: startNextStage }),
                    gameScreen === GameScreenState.STAGE_3_CLEAR && React.createElement(StageClearScreen3, { startNextStageCallback: startNextStage }),
                    gameScreen === GameScreenState.NEXUS_DEFEATED && React.createElement(NexusDefeatedScreen, { resumeGameCallback: handleEnterInfiniteMode })
                ),
                
                gameScreen === GameScreenState.CRISOL_RESULT && (
                    React.createElement(CrisolResultScreen, { 
                        result: crisolResult, 
                        setGameScreen, 
                        startChamber: (id) => { if(crisolEngineHookValues) { setGameScreen(GameScreenState.CRISOL_CHAMBER); crisolEngineHookValues.startChamber(id); } }, 
                        startInfinite: () => { if(crisolEngineHookValues) crisolEngineHookValues.startInfinite(); }, 
                        crisolProgress, 
                        setMainScreen 
                    })
                ),

                (uiAndCanvasVisible || crisolCanvasVisible) && (
                    React.createElement('div', { className: 'w-full h-full flex flex-row' },
                        uiAndCanvasVisible && engineHookValues ? React.createElement(LeftSidebar, { gameState: engineHookValues.gameState }) : React.createElement('div', { className: 'w-56 flex-shrink-0 bg-black/50' }),
                        
                        React.createElement('div', { className: 'flex-grow h-full flex flex-col items-center justify-center relative' },
                            uiAndCanvasVisible && engineHookValues && React.createElement(UIOverlay, { gameState: engineHookValues.gameState }),
                            crisolCanvasVisible && crisolEngineHookValues && React.createElement(CrisolUI, { gameState: crisolEngineHookValues.gameState, chamberData: crisolChamberData }),
                            
                            React.createElement(GameCanvas, { 
                                gameState: uiAndCanvasVisible && engineHookValues ? engineHookValues.gameState : null, 
                                gameScreen, 
                                crisolGameState: crisolCanvasVisible && crisolEngineHookValues ? crisolEngineHookValues.gameState : null
                            })
                        ),

                        uiAndCanvasVisible && engineHookValues ? React.createElement(RightSidebar, { gameState: engineHookValues.gameState }) : React.createElement('div', { className: 'w-56 flex-shrink-0 bg-black/50' })
                    )
                )
            );
        };
        // --- END OF App.tsx ---

        // --- START OF index.tsx (ReactDOM rendering) ---
        const rootElement = document.getElementById('root');
        if (!rootElement) { throw new Error("Could not find root element to mount to"); }
        const root = ReactDOM.createRoot(rootElement);
        root.render( React.createElement(React.StrictMode, null, React.createElement(App)) );
        // --- END OF index.tsx ---
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>